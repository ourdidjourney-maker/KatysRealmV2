<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shell World - Wireframe Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000000; color: #e0e0e0; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        #hide-ui-button { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(80, 80, 80, 0.4); color: #888; padding: 4px 10px; border-radius: 12px; cursor: pointer; font-size: 10px; z-index: 1000; transition: all 0.3s; backdrop-filter: blur(5px); width: auto; }
        #hide-ui-button:hover { background: rgba(20, 20, 20, 0.8); color: #ccc; }
        .ui-hidden #hide-ui-button { background: rgba(0, 0, 0, 0.4); }
        .overlay-panel { transition: opacity 0.4s ease, transform 0.4s ease; }
.ui-hidden .overlay-panel, .ui-hidden #fps-counter { opacity: 0; pointer-events: none; transform: translateY(10px); }
#info-panel { position: absolute; top: 50%; left: 15px; transform: translateY(-50%); background: rgba(0, 0, 0, 0.75); padding: 12px; border-radius: 10px; border: 1px solid rgba(60, 60, 60, 0.4); max-width: 260px; max-height: 85vh; overflow-y: auto; backdrop-filter: blur(10px); scrollbar-width: none; -ms-overflow-style: none; }
#info-panel::-webkit-scrollbar { display: none; }
#info-panel h1 { font-size: 15px; margin-bottom: 8px; color: #64b5f6; }
#info-panel h2 { font-size: 10px; margin-top: 6px; margin-bottom: 3px; color: #81c784; }
#info-panel ul { list-style: none; padding-left: 0; }
#info-panel li { margin: 2px 0; padding-left: 10px; position: relative; font-size: 9px; line-height: 1.3; color: #aaa; }
#info-panel::-webkit-scrollbar { width: 4px; }
#info-panel::-webkit-scrollbar-thumb { background: rgba(50,50,50,0.8); border-radius: 2px; }
#info-panel h1 { font-size: 11px; margin-bottom: 3px; color: #64b5f6; }
#info-panel h2 { font-size: 7px; margin-top: 2px; margin-bottom: 0px; color: #81c784; }
#info-panel ul { list-style: none; padding-left: 0; margin: 0; }
#info-panel li { margin: 0; padding-left: 6px; position: relative; font-size: 7px; line-height: 1.1; color: #aaa; }
        #info-panel h1 { font-size: 15px; margin-bottom: 8px; color: #64b5f6; }
        #info-panel h2 { font-size: 10px; margin-top: 6px; margin-bottom: 3px; color: #81c784; }
        #info-panel ul { list-style: none; padding-left: 0; }
        #info-panel li { margin: 2px 0; padding-left: 10px; position: relative; font-size: 9px; line-height: 1.3; color: #aaa; }
        #info-panel li:before { content: ">"; position: absolute; left: 0; color: #64b5f6; font-size: 8px; }
        .highlight { color: #ffd54f; font-weight: 600; }
#dimension-controls { position: absolute; top: 50%; right: 15px; transform: translateY(-50%); background: rgba(0, 0, 0, 0.75); padding: 10px; border-radius: 8px; border: 1px solid rgba(60, 60, 60, 0.4); backdrop-filter: blur(10px); min-width: 170px; max-width: 190px; font-size: 9px; max-height: 85vh; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none; }
        #dimension-controls::-webkit-scrollbar { display: none; }
        #dimension-controls h3 { color: #64b5f6; margin-bottom: 6px; font-size: 10px; }
        .control-group { margin-bottom: 5px; }
        .control-group label { display: block; color: #aaa; font-size: 9px; margin-bottom: 1px; }
        .control-group input[type="range"] { width: 100%; margin: 2px 0; height: 3px; }
        .control-group .value-display { color: #ffd54f; font-size: 9px; font-weight: 600; }
        button { background: rgba(40, 40, 40, 0.6); border: 1px solid rgba(80, 80, 80, 0.4); color: #bbb; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 9px; margin-top: 2px; width: 100%; transition: all 0.3s; }
        button:hover { background: rgba(60, 60, 60, 0.7); color: #ddd; }
        button.active { background: rgba(255, 152, 0, 0.3); border-color: rgba(255, 152, 0, 0.6); color: #ffcc80; }
        #controls { position: absolute; bottom: 15px; left: 15px; background: rgba(0, 0, 0, 0.75); padding: 8px; border-radius: 8px; border: 1px solid rgba(60, 60, 60, 0.4); backdrop-filter: blur(10px); }
        #controls p { margin: 2px 0; font-size: 9px; color: #777; }
        #controls p strong { color: #999; }
        .legend { position: absolute; top: 15px; right: 15px; background: rgba(0, 0, 0, 0.75); padding: 8px; border-radius: 8px; border: 1px solid rgba(60, 60, 60, 0.4); backdrop-filter: blur(10px); }
        .legend-item { display: flex; align-items: center; margin: 3px 0; font-size: 9px; color: #999; }
        .legend-line { width: 18px; height: 2px; margin-right: 6px; border-radius: 2px; }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 3px; background: rgba(120, 120, 120, 0.5); border-radius: 2px; outline: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; background: #64b5f6; border-radius: 50%; cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 10px; height: 10px; background: #64b5f6; border-radius: 50%; cursor: pointer; border: none; }
        #axis-drag-indicator, #meteor-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 213, 79, 0.9); color: #000; padding: 5px 10px; border-radius: 12px; font-size: 10px; font-weight: 600; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 100; }
        #meteor-indicator { top: 58%; background: rgba(255, 152, 0, 0.9); }
        #axis-drag-indicator.visible, #meteor-indicator.visible { opacity: 1; }
        #meteor-count-display { position: absolute; top: 55px; right: 15px; background: rgba(255, 152, 0, 0.8); color: #000; padding: 3px 8px; border-radius: 10px; font-size: 9px; font-weight: 600; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 100; }
        #meteor-count-display.visible { opacity: 1; }
#fps-counter { position: fixed; top: 5px; left: 50%; transform: translateX(-50%); color: #333; font-size: 10px; font-family: monospace; pointer-events: none; z-index: 9999; opacity: 0.6; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="fps-counter">-- FPS</div>
    <div id="axis-drag-indicator">Drag to rotate stars</div>
    <div id="meteor-indicator">Click shell to start/stop shower</div>
    <div id="meteor-count-display">Active: <span id="shower-count">0</span></div>
    <button id="hide-ui-button">Hide UI</button>
    <canvas id="upper-snow-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50;"></canvas>
<canvas id="upper-frost-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 51;"></canvas>
<canvas id="under-snow-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50;"></canvas>
<canvas id="under-frost-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 51;"></canvas>
<canvas id="fimbul-frost-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 51;"></canvas>
<canvas id="lens-flare-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 52;"></canvas>
<canvas id="lightning-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 53;"></canvas>
   
<div id="grid-tooltip" style="position: absolute; display: none; background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(30,25,0,0.9) 100%); border: 2px solid #ffdd44; border-radius: 10px; padding: 12px 16px; font-size: 14px; pointer-events: none; z-index: 1000; min-width: 220px; transform: perspective(300px) rotateY(-15deg) rotateX(5deg) skewY(-2deg); box-shadow: 8px 8px 20px rgba(255,221,68,0.4), -3px -3px 15px rgba(255,221,68,0.2), inset 0 0 30px rgba(255,221,68,0.05); border-left: 6px solid #ffdd44;">
    <div style="color: #ffdd44; font-weight: bold; margin-bottom: 8px; font-size: 16px;" id="tooltip-hemisphere">UPPER HEMISPHERE</div>
    <div style="color: #aaa;">X: <span style="color: #44ddff;" id="tooltip-x">0</span> mi</div>
    <div style="color: #aaa;">Y: <span style="color: #ff44dd;" id="tooltip-y">0</span> mi</div>
    <div style="color: #aaa;" id="tooltip-z-label">Z↑: <span style="color: #ffdd44;" id="tooltip-z">0</span> mi</div>
    <div style="color: #aaa;">Quadrant: <span style="color: #88ff88; font-weight: bold;" id="tooltip-quadrant">Q1</span></div>
    <div style="color: #aaa; margin-top: 8px; padding-top: 8px; border-top: 1px solid #444;">Arc to Equator: <span style="color: #fff; font-weight: bold;" id="tooltip-arc">0</span> mi</div>
</div>

<div id="strata-tooltip" style="position: absolute; display: none; background: linear-gradient(225deg, rgba(0,0,0,0.95) 0%, rgba(0,25,20,0.9) 100%); border: 2px solid #44ffaa; border-radius: 10px; padding: 12px 16px; font-size: 14px; pointer-events: none; z-index: 1000; min-width: 220px; transform: perspective(300px) rotateY(15deg) rotateX(-5deg) skewY(2deg); box-shadow: -8px 8px 20px rgba(68,255,170,0.4), 3px -3px 15px rgba(68,255,170,0.2), inset 0 0 30px rgba(68,255,170,0.05); border-left: 6px solid #44ffaa;">
    <div style="color: #44ffaa; font-weight: bold; margin-bottom: 8px; font-size: 16px;" id="strata-tooltip-surface">UPPER SURFACE</div>
    <div style="color: #aaa;">X: <span style="color: #44ddff;" id="strata-tooltip-x">0</span> mi</div>
    <div style="color: #aaa;">Y: <span style="color: #ff44dd;" id="strata-tooltip-y">0</span> mi</div>
    <div style="color: #aaa;" id="strata-tooltip-z-label">Z↑: <span style="color: #44ffaa;" id="strata-tooltip-z">0</span> mi</div>
    <div style="color: #aaa;">Quadrant: <span style="color: #88ff88; font-weight: bold;" id="strata-tooltip-quadrant">Q1</span></div>
    <div style="color: #aaa; margin-top: 8px; padding-top: 8px; border-top: 1px solid #444;">Distance from Center: <span style="color: #fff; font-weight: bold;" id="strata-tooltip-dist">0</span> mi</div>
</div>
   
    <div id="info-panel" class="overlay-panel">
        <h1>Shell World | Katy's Realm</h1>
        <h2>Shell Sphere</h2>
        <ul>
            <li>Radius: <span class="highlight" id="shell-info">4,039 mi</span></li>
            <li>Diameter: <span class="highlight" id="shell-diameter">8,078 mi</span></li>
            <li>Circumference: <span class="highlight" id="shell-circum">~25,375 mi</span></li>
        </ul>
        <h2>Earth Disk</h2>
        <ul>
            <li>Radius: <span class="highlight" id="disk-info">3,959 mi</span></li>
            <li>Circumference: <span class="highlight" id="disk-circum">~24,875 mi</span></li>
            <li>Thickness: <span class="highlight" id="thickness-info">1,980 mi</span></li>
        </ul>
        <h2>Gulf</h2>
        <ul><li>Shell to Disk: <span class="highlight" id="gap-info">80 mi</span></li></ul>
        <h2>Heights & Distances</h2>
        <ul>
            <li>Sky Height: <span class="highlight" id="sky-height-info">3,049 mi</span></li>
            <li>Underworld Depth: <span class="highlight" id="underworld-depth-info">3,049 mi</span></li>
            <li>Stars from Surface: <span class="highlight" id="stars-surface-info">2,987 mi</span></li>
            <li>Meteors from Surface: <span class="highlight" id="meteors-surface-info">3,049 mi</span></li>
        </ul>
<h2 style="color: #ffdd44;">Sun Metrics</h2>
<ul>
    <li>Altitude: <span class="highlight" id="sun-altitude-info">0 mi</span></li>
    <li>Orbital Radius: <span class="highlight" id="sun-orbital-info">0 mi</span></li>
    <li>Orbital Speed: <span class="highlight" id="sun-orbital-speed-info">0 mi/hr</span></li>
    <li>Vertical Speed: <span class="highlight" id="sun-vertical-speed-info">0 mi/hr</span></li>
    <li>Total Speed: <span class="highlight" id="sun-total-speed-info">0 mi/hr</span></li>
</ul>
<h2 style="color: #ffdd44;">Sun Position</h2>
<ul>
    <li style="color: #ffdd44;">Shell: <span class="highlight" id="sun-shell-coords">--</span></li>
    <li style="color: #44ffaa;">Strata: <span class="highlight" id="sun-strata-coords">--</span></li>
</ul>
<h2 style="color: #aabbdd;">Moon Metrics</h2>
<ul>
    <li>Altitude: <span class="highlight" id="moon-altitude-info">0 mi</span></li>
    <li>Orbital Radius: <span class="highlight" id="moon-orbital-info">0 mi</span></li>
    <li>Orbital Speed: <span class="highlight" id="moon-orbital-speed-info">0 mi/hr</span></li>
    <li>Vertical Speed: <span class="highlight" id="moon-vertical-speed-info">0 mi/hr</span></li>
    <li>Total Speed: <span class="highlight" id="moon-total-speed-info">0 mi/hr</span></li>
    <li>Phase: <span class="highlight" id="moon-phase-info">Full</span></li>
</ul>
<h2 style="color: #aabbdd;"> Moon Position</h2>
<ul>
    <li style="color: #ffdd44;">Shell: <span class="highlight" id="moon-shell-coords">--</span></li>
    <li style="color: #44ffaa;">Strata: <span class="highlight" id="moon-strata-coords">--</span></li>
</ul>
<h2 style="color: #ff4444;">Underworld Sun</h2>
<ul>
    <li>Altitude: <span class="highlight" id="usun-altitude-info">0 mi</span></li>
    <li>Orbital Radius: <span class="highlight" id="usun-orbital-info">0 mi</span></li>
    <li>Phase: <span class="highlight" id="usun-phase-info">--</span></li>
</ul>
<h2 style="color: #ff4444;">Underworld Sun Position</h2>
<ul>
    <li style="color: #ffdd44;">Shell: <span class="highlight" id="usun-shell-coords">--</span></li>
    <li style="color: #44ffaa;">Strata: <span class="highlight" id="usun-strata-coords">--</span></li>
</ul>
<h2 style="color: #4444aa;">Underworld Moon</h2>
<ul>
    <li>Altitude: <span class="highlight" id="umoon-altitude-info">0 mi</span></li>
    <li>Orbital Radius: <span class="highlight" id="umoon-orbital-info">0 mi</span></li>
    <li>Phase: <span class="highlight" id="umoon-phase-info">--</span></li>
</ul>
<h2 style="color: #4444aa;">Underworld Moon Position</h2>
<ul>
    <li style="color: #ffdd44;">Shell: <span class="highlight" id="umoon-shell-coords">--</span></li>
    <li style="color: #44ffaa;">Strata: <span class="highlight" id="umoon-strata-coords">--</span></li>
</ul>
<h2 style="color: linear-gradient(90deg, #ffdd44, #aabbff);">Luminary Distance</h2>
<ul>
    <li>Distance: <span class="highlight" id="luminary-distance-info">0 mi</span></li>
</ul>
<h2 style="color: #aa4466;">Underworld Luminary Distance</h2>
<ul>
    <li>Distance: <span class="highlight" id="underworld-luminary-distance-info">0 mi</span></li>
</ul>
<h2>Star Axis Tilt</h2>
        <ul>
            <li>X: <span class="highlight" id="axis-x-info">0</span></li>
            <li>Y: <span class="highlight" id="axis-y-info">0</span></li>
            <li>Z: <span class="highlight" id="axis-z-info">0</span></li>
        </ul>
    </div>
   
    <div id="dimension-controls" class="overlay-panel">
        <h3>Controls</h3>
        <div class="control-group"><label>Shell Radius: <span class="value-display" id="shell-radius-value">4039 mi</span></label><input type="range" id="shell-radius" min="1000" max="25000" value="4039" step="100"></div>
        <div class="control-group"><label>Disk Radius: <span class="value-display" id="earth-radius-value">3959 mi</span></label><input type="range" id="earth-radius" min="500" max="24000" value="3959" step="100"></div>
        <div class="control-group"><label>Disk Thickness: <span class="value-display" id="strata-thickness-value">1980 mi</span></label><input type="range" id="strata-thickness" min="10" max="12000" value="1980" step="50"></div>
        <div class="control-group"><label>Starfield Radius: <span class="value-display" id="starfield-radius-value">3977 mi</span></label><input type="range" id="starfield-radius" min="500" max="25000" value="3977" step="100"></div>
        <div class="control-group"><label>Starfield Speed: <span class="value-display" id="starfield-speed-value">1.0x</span></label><input type="range" id="starfield-speed" min="0" max="5" value="1" step="0.1"></div>
        <div class="control-group"><label>Star Brightness: <span class="value-display" id="star-brightness-value">1.00</span></label><input type="range" id="star-brightness" min="0.1" max="2.0" value="1.0" step="0.05"></div>
        <div class="control-group"><label>Twinkle: <span class="value-display" id="twinkle-value">0.5</span></label><input type="range" id="twinkle-intensity" min="0" max="1.0" value="0.5" step="0.1"></div>
        <div class="control-group"><label>Star Glow Size: <span class="value-display" id="glow-size-value">1.8</span></label><input type="range" id="glow-size" min="1.0" max="3.0" value="1.8" step="0.1"></div>
        <div class="control-group"><label>Core Sharpness: <span class="value-display" id="core-sharpness-value">0.6</span></label><input type="range" id="core-sharpness" min="0.2" max="1.0" value="0.6" step="0.05"></div>
        <div class="control-group"><label>Glow Intensity: <span class="value-display" id="glow-intensity-value">0.15</span></label><input type="range" id="glow-intensity" min="0.02" max="0.3" value="0.15" step="0.01"></div>
        <div class="control-group"><label>Meteor Rate: <span class="value-display" id="meteor-count-value">80</span>/sec</label><input type="range" id="meteor-count" min="20" max="200" value="80" step="10"></div>
        <h3 style="margin-top: 8px; color: #ffdd44;"> Sun</h3>
        <div class="control-group"><label>Sun Speed: <span class="value-display" id="sun-speed-value">1.0x</span></label><input type="range" id="sun-speed" min="0" max="50" value="1" step="0.5"></div>
        <div class="control-group"><label>Sun Brightness: <span class="value-display" id="sun-brightness-value">1.5</span></label><input type="range" id="sun-brightness" min="0.1" max="5" value="1.5" step="0.1"></div>
        <div class="control-group"><label>Sun Size: <span class="value-display" id="sun-size-value">124 mi</span></label><input type="range" id="sun-size" min="10" max="2000" value="124" step="10"></div>
        <div class="control-group"><label>Sun Height: <span class="value-display" id="sun-height-value">1243 mi</span></label><input type="range" id="sun-height" min="100" max="15000" value="1243" step="100"></div>
        <div class="control-group"><label>Sun Inner Orbit: <span class="value-display" id="sun-radius-min-value">621 mi</span></label><input type="range" id="sun-radius-min" min="10" max="15000" value="621" step="50"></div>
        <div class="control-group"><label>Sun Outer Orbit: <span class="value-display" id="sun-radius-max-value">3107 mi</span></label><input type="range" id="sun-radius-max" min="100" max="20000" value="3107" step="50"></div>
        <div class="control-group"><label>Sun Light Radius: <span class="value-display" id="sun-light-radius-value">8000 mi</span></label><input type="range" id="sun-light-radius" min="500" max="50000" value="8000" step="500"></div>
        <h3 style="margin-top: 8px; color: #aaaaff;">Moon</h3>
        <div class="control-group"><label>Moon Speed: <span class="value-display" id="moon-speed-value">0.97x</span></label><input type="range" id="moon-speed" min="0" max="50" value="0.97" step="0.5"></div>
        <div class="control-group"><label>Moon Brightness: <span class="value-display" id="moon-brightness-value">0.8</span></label><input type="range" id="moon-brightness" min="0.1" max="3" value="0.8" step="0.1"></div>
        <div class="control-group"><label>Moon Size: <span class="value-display" id="moon-size-value">112 mi</span></label><input type="range" id="moon-size" min="10" max="2000" value="112" step="10"></div>
        <div class="control-group"><label>Moon Height: <span class="value-display" id="moon-height-value">1118 mi</span></label><input type="range" id="moon-height" min="100" max="15000" value="1118" step="100"></div>
        <div class="control-group"><label>Moon Inner Orbit: <span class="value-display" id="moon-radius-min-value">621 mi</span></label><input type="range" id="moon-radius-min" min="10" max="15000" value="621" step="50"></div>
        <div class="control-group"><label>Moon Outer Orbit: <span class="value-display" id="moon-radius-max-value">3107 mi</span></label><input type="range" id="moon-radius-max" min="100" max="20000" value="3107" step="50"></div>
        <div class="control-group"><label>Moon Light Radius: <span class="value-display" id="moon-light-radius-value">6000 mi</span></label><input type="range" id="moon-light-radius" min="500" max="50000" value="6000" step="500"></div>
        <div class="control-group"><label>Interference Curve: <span class="value-display" id="interference-duration-value">0.12</span></label><input type="range" id="interference-duration" min="0.05" max="1.0" value="0.12" step="0.01"></div>
        <h3 style="margin-top: 8px; color: #ff4444;"> Underworld Sun</h3>
<div class="control-group"><label>Underworld Sun Speed: <span class="value-display" id="usun-speed-value">1.0x</span></label><input type="range" id="usun-speed" min="0" max="50" value="1" step="0.5"></div>
<div class="control-group"><label>Underworld Sun Brightness: <span class="value-display" id="usun-brightness-value">1.5</span></label><input type="range" id="usun-brightness" min="0.1" max="5" value="1.5" step="0.1"></div>
<div class="control-group"><label>Underworld Sun Size: <span class="value-display" id="usun-size-value">124 mi</span></label><input type="range" id="usun-size" min="10" max="2000" value="124" step="10"></div>
<div class="control-group"><label>Underworld Sun Height: <span class="value-display" id="usun-height-value">1243 mi</span></label><input type="range" id="usun-height" min="100" max="15000" value="1243" step="100"></div>
<div class="control-group"><label>Underworld Sun Inner Orbit: <span class="value-display" id="usun-radius-min-value">621 mi</span></label><input type="range" id="usun-radius-min" min="10" max="15000" value="621" step="50"></div>
<div class="control-group"><label>Underworld Sun Outer Orbit: <span class="value-display" id="usun-radius-max-value">3107 mi</span></label><input type="range" id="usun-radius-max" min="100" max="20000" value="3107" step="50"></div>
<div class="control-group"><label>Underworld Sun Light Radius: <span class="value-display" id="usun-light-radius-value">8000 mi</span></label><input type="range" id="usun-light-radius" min="500" max="50000" value="8000" step="500"></div>
<h3 style="margin-top: 8px; color: #4444aa;"> Underworld Moon</h3>
<div class="control-group"><label>Underworld Moon Speed: <span class="value-display" id="umoon-speed-value">0.97x</span></label><input type="range" id="umoon-speed" min="0" max="50" value="0.97" step="0.5"></div>
<div class="control-group"><label>Underworld Moon Brightness: <span class="value-display" id="umoon-brightness-value">0.8</span></label><input type="range" id="umoon-brightness" min="0.1" max="3" value="0.8" step="0.1"></div>
<div class="control-group"><label>Underworld Moon Size: <span class="value-display" id="umoon-size-value">112 mi</span></label><input type="range" id="umoon-size" min="10" max="2000" value="112" step="10"></div>
<div class="control-group"><label>Underworld Moon Height: <span class="value-display" id="umoon-height-value">1118 mi</span></label><input type="range" id="umoon-height" min="100" max="15000" value="1118" step="100"></div>
<div class="control-group"><label>Underworld Moon Inner Orbit: <span class="value-display" id="umoon-radius-min-value">621 mi</span></label><input type="range" id="umoon-radius-min" min="10" max="15000" value="621" step="50"></div>
<div class="control-group"><label>Underworld Moon Outer Orbit: <span class="value-display" id="umoon-radius-max-value">3107 mi</span></label><input type="range" id="umoon-radius-max" min="100" max="20000" value="3107" step="50"></div>
<div class="control-group"><label>Underworld Moon Light Radius: <span class="value-display" id="umoon-light-radius-value">6000 mi</span></label><input type="range" id="umoon-light-radius" min="500" max="50000" value="6000" step="500"></div>
<div class="control-group"><label>Underworld Moon Interference: <span class="value-display" id="umoon-interference-value">0.12</span></label><input type="range" id="umoon-interference" min="0.05" max="1.0" value="0.12" step="0.01"></div>
        <button id="toggle-realistic-lighting-button">Realistic Lighting</button>
        <button id="ground-view-button">Upper Realm Ground View</button>
        <button id="mid-view-button">Upper Realm Mid Plane View</button>
        <button id="edge-view-button">Upper Realm Edge Plane View</button>
        <button id="toggle-luminary-link-button">Upper Realm Luminary Distance</button>
        <button id="sun-view-button">Upper Realm Sun View</button>
        <button id="moon-view-button">Upper Realm Moon View</button>
        <button id="toggle-interference-button">Upper Moon Phases</button>
        <button id="usun-view-button">Underworld Sun View</button>
        <button id="umoon-view-button">Underworld Moon View</button>
        <button id="toggle-umoon-interference-button">Underworld Moon Phases</button>
        <button id="toggle-underworld-link-button">Underworld Luminary Distance</button>
        <button id="underworld-view-button">Underworld Ground View</button>
        <button id="underworld-mid-view-button">Underworld Mid Plane View</button> 
        <button id="underworld-edge-view-button">Underworld Edge View</button>
        <button id="toggle-resonance-button">Shell Resonance</button>
        <button id="shooting-stars-button">Shooting Stars</button>
        <button id="meteor-mode-button">Leonid Shower</button>
        <button id="stop-meteors-button">Clear Leonids</button>
        <button id="toggle-strata-wire-button">Strata Wireframe</button>
        <button id="toggle-starfield-button">Hide Starfield</button>
        <button id="toggle-shell-button">Hide Shell</button>
        <button id="toggle-horizon-button">Hide Gulf</button>
        <button id="toggle-sun-button">Hide Upper Realm Sun</button>
        <button id="toggle-moon-button">Hide Upper Realm Moon</button>
        <button id="toggle-underworld-sun-button">Hide Underworld Sun</button>
        <button id="toggle-underworld-moon-button">Hide Underworld Moon</button>
        <button id="toggle-axes-button">Hide Axes</button>
        <button id="toggle-lens-flare-button">Lens Flare</button>
        <button id="toggle-ripple-button">Gulf Ripple</button>
        <button id="random-lightning-button">Random Lightning</button>
        <button id="toggle-strata-grid-button">Strata Coordinates</button>
        <button id="toggle-shell-grid-button">Kayleigh Coordinates</button>
        <button id="reset-axis-button">Reset Star Axis</button>
        <button id="reset-button">Reset Realm</button>
    </div>
   
    <div id="controls" class="overlay-panel" style="display: none;">
        <p><strong>Mouse:</strong></p>
        <p>Left Drag: Rotate | Right Drag: Pan | Scroll: Zoom</p>
        <p><strong style="color: #ffd54f;">Star Axis:</strong> Drag to tilt</p>
        <p><strong style="color: #ff9800;">Meteors:</strong> Enable + click shell</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let uiVisible = true;
        document.getElementById('hide-ui-button').addEventListener('click', () => {
            uiVisible = !uiVisible;
            document.body.classList.toggle('ui-hidden', !uiVisible);
            document.getElementById('hide-ui-button').textContent = uiVisible ? 'Hide UI' : 'Show UI';
        });
       
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 500000);
        camera.position.set(12000, 7000, 12000);
        let originalFOV = 50, groundViewFOV = 90;
        const MOVE_SPEED = 50;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);
       
        const raycaster = new THREE.Raycaster();
        raycaster.params.Line.threshold = 300;
        const mouse = new THREE.Vector2();
        const ambientLight = new THREE.AmbientLight(0.0);
        scene.add(ambientLight);
       
        let SHELL_RADIUS = 4039, DISK_RADIUS = 3959, DISK_THICKNESS = 1980, STARFIELD_RADIUS = 3977;
        let STARFIELD_SPEED = 1.0, STAR_BRIGHTNESS = 1.0, TWINKLE_INTENSITY = 0.5;
        let GLOW_SIZE = 1.8, CORE_SHARPNESS = 0.6, GLOW_INTENSITY = 0.15;
        let METEOR_RATE = 80;
       
        // Sun and Moon parameters
        let SUN_SPEED = 1.0, MOON_SPEED = 0.97; // Moon slightly slower (lunar month)
        let SUN_HEIGHT = 1243, MOON_HEIGHT = 1118;
        let SUN_RADIUS_MIN = 621, SUN_RADIUS_MAX = 3107; // Radial in-out range
        let MOON_RADIUS_MIN = 621, MOON_RADIUS_MAX = 3107;
        let SUN_SIZE = 124, MOON_SIZE = 112;
        let SUN_BRIGHTNESS = 1.5, MOON_BRIGHTNESS = 0.8;
        let SUN_LIGHT_RADIUS = 8000, MOON_LIGHT_RADIUS = 6000; // Light reach distance
        let INTERFERENCE_DURATION = 0.12; // Controls blackout curve (lower = longer darkness)
        let sunAngle = 0, moonAngle = Math.PI; // Start opposite each other
        let sunRadialPhase = -Math.PI / 2, moonRadialPhase = -Math.PI / 2; // Start at HIGHEST point (inner orbit, full brightness)
        let sunVisible = true, moonVisible = true, moonInterferenceEnabled = true;
let isSunView = false, isMoonView = false, isUSunView = false, isUMoonView = false;
let luminaryViewAngles = { pitch: 0, yaw: 0 };
let underworldLuminaryViewAngles = { pitch: 0, yaw: 0 };
        let realisticLighting = false;
let sunMesh, moonMesh, sunLight, moonLight, sunGlow, moonGlow, sunHalo, moonHalo;
// Underworld Luminaries
let underworldSunMesh, underworldMoonMesh, underworldSunLight, underworldMoonLight;
let underworldSunGlow, underworldMoonGlow, underworldSunHalo, underworldMoonHalo;
let underworldSunAngle = Math.PI, underworldMoonAngle = 0; // Opposite to upper luminaries
let underworldSunRadialPhase = Math.PI / 2, underworldMoonRadialPhase = -Math.PI / 2;
let underworldSunVisible = true, underworldMoonVisible = true;
// Underworld Luminary Parameters (independent from upper world)
let USUN_SPEED = 1.0, UMOON_SPEED = 0.97;
let USUN_HEIGHT = 1243, UMOON_HEIGHT = 1118;
let USUN_RADIUS_MIN = 621, USUN_RADIUS_MAX = 3107;
let UMOON_RADIUS_MIN = 621, UMOON_RADIUS_MAX = 3107;
let USUN_SIZE = 124, UMOON_SIZE = 112;
let USUN_BRIGHTNESS = 1.5, UMOON_BRIGHTNESS = 0.8;
let USUN_LIGHT_RADIUS = 8000, UMOON_LIGHT_RADIUS = 6000;
let UMOON_INTERFERENCE_DURATION = 0.12;
let underworldMoonInterferenceEnabled = true;
// Displayed brightness values (smoothly interpolate toward slider values)
let displayedSunBrightness = 1.5;
let displayedMoonBrightness = 0.8;
let displayedUSunBrightness = 1.5;
let displayedUMoonBrightness = 0.8;
// Sun flicker system (re-ignition effect)
let sunFlickerActive = false;
let sunFlickerStartTime = 0;
let sunWasOff = false;
// Lightning system (re-ignition arcs)
let lightningCanvas, lightningCtx;
let lightningGroup;
let activeLightningBolts = [];
const LIGHTNING_SPAWN_RATE = 300; // Bolts per second at peak
const LIGHTNING_BOLT_LIFETIME = 200; // ms per bolt
const LIGHTNING_BRANCH_CHANCE = 90.0;
const SHELL_LIGHTNING_SPAWN_RATE = 900;
const SUN_FLICKER_DURATION = 4500;
let randomLightningMode = false;
const SUN_OFF_THRESHOLD = 0.5; // Below this = "off"
// Moon flicker system (re-ignition effect)
let moonFlickerActive = false;
let moonFlickerStartTime = 0;
let moonWasOff = false;
const MOON_FLICKER_DURATION = 3500;
const MOON_OFF_THRESHOLD = 0.3;
// Underworld Sun flicker system (re-ignition effect)
let uSunFlickerActive = false;
let uSunFlickerStartTime = 0;
let uSunWasOff = false;
const USUN_FLICKER_DURATION = 5500;
const USUN_OFF_THRESHOLD = 0.5;
// Underworld Moon flicker system (re-ignition effect)
let uMoonFlickerActive = false;
let uMoonFlickerStartTime = 0;
let uMoonWasOff = false;
const UMOON_FLICKER_DURATION = 4500;
const UMOON_OFF_THRESHOLD = 0.3;
// ============ EDGE COLD SYSTEM - NIFLHEIM ============
// Upper Edge View
let upperEdgeSnowActive = false;
let upperEdgeFrostIntensity = 0;
let upperEdgeViewStartTime = 0;
let upperSnowflakes = [];
const UPPER_MAX_SNOWFLAKES = 200;

// Underworld Edge View
let underEdgeSnowActive = false;
let underEdgeFrostIntensity = 0;
let underEdgeViewStartTime = 0;
let underSnowflakes = [];
const UNDER_MAX_SNOWFLAKES = 200;

// Frost timing
// Frost timing
const FROST_MAX_TIME = 60000; // 60 seconds to full frost
const FROST_MAX_INTENSITY = 1.0; // Max 100% frost coverage

// Shiver timing
const SHIVER_START_TIME = 2500; // Start shivering after 2.5 seconds
const SHIVER_MAX_TIME = 30000; // Max shiver at 30 seconds
const SHIVER_MAX_INTENSITY = 25; // Max camera shake in units
let upperShiverIntensity = 0;
// ============ FIMBULWINTER SYSTEM ============
// Upper World - triggered by dying sun/moon
let upperFimbulwinterActive = false;
let upperFimbulwinterIntensity = 0;
let upperFimbulwinterStartTime = 0;

// Underworld - triggered by dying underworld sun/moon (independent system)
let lowerFimbulwinterActive = false;
let lowerFimbulwinterIntensity = 0;
let lowerFimbulwinterStartTime = 0;

// Fimbulwinter thresholds (when cold begins)
const FIMBULWINTER_SUN_BRIGHTNESS_THRESHOLD = 0.8;
const FIMBULWINTER_SUN_SIZE_THRESHOLD = 100;
const FIMBULWINTER_MOON_MULTIPLIER = 0.3;
let underShiverIntensity = 0;
// Fimbulwinter shiver (camera shake from cold)
let upperFimbulShiverIntensity = 0;
let lowerFimbulShiverIntensity = 0;
const FIMBUL_SHIVER_START_INTENSITY = 0.15;
const FIMBUL_SHIVER_MAX = 25;
// ============ LENS FLARE SYSTEM ============
let fimbulFrostCanvas, fimbulFrostCtx;
let frostShell, frostShellMaterial;
let lensFlareCanvas, lensFlareCtx;
const FLARE_THRESHOLD = 0.7; // How directly you need to look at sun (lower = wider angle)
const FLARE_MAX_INTENSITY = 0.4; // Maximum flare opacity
let lensFlareEnabled = true;
        // Luminary link variables
        let luminaryLinkVisible = false;
        let luminaryLine, luminaryDistanceSprite;
        let underworldLuminaryLinkVisible = false;
        let underworldLuminaryLine, underworldLuminaryDistanceSprite;
       
// Kayleigh's Dual-Zenith Coordinate System
        let shellGridVisible = false;
        let upperZenithMarker, lowerZenithMarker;
        let shellGridLines = [];
        let shellGridLabels = [];
        let gridDivisions = 8; // Number of latitude/longitude divisions
        let upperZenithLabel, lowerZenithLabel, equatorLabel;
        let gridHoverEnabled = false;
        let shellHoverSphere, gridTooltip;

// Strata Coordinate System - As Above, So Below
        let strataGridVisible = false;
        let upperStrataOrigin, lowerStrataOrigin;
        let strataGridLines = [];
        let strataGridLabels = [];
        let upperStrataLabel, lowerStrataLabel, strataMidplaneLabel;
        let strataHoverMesh;
       
        let shellVisible = true, axesVisible = true, shellResonating = false, horizonVisible = true, starfieldVisible = true;
        let strataWireframe = false;
        let meteorMode = false;
        let shellWireframe, diskWireframe, diskMaterial, diskFill, diskFillMaterial, axisLine, starfield, starfieldMaterial;
        let starAxisPivot, starAxisLine, starAxisHandles = [];
        let isDraggingAxis = false, axisHovered = false;
        let axisDragStart = new THREE.Vector2(), axisRotationStart = new THREE.Euler();
        let axisVelocity = { x: 0, y: 0 }, lastDragPosition = { x: 0, y: 0 }, lastDragTime = 0;
        let momentumDecay = 0.95, minVelocityThreshold = 0.0001;
        const MAIN_STAR_COUNT = 3500, TINY_STAR_COUNT = 20000;
       
        // METEOR SYSTEM
        let activeMeteorSources = [];
        let allMeteors = [];
        const TRAIL_LENGTH = 12;
        let lastFrameTime = Date.now();
        let shootingStarsMode = false;
        let lastShootingStarTime = 0;
       
        const meteorColors = [
            { r: 1.0, g: 1.0, b: 1.0 },
            { r: 0.6, g: 0.8, b: 1.0 },
            { r: 0.75, g: 0.88, b: 1.0 },
            { r: 1.0, g: 0.95, b: 0.7 },
            { r: 1.0, g: 0.8, b: 0.5 },
            { r: 1.0, g: 0.6, b: 0.3 },
        ];
       
        let meteorGeometry, meteorMaterial, meteorPoints;
        let trailGeometry, trailMaterial, trailLines;
        const MAX_METEORS = 9000;
        let meteorClickSphere;
       
        function initMeteorSystem() {
            const positions = new Float32Array(MAX_METEORS * 3);
            const colors = new Float32Array(MAX_METEORS * 3);
            const sizes = new Float32Array(MAX_METEORS);
            const alphas = new Float32Array(MAX_METEORS);
           
            meteorGeometry = new THREE.BufferGeometry();
            meteorGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            meteorGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            meteorGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            meteorGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
           
            meteorMaterial = new THREE.ShaderMaterial({
                uniforms: { uPixelRatio: { value: renderer.getPixelRatio() } },
                vertexShader: `
                    attribute float size;
                    attribute float alpha;
                    varying vec3 vColor;
                    varying float vAlpha;
                    uniform float uPixelRatio;
                    void main() {
                        vColor = color;
                        vAlpha = alpha;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * uPixelRatio * (200.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center) * 2.0;
                        float core = 1.0 - smoothstep(0.0, 0.5, dist);
                        float glow = 1.0 - smoothstep(0.0, 1.0, dist);
                        float alpha = (core + glow * 0.5) * vAlpha;
                        gl_FragColor = vec4(vColor * 1.5, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: true,
                side: THREE.DoubleSide
            });
           
            meteorPoints = new THREE.Points(meteorGeometry, meteorMaterial);
            meteorPoints.frustumCulled = false;
            meteorPoints.renderOrder = 999;
            scene.add(meteorPoints);
           
            const trailPositions = new Float32Array(MAX_METEORS * TRAIL_LENGTH * 2 * 3);
            const trailColors = new Float32Array(MAX_METEORS * TRAIL_LENGTH * 2 * 3);
           
            trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
           
            trailMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: true
            });
           
            trailLines = new THREE.LineSegments(trailGeometry, trailMaterial);
            trailLines.frustumCulled = false;
            trailLines.renderOrder = 998;
            scene.add(trailLines);
        }
       
        function spawnMeteor(origin) {
            if (allMeteors.length >= MAX_METEORS) return;
            const normalizedOrigin = origin.clone().normalize().multiplyScalar(SHELL_RADIUS);
            const randomDir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            const radial = normalizedOrigin.clone().normalize();
            const tangent = randomDir.sub(radial.clone().multiplyScalar(randomDir.dot(radial))).normalize();
            const speed = 20 + Math.random() * 35;
            const color = meteorColors[Math.floor(Math.random() * meteorColors.length)];
            const meteor = {
                position: normalizedOrigin.clone(),
                velocity: tangent.multiplyScalar(speed),
                color: color,
                size: 3 + Math.random() * 5,
                age: 0,
                maxAge: 100 + Math.random() * 150,
                trail: []
            };
            for (let i = 0; i < TRAIL_LENGTH; i++) meteor.trail.push(normalizedOrigin.clone());
            allMeteors.push(meteor);
        }
       
        // Realistic shooting star colors - what we actually observe
        const shootingStarColors = [
            { r: 1.0, g: 1.0, b: 1.0 },     // Bright white (most common)
            { r: 0.9, g: 0.95, b: 1.0 },    // Blue-white
            { r: 0.8, g: 1.0, b: 0.85 },    // Slight green tint (magnesium burn)
            { r: 1.0, g: 0.98, b: 0.9 },    // Warm white
            { r: 0.85, g: 0.9, b: 1.0 },    // Cool blue-white
        ];
       
        function spawnShootingStar(origin) {
            if (allMeteors.length >= MAX_METEORS) return;
            const normalizedOrigin = origin.clone().normalize().multiplyScalar(SHELL_RADIUS);
            const randomDir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            const radial = normalizedOrigin.clone().normalize();
            const tangent = randomDir.sub(radial.clone().multiplyScalar(randomDir.dot(radial))).normalize();
            const speed = 80 + Math.random() * 80; // FASTER - 45-85 vs 20-55
            const color = shootingStarColors[Math.floor(Math.random() * shootingStarColors.length)];
            const meteor = {
                position: normalizedOrigin.clone(),
                velocity: tangent.multiplyScalar(speed),
                color: color,
                size: 8 + Math.random() * 6, // BIGGER - 8-14 vs 3-8
                age: 0,
                maxAge: 25 + Math.random() * 50, // Shorter life but faster = longer visible trail
                trail: [],
                isShootingStar: true // Flag for longer trail rendering
            };
            for (let i = 0; i < TRAIL_LENGTH; i++) meteor.trail.push(normalizedOrigin.clone());
            allMeteors.push(meteor);
        }
       
        function updateMeteorSystem() {
            const now = Date.now();
            const frameDelta = now - lastFrameTime;
            lastFrameTime = now;
           
            if (frameDelta > 100) {
                activeMeteorSources.forEach(source => { source.lastSpawnTime = now; });
                lastShootingStarTime = now;
            }
           
            // Shooting stars mode - single random meteor every 2-5 seconds
            if (shootingStarsMode) {
                const timeSinceLastStar = now - lastShootingStarTime;
                const nextStarInterval = 40000 + Math.random() * 20000; // 40-60 seconds
                if (timeSinceLastStar >= nextStarInterval) {
                    // Random position on shell
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const randomPos = new THREE.Vector3(
                        SHELL_RADIUS * Math.sin(phi) * Math.cos(theta),
                        SHELL_RADIUS * Math.sin(phi) * Math.sin(theta),
                        SHELL_RADIUS * Math.cos(phi)
                    );
                    spawnShootingStar(randomPos);
                    lastShootingStarTime = now;
                }
            }
           
            activeMeteorSources.forEach(source => {
                const timeSinceSpawn = now - source.lastSpawnTime;
                const spawnInterval = 1000 / METEOR_RATE;
                if (timeSinceSpawn >= spawnInterval) {
                    const maxSpawnPerFrame = 8;
                    const meteorsToSpawn = Math.min(Math.floor(timeSinceSpawn / spawnInterval), maxSpawnPerFrame);
                    for (let i = 0; i < meteorsToSpawn && allMeteors.length < MAX_METEORS; i++) {
                        spawnMeteor(source.position);
                    }
                    source.lastSpawnTime = now;
                }
            });
           
            const showerCountEl = document.getElementById('shower-count');
            if (showerCountEl) showerCountEl.textContent = activeMeteorSources.length;
            const countDisplay = document.getElementById('meteor-count-display');
            if (countDisplay) countDisplay.classList.toggle('visible', activeMeteorSources.length > 0);
           
            const positions = meteorGeometry.attributes.position.array;
            const colors = meteorGeometry.attributes.color.array;
            const sizes = meteorGeometry.attributes.size.array;
            const alphas = meteorGeometry.attributes.alpha.array;
            const trailPos = trailGeometry.attributes.position.array;
            const trailCol = trailGeometry.attributes.color.array;
           
            for (let i = 0; i < MAX_METEORS * 3; i++) { positions[i] = 0; colors[i] = 0; }
            for (let i = 0; i < MAX_METEORS; i++) { sizes[i] = 0; alphas[i] = 0; }
            for (let i = 0; i < MAX_METEORS * TRAIL_LENGTH * 6; i++) { trailPos[i] = 0; trailCol[i] = 0; }
           
            for (let i = allMeteors.length - 1; i >= 0; i--) {
                const m = allMeteors[i];
                m.age++;
                if (m.age >= m.maxAge) { allMeteors.splice(i, 1); continue; }
                m.trail.unshift(m.position.clone());
                if (m.trail.length > TRAIL_LENGTH) m.trail.pop();
                m.position.add(m.velocity);
                m.position.normalize().multiplyScalar(SHELL_RADIUS);
                const radial = m.position.clone().normalize();
                m.velocity.sub(radial.clone().multiplyScalar(m.velocity.dot(radial)));
                const lifeRatio = 1 - (m.age / m.maxAge);
                const fade = m.isShootingStar ? Math.pow(lifeRatio, 0.5) : Math.pow(lifeRatio, 0.3);
                positions[i * 3] = m.position.x;
                positions[i * 3 + 1] = m.position.y;
                positions[i * 3 + 2] = m.position.z;
                colors[i * 3] = m.color.r;
                colors[i * 3 + 1] = m.color.g;
                colors[i * 3 + 2] = m.color.b;
                sizes[i] = m.size * fade;
                alphas[i] = fade;
                const trailBase = i * TRAIL_LENGTH * 6;
                const trailBrightness = m.isShootingStar ? 1.2 : 0.7; // Brighter trails for shooting stars
                for (let t = 0; t < m.trail.length - 1; t++) {
                    const p1 = m.trail[t], p2 = m.trail[t + 1];
                    const segBase = trailBase + t * 6;
                    trailPos[segBase] = p1.x; trailPos[segBase + 1] = p1.y; trailPos[segBase + 2] = p1.z;
                    trailPos[segBase + 3] = p2.x; trailPos[segBase + 4] = p2.y; trailPos[segBase + 5] = p2.z;
                    const trailFade = fade * (1 - t / TRAIL_LENGTH) * trailBrightness;
                    trailCol[segBase] = m.color.r * trailFade;
                    trailCol[segBase + 1] = m.color.g * trailFade;
                    trailCol[segBase + 2] = m.color.b * trailFade;
                    trailCol[segBase + 3] = m.color.r * trailFade * 0.5;
                    trailCol[segBase + 4] = m.color.g * trailFade * 0.5;
                    trailCol[segBase + 5] = m.color.b * trailFade * 0.5;
                }
            }
            meteorGeometry.attributes.position.needsUpdate = true;
            meteorGeometry.attributes.color.needsUpdate = true;
            meteorGeometry.attributes.size.needsUpdate = true;
            meteorGeometry.attributes.alpha.needsUpdate = true;
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.color.needsUpdate = true;
        }
       
        function toggleMeteorSource(point) {
            const normalizedPoint = point.clone().normalize().multiplyScalar(SHELL_RADIUS);
            const threshold = 500;
            for (let i = activeMeteorSources.length - 1; i >= 0; i--) {
                if (activeMeteorSources[i].position.distanceTo(normalizedPoint) < threshold) {
                    activeMeteorSources.splice(i, 1);
                    return false;
                }
            }
            activeMeteorSources.push({ position: normalizedPoint, lastSpawnTime: Date.now() });
            return true;
        }
       
        function stopAllMeteors() { activeMeteorSources = []; allMeteors = []; }
       
function createMeteorClickSphere() {
    if (meteorClickSphere) {
        meteorClickSphere.geometry.dispose();
        meteorClickSphere.material.dispose();
        scene.remove(meteorClickSphere);
    }
            const geometry = new THREE.SphereGeometry(SHELL_RADIUS, 64, 64);
            const material = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });
            meteorClickSphere = new THREE.Mesh(geometry, material);
            scene.add(meteorClickSphere);
        }
       
function createStarfield() {
    // DISPOSE old starfield to prevent memory leaks
    if (starfield) {
        starfield.geometry.dispose();
        starfield.material.dispose();
        starAxisPivot.remove(starfield);
    }
            const totalStars = MAIN_STAR_COUNT + TINY_STAR_COUNT;
            const positions = new Float32Array(totalStars * 3);
            const colors = new Float32Array(totalStars * 3);
            const sizes = new Float32Array(totalStars);
            const twinkleSeeds = new Float32Array(totalStars);
            const twinkleSpeeds = new Float32Array(totalStars);
            const glowSizes = new Float32Array(totalStars);
            let idx = 0;
           
            for (let i = 0; i < MAIN_STAR_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                positions[idx * 3] = STARFIELD_RADIUS * Math.sin(phi) * Math.cos(theta);
                positions[idx * 3 + 1] = STARFIELD_RADIUS * Math.sin(phi) * Math.sin(theta);
                positions[idx * 3 + 2] = STARFIELD_RADIUS * Math.cos(phi);
                const colorVariation = Math.random();
                if (colorVariation > 0.92) { colors[idx * 3] = 0.6; colors[idx * 3 + 1] = 0.8; colors[idx * 3 + 2] = 1.0; }
                else if (colorVariation > 0.84) { colors[idx * 3] = 0.75; colors[idx * 3 + 1] = 0.88; colors[idx * 3 + 2] = 1.0; }
                else if (colorVariation > 0.76) { colors[idx * 3] = 1.0; colors[idx * 3 + 1] = 0.95; colors[idx * 3 + 2] = 0.7; }
                else if (colorVariation > 0.68) { colors[idx * 3] = 1.0; colors[idx * 3 + 1] = 0.8; colors[idx * 3 + 2] = 0.5; }
                else { colors[idx * 3] = 1.0; colors[idx * 3 + 1] = 1.0; colors[idx * 3 + 2] = 1.0; }
                const sizeRoll = Math.random();
                if (sizeRoll > 0.95) { sizes[idx] = 8.0 + Math.random() * 5.0; glowSizes[idx] = 2.2; }
                else if (sizeRoll > 0.85) { sizes[idx] = 6.0 + Math.random() * 4.0; glowSizes[idx] = 2.0; }
                else if (sizeRoll > 0.6) { sizes[idx] = 4.0 + Math.random() * 2.0; glowSizes[idx] = 1.7; }
                else { sizes[idx] = 2.0 + Math.random() * 1.5; glowSizes[idx] = 1.4; }
                twinkleSeeds[idx] = Math.random() * 100.0;
                twinkleSpeeds[idx] = 0.3 + Math.random() * 1.4;
                idx++;
            }
            for (let i = 0; i < TINY_STAR_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                positions[idx * 3] = STARFIELD_RADIUS * Math.sin(phi) * Math.cos(theta);
                positions[idx * 3 + 1] = STARFIELD_RADIUS * Math.sin(phi) * Math.sin(theta);
                positions[idx * 3 + 2] = STARFIELD_RADIUS * Math.cos(phi);
                const dimness = 0.1 + Math.random() * 0.1;
                colors[idx * 3] = dimness; colors[idx * 3 + 1] = dimness; colors[idx * 3 + 2] = dimness;
                sizes[idx] = 0.5 + Math.random() * 0.7;
                glowSizes[idx] = 0.5;
                twinkleSeeds[idx] = Math.random() * 2.0;
                sizes[idx] = 1.8 + Math.random() * 1.0;
                idx++;
            }
           
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            starGeometry.setAttribute('twinkleSeed', new THREE.BufferAttribute(twinkleSeeds, 1));
            starGeometry.setAttribute('twinkleSpeed', new THREE.BufferAttribute(twinkleSpeeds, 1));
            starGeometry.setAttribute('glowSize', new THREE.BufferAttribute(glowSizes, 1));
           
            starfieldMaterial = new THREE.ShaderMaterial({
    uniforms: {
    uTime: { value: 0.0 },
    uBrightness: { value: STAR_BRIGHTNESS },
    uTwinkleIntensity: { value: TWINKLE_INTENSITY },
    uPixelRatio: { value: renderer.getPixelRatio() },
    uGlowSize: { value: GLOW_SIZE },
    uCoreSharpness: { value: CORE_SHARPNESS },
    uGlowIntensity: { value: GLOW_INTENSITY },
    uUpperFimbul: { value: 0.0 },
    uLowerFimbul: { value: 0.0 }
},
    vertexShader: `
    attribute float size; attribute float twinkleSeed; attribute float twinkleSpeed; attribute float glowSize;
    varying vec3 vColor; varying float vBrightness; varying float vGlowSize;
    uniform float uTime; uniform float uBrightness; uniform float uTwinkleIntensity; uniform float uPixelRatio; uniform float uGlowSize;
        uniform float uUpperFimbul; uniform float uLowerFimbul;
        void main() {
        vColor = color; vGlowSize = glowSize * uGlowSize;
        float twinkleMultiplier = 1.0;
        if (uTwinkleIntensity > 0.01) {
            float t1 = sin(uTime * 2.0 * twinkleSpeed + twinkleSeed * 6.28);
            float twinkle = t1 * uTwinkleIntensity * 0.5;
            twinkleMultiplier = 1.0 + twinkle;
        }
       
        // Hemisphere-based Fimbulwinter fade
        float fimbulFade = 1.0;
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vec3 normPos = normalize(worldPos.xyz);
        if (normPos.y > 0.0) {
            // Upper hemisphere star - affected by upper Fimbulwinter
            if (uUpperFimbul > 0.3) {
                fimbulFade = 1.0 - ((uUpperFimbul - 0.3) / 0.6);
                fimbulFade = max(0.0, fimbulFade);
            }
        } else {
            // Lower hemisphere star - affected by lower Fimbulwinter
            if (uLowerFimbul > 0.3) {
                fimbulFade = 1.0 - ((uLowerFimbul - 0.3) / 0.6);
                fimbulFade = max(0.0, fimbulFade);
            }
        }
       
        vBrightness = uBrightness * twinkleMultiplier * fimbulFade;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * glowSize * uGlowSize * uPixelRatio * (0.75 + uBrightness * 0.25) * twinkleMultiplier * fimbulFade;
        gl_Position = projectionMatrix * mvPosition;
    }
`,
                fragmentShader: `
                    varying vec3 vColor; varying float vBrightness; varying float vGlowSize;
                    uniform float uCoreSharpness; uniform float uGlowIntensity;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center) * 2.0;
                        float core = 1.0 - smoothstep(0.0, uCoreSharpness / vGlowSize, dist);
                        float glow = 1.0 - smoothstep(0.0, 0.9, dist);
                        float alpha = core + glow * uGlowIntensity;
                        vec3 finalColor = vColor * (0.85 + vBrightness * 0.15);
                        gl_FragColor = vec4(finalColor, alpha * min(vBrightness, 1.2));
                    }
                `,
                transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            starfield = new THREE.Points(starGeometry, starfieldMaterial);
            starAxisPivot.add(starfield);
        }
       
function createSunAndMoon() {
    // DISPOSE old upper world luminaries to prevent memory leaks
    if (sunMesh) {
        sunMesh.geometry.dispose();
        sunMesh.material.dispose();
        scene.remove(sunMesh);
    }
    if (moonMesh) {
        moonMesh.geometry.dispose();
        moonMesh.material.dispose();
        scene.remove(moonMesh);
    }
    if (sunGlow) {
        sunGlow.material.map.dispose();
        sunGlow.material.dispose();
        scene.remove(sunGlow);
    }
    if (moonGlow) {
        moonGlow.material.map.dispose();
        moonGlow.material.dispose();
        scene.remove(moonGlow);
    }
    if (sunHalo) {
        sunHalo.material.map.dispose();
        sunHalo.material.dispose();
        scene.remove(sunHalo);
    }
    if (moonHalo) {
        moonHalo.material.map.dispose();
        moonHalo.material.dispose();
        scene.remove(moonHalo);
    }
    if (sunLight) scene.remove(sunLight);
    if (moonLight) scene.remove(moonLight);
           
            // Create Sun
            const sunGeometry = new THREE.SphereGeometry(SUN_SIZE, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffdd44
            });
            sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sunMesh);
           
            // Sun glow sprite - inner bright glow
            const sunGlowTexture = createGlowTexture(0xffdd44);
            const sunGlowMaterial = new THREE.SpriteMaterial({
                map: sunGlowTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            sunGlow = new THREE.Sprite(sunGlowMaterial);
            sunGlow.scale.set(SUN_SIZE * 10, SUN_SIZE * 10, 1);
            scene.add(sunGlow);
           
            // Sun outer halo - softer, larger
            const sunHaloTexture = createGlowTexture(0xffaa22);
            const sunHaloMaterial = new THREE.SpriteMaterial({
                map: sunHaloTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                opacity: 0.3
            });
            sunHalo = new THREE.Sprite(sunHaloMaterial);
            sunHalo.scale.set(SUN_SIZE * 18, SUN_SIZE * 18, 1);
            scene.add(sunHalo);
           
            // Sun light
            sunLight = new THREE.PointLight(0xffaa44, SUN_BRIGHTNESS, SHELL_RADIUS * 3);
            sunLight.castShadow = false;
            scene.add(sunLight);
           
            // Create Moon - bright pearl white with ethereal glow
            const moonGeometry = new THREE.SphereGeometry(MOON_SIZE, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({
                color: 0xeeeeff  // Bright pearl white with hint of blue
            });
            moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(moonMesh);
           
            // Moon inner glow sprite - strong blue-violet bloom
            const moonGlowTexture = createGlowTexture(0x5577ee);  // Saturated blue
            const moonGlowMaterial = new THREE.SpriteMaterial({
                map: moonGlowTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                opacity: 0.8
            });
            moonGlow = new THREE.Sprite(moonGlowMaterial);
            moonGlow.scale.set(MOON_SIZE * 10, MOON_SIZE * 10, 1);
            scene.add(moonGlow);
           
            // Moon outer halo - deep blue corona
            const moonHaloTexture = createGlowTexture(0x4466dd);
            const moonHaloMaterial = new THREE.SpriteMaterial({
                map: moonHaloTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                opacity: 0.5
            });
            moonHalo = new THREE.Sprite(moonHaloMaterial);
            moonHalo.scale.set(MOON_SIZE * 16, MOON_SIZE * 16, 1);
            scene.add(moonHalo);
           
            // Moon light - strong blue moonlight to overpower white
            moonLight = new THREE.PointLight(0x0033ff, MOON_BRIGHTNESS * 4, SHELL_RADIUS * 3);
            scene.add(moonLight);
                        // ============ UNDERWORLD LUMINARIES ============

// DISPOSE old underworld luminaries to prevent memory leaks
if (underworldSunMesh) {
    underworldSunMesh.geometry.dispose();
    underworldSunMesh.material.dispose();
    scene.remove(underworldSunMesh);
}
if (underworldMoonMesh) {
    underworldMoonMesh.geometry.dispose();
    underworldMoonMesh.material.dispose();
    scene.remove(underworldMoonMesh);
}
if (underworldSunGlow) {
    underworldSunGlow.material.map.dispose();
    underworldSunGlow.material.dispose();
    scene.remove(underworldSunGlow);
}
if (underworldMoonGlow) {
    underworldMoonGlow.material.map.dispose();
    underworldMoonGlow.material.dispose();
    scene.remove(underworldMoonGlow);
}
if (underworldSunHalo) {
    underworldSunHalo.material.map.dispose();
    underworldSunHalo.material.dispose();
    scene.remove(underworldSunHalo);
}
if (underworldMoonHalo) {
    underworldMoonHalo.material.map.dispose();
    underworldMoonHalo.material.dispose();
    scene.remove(underworldMoonHalo);
}
if (underworldSunLight) scene.remove(underworldSunLight);
if (underworldMoonLight) scene.remove(underworldMoonLight);
           
            // Create Underworld Sun - BLOOD RED
            const uSunGeometry = new THREE.SphereGeometry(USUN_SIZE, 32, 32);
            const uSunMaterial = new THREE.MeshBasicMaterial({ color: 0xff2222 });
            underworldSunMesh = new THREE.Mesh(uSunGeometry, uSunMaterial);
            scene.add(underworldSunMesh);
           
            // Underworld Sun glow - deep red
            const uSunGlowTexture = createGlowTexture(0xff4422);
            const uSunGlowMaterial = new THREE.SpriteMaterial({
                map: uSunGlowTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            underworldSunGlow = new THREE.Sprite(uSunGlowMaterial);
            underworldSunGlow.scale.set(USUN_SIZE * 10, USUN_SIZE * 10, 1);
            scene.add(underworldSunGlow);
           
            // Underworld Sun halo - darker red corona
            const uSunHaloTexture = createGlowTexture(0xaa2200);
            const uSunHaloMaterial = new THREE.SpriteMaterial({
                map: uSunHaloTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                opacity: 0.3
            });
            underworldSunHalo = new THREE.Sprite(uSunHaloMaterial);
            underworldSunHalo.scale.set(USUN_SIZE * 18, USUN_SIZE * 18, 1);
            scene.add(underworldSunHalo);
           
            // Underworld Sun light - red light
            underworldSunLight = new THREE.PointLight(0xff4422, SUN_BRIGHTNESS, SHELL_RADIUS * 3);
            underworldSunLight.castShadow = false;
            scene.add(underworldSunLight);
           
            // Create Underworld Moon - WEIRD DARK BLUE
            const uMoonGeometry = new THREE.SphereGeometry(UMOON_SIZE, 32, 32);
            const uMoonMaterial = new THREE.MeshBasicMaterial({ color: 0x2233aa });
            underworldMoonMesh = new THREE.Mesh(uMoonGeometry, uMoonMaterial);
            scene.add(underworldMoonMesh);
           
            // Underworld Moon glow - deep indigo
            const uMoonGlowTexture = createGlowTexture(0x3344bb);
            const uMoonGlowMaterial = new THREE.SpriteMaterial({
                map: uMoonGlowTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                opacity: 0.8
            });
            underworldMoonGlow = new THREE.Sprite(uMoonGlowMaterial);
            underworldMoonGlow.scale.set(MOON_SIZE * 10, MOON_SIZE * 10, 1);
            scene.add(underworldMoonGlow);
           
            // Underworld Moon halo - dark violet corona
            const uMoonHaloTexture = createGlowTexture(0x222266);
            const uMoonHaloMaterial = new THREE.SpriteMaterial({
                map: uMoonHaloTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                opacity: 0.5
            });
           underworldMoonHalo = new THREE.Sprite(uMoonHaloMaterial);
           underworldMoonHalo.scale.set(UMOON_SIZE * 16, UMOON_SIZE * 16, 1);
           underworldMoonHalo.renderOrder = 100;
           underworldMoonGlow.renderOrder = 100;
           scene.add(underworldMoonHalo);
           
            // Underworld Moon light - dark blue light
            underworldMoonLight = new THREE.PointLight(0x0033ff, MOON_BRIGHTNESS * 4, SHELL_RADIUS * 3);
            scene.add(underworldMoonLight);
        }
       
        function createGlowTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
           
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            const r = (color >> 16) & 255;
            const g = (color >> 8) & 255;
            const b = color & 255;
           
            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 1)`);
            gradient.addColorStop(0.1, `rgba(${r}, ${g}, ${b}, 0.8)`);
            gradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.3)`);
            gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.1)`);
            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
           
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
           
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
       
        function createFrostShellMaterial() {
    frostShellMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0.0 },
            uUpperFrostIntensity: { value: 0.0 },
            uLowerFrostIntensity: { value: 0.0 },
            uShellRadius: { value: SHELL_RADIUS }
        },
        vertexShader: `
            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;
           
            void main() {
                vPosition = position;
                vNormal = normalize(normalMatrix * normal);
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPos.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float uTime;
            uniform float uUpperFrostIntensity;
            uniform float uLowerFrostIntensity;
            uniform float uShellRadius;
           
            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;
           
            vec3 hash3(vec3 p) {
                p = vec3(
                    dot(p, vec3(127.1, 311.7, 74.7)),
                    dot(p, vec3(269.5, 183.3, 246.1)),
                    dot(p, vec3(113.5, 271.9, 124.6))
                );
                return fract(sin(p) * 43758.5453123);
            }
           
            vec2 voronoi(vec3 x) {
                vec3 p = floor(x);
                vec3 f = fract(x);
                float id = 0.0;
                float res = 100.0;
                for(int k = -1; k <= 1; k++)
                for(int j = -1; j <= 1; j++)
                for(int i = -1; i <= 1; i++) {
                    vec3 b = vec3(float(i), float(j), float(k));
                    vec3 r = vec3(b) - f + hash3(p + b);
                    float d = dot(r, r);
                    if(d < res) {
                        res = d;
                        id = dot(p + b, vec3(1.0, 57.0, 113.0));
                    }
                }
                return vec2(sqrt(res), id);
            }
           
            void main() {
                vec3 normPos = normalize(vPosition);
               
                float upperBlend = smoothstep(-0.02, 0.02, normPos.y);
                float lowerBlend = smoothstep(0.02, -0.02, normPos.y);
               
                float upperPoleDistance = 1.0 - normPos.y;
                float upperFrostEdge = uUpperFrostIntensity * 2.0;
                float upperFrost = 1.0 - smoothstep(upperFrostEdge - 0.3, upperFrostEdge, upperPoleDistance);
                upperFrost *= upperBlend;
               
                float lowerPoleDistance = 1.0 + normPos.y;
                float lowerFrostEdge = uLowerFrostIntensity * 2.0;
                float lowerFrost = 1.0 - smoothstep(lowerFrostEdge - 0.3, lowerFrostEdge, lowerPoleDistance);
                lowerFrost *= lowerBlend;
               
                float frostIntensity = max(upperFrost, lowerFrost);
                if (frostIntensity < 0.01) discard;
               
                vec3 voronoiCoord = normPos * 1.0;
                vec2 v = voronoi(voronoiCoord);
                float cracks = 1.0 - smoothstep(0.0, 0.15, v.x);
               
                vec2 v2 = voronoi(normPos * 10.0);
                float smallCracks = 1.0 - smoothstep(0.0, 0.1, v2.x);
                smallCracks *= 0.5;
               
                float crackPattern = cracks + smallCracks * frostIntensity;
               
                vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                float fresnel = 1.0 - abs(dot(viewDir, vNormal));
                fresnel = pow(fresnel, 2.0);
               
                vec3 paleCyan = vec3(0.02, 0.03, 0.06);
                vec3 iceWhite = vec3(0.01, 0.02, 0.04);
                vec3 deepFrost = vec3(0.0, 0.01, 0.03);
               
                vec3 frostColor;
                if (frostIntensity < 0.3) {
                    frostColor = mix(paleCyan, iceWhite, frostIntensity / 0.3);
                } else if (frostIntensity < 0.6) {
                    frostColor = mix(iceWhite, deepFrost, (frostIntensity - 0.3) / 0.3);
                } else {
                    frostColor = deepFrost;
                }
               
            float shimmer = sin(uTime * 0.5 + v.y * 10.0) * 0.5 + 0.5;
            shimmer = pow(shimmer, 2.0) * frostIntensity;
               
            vec3 finalColor = frostColor * (0.1 + crackPattern * 0.05);
            finalColor += vec3(0.02, 0.03, 0.06) * fresnel * 0.1;
            finalColor += vec3(0.002, 0.004, 0.008) * shimmer;
               
            float alpha = 0.75 + frostIntensity * 0.2;
                alpha = clamp(alpha, 0.0, 0.95);
               
                gl_FragColor = vec4(finalColor, alpha);
            }
        `,
        transparent: true,
        blending: THREE.NormalBlending,
        side: THREE.DoubleSide,
        depthWrite: false
    });
}

    let displayedUpperFrost = 0;
    let displayedLowerFrost = 0;

function updateFrostShell(elapsedTime) {
    if (!frostShell || !frostShellMaterial) return;
   
    // Calculate TARGET frost from sun state
    const targetUpperFrost = calculateUpperFimbulwinterIntensity();
    const targetLowerFrost = calculateLowerFimbulwinterIntensity();
   
    // Smooth interpolation - frost creeps slowly toward target
    const freezeSpeed = 0.0004;  // How fast frost spreads
    const thawSpeed = 0.0030;   // How fast frost retreats (slower)
   
    // Upper frost smoothing
    if (targetUpperFrost > displayedUpperFrost) {
        displayedUpperFrost += (targetUpperFrost - displayedUpperFrost) * freezeSpeed;
    } else {
        displayedUpperFrost += (targetUpperFrost - displayedUpperFrost) * thawSpeed;
    }
   
    // Lower frost smoothing
    if (targetLowerFrost > displayedLowerFrost) {
        displayedLowerFrost += (targetLowerFrost - displayedLowerFrost) * freezeSpeed;
    } else {
        displayedLowerFrost += (targetLowerFrost - displayedLowerFrost) * thawSpeed;
    }
   
    frostShellMaterial.uniforms.uTime.value = elapsedTime;
    frostShellMaterial.uniforms.uUpperFrostIntensity.value = displayedUpperFrost;
    frostShellMaterial.uniforms.uLowerFrostIntensity.value = displayedLowerFrost;
   
    frostShell.visible = (displayedUpperFrost > 0.02 || displayedLowerFrost > 0.02);
}
       
        // Kayleigh's Dual-Zenith Shell Coordinate System
function createShellGrid() {
    // DISPOSE old grid to prevent memory leaks
    if (upperZenithMarker) {
        upperZenithMarker.geometry.dispose();
        upperZenithMarker.material.dispose();
        scene.remove(upperZenithMarker);
    }
    if (lowerZenithMarker) {
        lowerZenithMarker.geometry.dispose();
        lowerZenithMarker.material.dispose();
        scene.remove(lowerZenithMarker);
    }
    shellGridLines.forEach(line => {
        line.geometry.dispose();
        line.material.dispose();
        scene.remove(line);
    });
    shellGridLines = [];
   
    // Create Upper Zenith marker (top of shell) - GOLD
    const zenithGeometry = new THREE.SphereGeometry(80, 16, 16);
    const upperZenithMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
    upperZenithMarker = new THREE.Mesh(zenithGeometry, upperZenithMaterial);
    upperZenithMarker.position.set(0, SHELL_RADIUS, 0);
    upperZenithMarker.visible = shellGridVisible;
    scene.add(upperZenithMarker);
   
    // Create Lower Zenith marker (bottom of shell) - CYAN
    const lowerZenithMaterial = new THREE.MeshBasicMaterial({ color: 0xff6666 });
    lowerZenithMarker = new THREE.Mesh(zenithGeometry, lowerZenithMaterial);
    lowerZenithMarker.position.set(0, -SHELL_RADIUS, 0);
    lowerZenithMarker.visible = shellGridVisible;
    scene.add(lowerZenithMarker);
   
    // Create latitude lines (horizontal circles at different Z depths from each zenith)
    const latitudeMaterialUpper = new THREE.LineBasicMaterial({ color: 0xffdd44, transparent: true, opacity: 0.5 });
    const latitudeMaterialLower = new THREE.LineBasicMaterial({ color: 0xff6666, transparent: true, opacity: 0.5 });
   
    for (let i = 1; i < gridDivisions; i++) {
        const angle = (i / gridDivisions) * (Math.PI / 2); // 0 to 90 degrees from zenith
        const y = SHELL_RADIUS * Math.cos(angle);
        const radius = SHELL_RADIUS * Math.sin(angle);
       
        // Upper hemisphere latitude circle
        const upperLatPoints = [];
        for (let j = 0; j <= 64; j++) {
            const theta = (j / 64) * Math.PI * 2;
            upperLatPoints.push(new THREE.Vector3(
                radius * Math.cos(theta),
                y,
                radius * Math.sin(theta)
            ));
        }
        const upperLatGeometry = new THREE.BufferGeometry().setFromPoints(upperLatPoints);
        const upperLatLine = new THREE.Line(upperLatGeometry, latitudeMaterialUpper);
        upperLatLine.visible = shellGridVisible;
        scene.add(upperLatLine);
        shellGridLines.push(upperLatLine);
       
        // Lower hemisphere latitude circle (mirror)
        const lowerLatPoints = [];
        for (let j = 0; j <= 64; j++) {
            const theta = (j / 64) * Math.PI * 2;
            lowerLatPoints.push(new THREE.Vector3(
                radius * Math.cos(theta),
                -y,
                radius * Math.sin(theta)
            ));
        }
        const lowerLatGeometry = new THREE.BufferGeometry().setFromPoints(lowerLatPoints);
        const lowerLatLine = new THREE.Line(lowerLatGeometry, latitudeMaterialLower);
        lowerLatLine.visible = shellGridVisible;
        scene.add(lowerLatLine);
        shellGridLines.push(lowerLatLine);
    }
   
    // Create longitude lines (great circles through both zeniths)
    const longitudeMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.4 });
   
    for (let i = 0; i < gridDivisions; i++) {
        const theta = (i / gridDivisions) * Math.PI; // Half circle (other half is same line)
        const lonPoints = [];
       
        // Draw full great circle from top zenith to bottom zenith and back
        for (let j = 0; j <= 64; j++) {
            const phi = (j / 64) * Math.PI * 2;
            lonPoints.push(new THREE.Vector3(
                SHELL_RADIUS * Math.sin(phi) * Math.cos(theta),
                SHELL_RADIUS * Math.cos(phi),
                SHELL_RADIUS * Math.sin(phi) * Math.sin(theta)
            ));
        }
        const lonGeometry = new THREE.BufferGeometry().setFromPoints(lonPoints);
        const lonLine = new THREE.Line(lonGeometry, longitudeMaterial);
        lonLine.visible = shellGridVisible;
        scene.add(lonLine);
        shellGridLines.push(lonLine);
    }
   
    // Create equator line (where upper and lower systems meet) - WHITE/BRIGHT
    const equatorMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    const equatorPoints = [];
    for (let i = 0; i <= 64; i++) {
        const theta = (i / 64) * Math.PI * 2;
        equatorPoints.push(new THREE.Vector3(
            SHELL_RADIUS * Math.cos(theta),
            0,
            SHELL_RADIUS * Math.sin(theta)
        ));
    }
    const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
    const equatorLine = new THREE.Line(equatorGeometry, equatorMaterial);
    equatorLine.visible = shellGridVisible;
    scene.add(equatorLine);
    shellGridLines.push(equatorLine);
}

    function updateShellGridVisibility() {
    if (upperZenithMarker) upperZenithMarker.visible = shellGridVisible;
    if (lowerZenithMarker) lowerZenithMarker.visible = shellGridVisible;
    shellGridLines.forEach(line => line.visible = shellGridVisible);
    updateGridLabelsVisibility();
}

    function createGridLabel(text, color, fontSize = 72) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 128;
   
    context.font = `Bold ${fontSize}px Arial`;
    context.textAlign = 'center';
    context.textBaseline = 'middle';
   
    // Background
    context.fillStyle = 'rgba(0, 0, 0, 0.6)';
    context.beginPath();
    context.roundRect(10, 10, canvas.width - 20, canvas.height - 20, 20);
    context.fill();
   
    // Text
    context.fillStyle = color;
    context.fillText(text, canvas.width / 2, canvas.height / 2);
   
    const texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;
   
    const spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        depthWrite: false
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(800, 200, 1);
    return sprite;
}

function createShellGridLabels() {
    // DISPOSE old labels to prevent memory leaks
    if (upperZenithLabel) {
        upperZenithLabel.material.map.dispose();
        upperZenithLabel.material.dispose();
        scene.remove(upperZenithLabel);
    }
    if (lowerZenithLabel) {
        lowerZenithLabel.material.map.dispose();
        lowerZenithLabel.material.dispose();
        scene.remove(lowerZenithLabel);
    }
    if (equatorLabel) {
        equatorLabel.material.map.dispose();
        equatorLabel.material.dispose();
        scene.remove(equatorLabel);
    }
    shellGridLabels.forEach(label => {
        label.material.map.dispose();
        label.material.dispose();
        scene.remove(label);
    });
    shellGridLabels = [];
   
    // Upper Zenith Label
    upperZenithLabel = createGridLabel('Z↑ ORIGIN', '#ffdd44');
    upperZenithLabel.position.set(300, SHELL_RADIUS + 150, 0);
    upperZenithLabel.visible = shellGridVisible;
    scene.add(upperZenithLabel);
   
    // Lower Zenith Label
    lowerZenithLabel = createGridLabel('Z↓ ORIGIN', '#ff8844');
    lowerZenithLabel.position.set(300, -SHELL_RADIUS - 150, 0);
    lowerZenithLabel.visible = shellGridVisible;
    scene.add(lowerZenithLabel);
   
    // Z depth labels for upper hemisphere latitude rings
    for (let i = 1; i < gridDivisions; i++) {
        const angle = (i / gridDivisions) * (Math.PI / 2);
        const y = SHELL_RADIUS * Math.cos(angle);
        const zDepth = SHELL_RADIUS - y;
       
        // Upper hemisphere Z↑ label
        const upperLabel = createGridLabel(`Z↑ ${Math.round(zDepth)} mi`, '#ffdd44', 48);
        upperLabel.position.set(SHELL_RADIUS * Math.sin(angle) + 300, y, 0);
        upperLabel.scale.set(SHELL_RADIUS * 0.15, SHELL_RADIUS * 0.0375, 1);
        upperLabel.visible = shellGridVisible;
        scene.add(upperLabel);
        shellGridLabels.push(upperLabel);
       
        // Lower hemisphere Z↓ label
        const lowerLabel = createGridLabel(`Z↓ ${Math.round(zDepth)} mi`, '#ff8844', 48);
        lowerLabel.position.set(SHELL_RADIUS * Math.sin(angle) + 300, -y, 0);
        lowerLabel.scale.set(SHELL_RADIUS * 0.15, SHELL_RADIUS * 0.0375, 1);
        lowerLabel.visible = shellGridVisible;
        scene.add(lowerLabel);
        shellGridLabels.push(lowerLabel);
    }
       // X-axis labels around full equator (all positive distances from center)
        for (let i = 1; i < gridDivisions; i++) {
        const angle = (i / gridDivisions) * (Math.PI / 2);
        const xPos = SHELL_RADIUS * Math.sin(angle);
        const zPos = SHELL_RADIUS * Math.cos(angle);
       
        // Front side: both sides of center
        const xLabelFront1 = createGridLabel(`X ${Math.round(xPos)} mi`, '#44ddff', 48);
        xLabelFront1.position.set(xPos, 150, zPos);
        xLabelFront1.scale.set(SHELL_RADIUS * 0.15, SHELL_RADIUS * 0.0375, 1);
        xLabelFront1.visible = shellGridVisible;
        scene.add(xLabelFront1);
        shellGridLabels.push(xLabelFront1);
       
        const xLabelFront2 = createGridLabel(`X ${Math.round(xPos)} mi`, '#44ddff', 48);
        xLabelFront2.position.set(-xPos, 150, zPos);
        xLabelFront2.scale.set(SHELL_RADIUS * 0.15, SHELL_RADIUS * 0.0375, 1);
        xLabelFront2.visible = shellGridVisible;
        scene.add(xLabelFront2);
        shellGridLabels.push(xLabelFront2);
       
        // Back side: both sides of center
        const xLabelBack1 = createGridLabel(`X ${Math.round(xPos)} mi`, '#44ddff', 48);
        xLabelBack1.position.set(xPos, 150, -zPos);
        xLabelBack1.scale.set(SHELL_RADIUS * 0.15, SHELL_RADIUS * 0.0375, 1);
        xLabelBack1.visible = shellGridVisible;
        scene.add(xLabelBack1);
        shellGridLabels.push(xLabelBack1);
       
        const xLabelBack2 = createGridLabel(`X ${Math.round(xPos)} mi`, '#44ddff', 48);
        xLabelBack2.position.set(-xPos, 150, -zPos);
        xLabelBack2.scale.set(SHELL_RADIUS * 0.15, SHELL_RADIUS * 0.0375, 1);
        xLabelBack2.visible = shellGridVisible;
        scene.add(xLabelBack2);
        shellGridLabels.push(xLabelBack2);
    }
   
}

    function updateGridLabelsVisibility() {
    if (upperZenithLabel) upperZenithLabel.visible = shellGridVisible;
    if (lowerZenithLabel) lowerZenithLabel.visible = shellGridVisible;
    shellGridLabels.forEach(label => label.visible = shellGridVisible);
}

function createStrataGrid() {
    // DISPOSE old strata grid to prevent memory leaks
    if (upperStrataOrigin) {
        upperStrataOrigin.geometry.dispose();
        upperStrataOrigin.material.dispose();
        scene.remove(upperStrataOrigin);
    }
    if (lowerStrataOrigin) {
        lowerStrataOrigin.geometry.dispose();
        lowerStrataOrigin.material.dispose();
        scene.remove(lowerStrataOrigin);
    }
    strataGridLines.forEach(line => {
        line.geometry.dispose();
        line.material.dispose();
        scene.remove(line);
    });
    strataGridLines = [];
   
    const halfThickness = DISK_THICKNESS / 2;
   
    // Create Upper Surface Origin marker (top center) - GOLD
    const originGeometry = new THREE.SphereGeometry(60, 16, 16);
    const upperOriginMaterial = new THREE.MeshBasicMaterial({ color: 0x44ffaa });
    upperStrataOrigin = new THREE.Mesh(originGeometry, upperOriginMaterial);
    upperStrataOrigin.position.set(0, halfThickness, 0);
    upperStrataOrigin.visible = strataGridVisible;
    scene.add(upperStrataOrigin);
   
    // Create Lower Surface Origin marker (bottom center) - CYAN
    const lowerOriginMaterial = new THREE.MeshBasicMaterial({ color: 0xff44aa });
    lowerStrataOrigin = new THREE.Mesh(originGeometry, lowerOriginMaterial);
    lowerStrataOrigin.position.set(0, -halfThickness, 0);
    lowerStrataOrigin.visible = strataGridVisible;
    scene.add(lowerStrataOrigin);
   
    // Concentric circles on upper surface (distance from center)
    const upperCircleMaterial = new THREE.LineBasicMaterial({ color: 0x44ffaa, transparent: true, opacity: 0.5 });
    const lowerCircleMaterial = new THREE.LineBasicMaterial({ color: 0xff44aa, transparent: true, opacity: 0.5 });
   
    for (let i = 1; i <= gridDivisions; i++) {
        const radius = (i / gridDivisions) * DISK_RADIUS;
       
        // Upper surface circle
        const upperPoints = [];
        for (let j = 0; j <= 64; j++) {
            const theta = (j / 64) * Math.PI * 2;
            upperPoints.push(new THREE.Vector3(
                radius * Math.cos(theta),
                halfThickness + 1,
                radius * Math.sin(theta)
            ));
        }
        const upperGeometry = new THREE.BufferGeometry().setFromPoints(upperPoints);
        const upperLine = new THREE.Line(upperGeometry, upperCircleMaterial);
        upperLine.visible = strataGridVisible;
        scene.add(upperLine);
        strataGridLines.push(upperLine);
       
        // Lower surface circle
        const lowerPoints = [];
        for (let j = 0; j <= 64; j++) {
            const theta = (j / 64) * Math.PI * 2;
            lowerPoints.push(new THREE.Vector3(
                radius * Math.cos(theta),
                -halfThickness - 1,
                radius * Math.sin(theta)
            ));
        }
        const lowerGeometry = new THREE.BufferGeometry().setFromPoints(lowerPoints);
        const lowerLine = new THREE.Line(lowerGeometry, lowerCircleMaterial);
        lowerLine.visible = strataGridVisible;
        scene.add(lowerLine);
        strataGridLines.push(lowerLine);
    }
   
    // Radial lines for quadrants (4 lines dividing into Q1-Q4)
    const radialMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.4 });
    const upperEdgeMaterial = new THREE.LineBasicMaterial({ color: 0x44ffaa, transparent: true, opacity: 0.5 });
    const lowerEdgeMaterial = new THREE.LineBasicMaterial({ color: 0xff44aa, transparent: true, opacity: 0.5 });
   
    for (let i = 0; i < 4; i++) {
        const theta = (i / 4) * Math.PI * 2;
        const x = DISK_RADIUS * Math.cos(theta);
        const z = DISK_RADIUS * Math.sin(theta);
       
        // Upper surface radial
        const upperRadialGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, halfThickness + 1, 0),
            new THREE.Vector3(x, halfThickness + 1, z)
        ]);
        const upperRadial = new THREE.Line(upperRadialGeometry, radialMaterial);
        upperRadial.visible = strataGridVisible;
        scene.add(upperRadial);
        strataGridLines.push(upperRadial);
       
        // Lower surface radial
        const lowerRadialGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -halfThickness - 1, 0),
            new THREE.Vector3(x, -halfThickness - 1, z)
        ]);
        const lowerRadial = new THREE.Line(lowerRadialGeometry, radialMaterial);
        lowerRadial.visible = strataGridVisible;
        scene.add(lowerRadial);
        strataGridLines.push(lowerRadial);
       
        // Upper edge line (top surface down to midplane)
        const upperEdgeGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, halfThickness, z),
            new THREE.Vector3(x, 0, z)
        ]);
        const upperEdge = new THREE.Line(upperEdgeGeometry, upperEdgeMaterial);
        upperEdge.visible = strataGridVisible;
        scene.add(upperEdge);
        strataGridLines.push(upperEdge);
       
        // Lower edge line (bottom surface up to midplane)
        const lowerEdgeGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, -halfThickness, z),
            new THREE.Vector3(x, 0, z)
        ]);
        const lowerEdge = new THREE.Line(lowerEdgeGeometry, lowerEdgeMaterial);
        lowerEdge.visible = strataGridVisible;
        scene.add(lowerEdge);
        strataGridLines.push(lowerEdge);
    }
   
    // Additional edge lines around the cylinder (more detail)
    const edgeLineDivisions = 16; // More lines around the edge
    for (let i = 0; i < edgeLineDivisions; i++) {
        const theta = (i / edgeLineDivisions) * Math.PI * 2;
        const x = DISK_RADIUS * Math.cos(theta);
        const z = DISK_RADIUS * Math.sin(theta);
       
        // Upper surface radial (origin to edge)
        const upperRadialGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, halfThickness + 1, 0),
            new THREE.Vector3(x, halfThickness + 1, z)
        ]);
        const upperRadial = new THREE.Line(upperRadialGeometry, upperEdgeMaterial);
        upperRadial.visible = strataGridVisible;
        scene.add(upperRadial);
        strataGridLines.push(upperRadial);
       
        // Lower surface radial (origin to edge)
        const lowerRadialGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -halfThickness - 1, 0),
            new THREE.Vector3(x, -halfThickness - 1, z)
        ]);
        const lowerRadial = new THREE.Line(lowerRadialGeometry, lowerEdgeMaterial);
        lowerRadial.visible = strataGridVisible;
        scene.add(lowerRadial);
        strataGridLines.push(lowerRadial);
       
        // Upper edge line (top surface down to midplane)
        const upperEdgeGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, halfThickness, z),
            new THREE.Vector3(x, 0, z)
        ]);
        const upperEdge = new THREE.Line(upperEdgeGeometry, upperEdgeMaterial);
        upperEdge.visible = strataGridVisible;
        scene.add(upperEdge);
        strataGridLines.push(upperEdge);
       
        // Lower edge line (bottom surface up to midplane)
        const lowerEdgeGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, -halfThickness, z),
            new THREE.Vector3(x, 0, z)
        ]);
        const lowerEdge = new THREE.Line(lowerEdgeGeometry, lowerEdgeMaterial);
        lowerEdge.visible = strataGridVisible;
        scene.add(lowerEdge);
        strataGridLines.push(lowerEdge);
    }
}

function createStrataGridLabels() {
    // DISPOSE old strata labels to prevent memory leaks
    if (upperStrataLabel) {
        upperStrataLabel.material.map.dispose();
        upperStrataLabel.material.dispose();
        scene.remove(upperStrataLabel);
    }
    if (lowerStrataLabel) {
        lowerStrataLabel.material.map.dispose();
        lowerStrataLabel.material.dispose();
        scene.remove(lowerStrataLabel);
    }
    if (strataMidplaneLabel) {
        strataMidplaneLabel.material.map.dispose();
        strataMidplaneLabel.material.dispose();
        scene.remove(strataMidplaneLabel);
    }
    strataGridLabels.forEach(label => {
        label.material.map.dispose();
        label.material.dispose();
        scene.remove(label);
    });
    strataGridLabels = [];
   
    const halfThickness = DISK_THICKNESS / 2;
   
    // Upper Surface Origin Label
    upperStrataLabel = createGridLabel('Z↑ ORIGIN', '#44ffaa');
    upperStrataLabel.position.set(200, halfThickness + 150, 0);
    upperStrataLabel.visible = strataGridVisible;
    scene.add(upperStrataLabel);
   
    // Lower Surface Origin Label
    lowerStrataLabel = createGridLabel('Z↓ ORIGIN', '#ff44aa');
    lowerStrataLabel.position.set(200, -halfThickness - 150, 0);
    lowerStrataLabel.visible = strataGridVisible;
    scene.add(lowerStrataLabel);
   
    // Midplane Label
    strataMidplaneLabel = createGridLabel('MIDPLANE', '#ffffff');
    strataMidplaneLabel.position.set(DISK_RADIUS + 400, 0, 0);
    strataMidplaneLabel.visible = strataGridVisible;
    scene.add(strataMidplaneLabel);
   
    // Distance labels for concentric circles (on upper surface)
    for (let i = 1; i <= gridDivisions; i++) {
        const radius = (i / gridDivisions) * DISK_RADIUS;
       
        // Upper surface distance label
        const upperDistLabel = createGridLabel(`${Math.round(radius)} mi`, '#44ffaa', 48);
        upperDistLabel.position.set(radius + 150, halfThickness + 80, 0);
        upperDistLabel.scale.set(DISK_RADIUS * 0.12, DISK_RADIUS * 0.03, 1);
        upperDistLabel.visible = strataGridVisible;
        scene.add(upperDistLabel);
        strataGridLabels.push(upperDistLabel);
       
        // Lower surface distance label
        const lowerDistLabel = createGridLabel(`${Math.round(radius)} mi`, '#ff44aa', 48);
        lowerDistLabel.position.set(radius + 150, -halfThickness - 80, 0);
        lowerDistLabel.scale.set(DISK_RADIUS * 0.12, DISK_RADIUS * 0.03, 1);
        lowerDistLabel.visible = strataGridVisible;
        scene.add(lowerDistLabel);
        strataGridLabels.push(lowerDistLabel);
    }
   
    // Z depth labels on the edge (showing depth into strata)
    const zDivisions = 4;
    for (let i = 1; i < zDivisions; i++) {
        const yPos = halfThickness - (i / zDivisions) * halfThickness;
        const zDepth = (i / zDivisions) * halfThickness;
       
        // Upper half Z↑ depth label
        const upperZLabel = createGridLabel(`Z↑ ${Math.round(zDepth)} mi`, '#44ffaa', 48);
        upperZLabel.position.set(DISK_RADIUS + 300, yPos, 0);
        upperZLabel.scale.set(DISK_RADIUS * 0.15, DISK_RADIUS * 0.0375, 1);
        upperZLabel.visible = strataGridVisible;
        scene.add(upperZLabel);
        strataGridLabels.push(upperZLabel);
       
        // Lower half Z↓ depth label
        const lowerZLabel = createGridLabel(`Z↓ ${Math.round(zDepth)} mi`, '#ff44aa', 48);
        lowerZLabel.position.set(DISK_RADIUS + 300, -yPos, 0);
        lowerZLabel.scale.set(DISK_RADIUS * 0.15, DISK_RADIUS * 0.0375, 1);
        lowerZLabel.visible = strataGridVisible;
        scene.add(lowerZLabel);
        strataGridLabels.push(lowerZLabel);
    }
}

    function updateStrataGridVisibility() {
    if (upperStrataOrigin) upperStrataOrigin.visible = strataGridVisible;
    if (lowerStrataOrigin) lowerStrataOrigin.visible = strataGridVisible;
    if (upperStrataLabel) upperStrataLabel.visible = strataGridVisible;
    if (lowerStrataLabel) lowerStrataLabel.visible = strataGridVisible;
    if (strataMidplaneLabel) strataMidplaneLabel.visible = strataGridVisible;
    strataGridLines.forEach(line => line.visible = strataGridVisible);
    strataGridLabels.forEach(label => label.visible = strataGridVisible);
}

function createGridHoverSphere() {
    if (shellHoverSphere) {
        shellHoverSphere.geometry.dispose();
        shellHoverSphere.material.dispose();
        scene.remove(shellHoverSphere);
    }
    const geometry = new THREE.SphereGeometry(SHELL_RADIUS, 64, 64);
    const material = new THREE.MeshBasicMaterial({
        visible: false,
        side: THREE.DoubleSide
    });
    shellHoverSphere = new THREE.Mesh(geometry, material);
    scene.add(shellHoverSphere);
}

function createStrataHoverMesh() {
    if (strataHoverMesh) {
        strataHoverMesh.geometry.dispose();
        strataHoverMesh.material.dispose();
        scene.remove(strataHoverMesh);
    }
    const geometry = new THREE.CylinderGeometry(DISK_RADIUS, DISK_RADIUS, DISK_THICKNESS, 64, 1);
    const material = new THREE.MeshBasicMaterial({
        visible: false,
        side: THREE.DoubleSide
    });
    strataHoverMesh = new THREE.Mesh(geometry, material);
    scene.add(strataHoverMesh);
}

    function getShellCoordinates(point) {
    const isUpperHemisphere = point.y >= 0;
   
    let zDepth;
    if (isUpperHemisphere) {
        zDepth = SHELL_RADIUS - point.y;
    } else {
        zDepth = SHELL_RADIUS + point.y;
    }
   
    // Arc distance to equator (curved path along shell surface)
    const angleFromEquator = Math.asin(Math.abs(point.y) / SHELL_RADIUS);
    const arcToEquator = angleFromEquator * SHELL_RADIUS;
   
    // Absolute values for X and Y (always positive)
    const x = Math.abs(point.x);
    const y = Math.abs(point.z);
   
    // Determine quadrant based on signs
    let quadrant;
    if (point.x >= 0 && point.z >= 0) quadrant = 'Q1';
    else if (point.x < 0 && point.z >= 0) quadrant = 'Q2';
    else if (point.x < 0 && point.z < 0) quadrant = 'Q3';
    else quadrant = 'Q4';
   
    return {
        hemisphere: isUpperHemisphere ? 'UPPER' : 'LOWER',
        x: Math.round(x),
        y: Math.round(y),
        z: Math.round(zDepth),
        quadrant: quadrant,
        arcToEquator: Math.round(arcToEquator),
        color: isUpperHemisphere ? '#ffdd44' : '#ff8844',
        zSymbol: isUpperHemisphere ? 'Z↑' : 'Z↓'
    };
}

    function getStrataCoordinates(point) {
    const halfThickness = DISK_THICKNESS / 2;
    const isUpperSurface = point.y >= 0;
   
    // Z depth from surface (always positive)
    let zDepth;
    if (isUpperSurface) {
        zDepth = halfThickness - point.y;
    } else {
        zDepth = halfThickness + point.y;
    }
   
    // Horizontal distance from center
    const distFromCenter = Math.sqrt(point.x * point.x + point.z * point.z);
   
    // Absolute values for X and Y (always positive)
    const x = Math.abs(point.x);
    const y = Math.abs(point.z);
   
    // Determine quadrant based on signs
    let quadrant;
    if (point.x >= 0 && point.z >= 0) quadrant = 'Q1';
    else if (point.x < 0 && point.z >= 0) quadrant = 'Q2';
    else if (point.x < 0 && point.z < 0) quadrant = 'Q3';
    else quadrant = 'Q4';
   
    return {
        surface: isUpperSurface ? 'UPPER' : 'LOWER',
        x: Math.round(x),
        y: Math.round(y),
        z: Math.round(Math.max(0, zDepth)),
        quadrant: quadrant,
        distFromCenter: Math.round(distFromCenter),
        color: isUpperSurface ? '#44ffaa' : '#ff44aa',
        zSymbol: isUpperSurface ? 'Z↑' : 'Z↓'
    };
}

    function updateGridTooltip(event) {
    if (!shellGridVisible || !shellHoverSphere) {
        document.getElementById('grid-tooltip').style.display = 'none';
        return;
    }
   
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
   
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(shellHoverSphere);
   
    if (intersects.length > 0) {
        const point = intersects[0].point;
        const coords = getShellCoordinates(point);
       
        const tooltip = document.getElementById('grid-tooltip');
        tooltip.style.display = 'block';
tooltip.style.left = (event.clientX + 15) + 'px';
tooltip.style.top = (event.clientY - 100) + 'px';
        tooltip.style.borderColor = coords.color;
       
        document.getElementById('tooltip-hemisphere').textContent = coords.hemisphere + ' HEMISPHERE';
        document.getElementById('tooltip-hemisphere').style.color = coords.color;
        document.getElementById('tooltip-x').textContent = coords.x.toLocaleString();
        document.getElementById('tooltip-y').textContent = coords.y.toLocaleString();
        document.getElementById('tooltip-z').textContent = coords.z.toLocaleString();
        document.getElementById('tooltip-z').style.color = coords.color;
        document.getElementById('tooltip-z-label').innerHTML = coords.zSymbol + ': <span style="color: ' + coords.color + ';" id="tooltip-z">' + coords.z.toLocaleString() + '</span> mi';
        document.getElementById('tooltip-quadrant').textContent = coords.quadrant;
        document.getElementById('tooltip-arc').textContent = coords.arcToEquator.toLocaleString();
    } else {
        document.getElementById('grid-tooltip').style.display = 'none';
    }
}

    function updateStrataTooltip(event) {
    if (!strataGridVisible || !strataHoverMesh) {
        document.getElementById('strata-tooltip').style.display = 'none';
        return;
    }
   
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
   
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(strataHoverMesh);
   
    if (intersects.length > 0) {
        const point = intersects[0].point;
        const coords = getStrataCoordinates(point);
       
        const tooltip = document.getElementById('strata-tooltip');
        tooltip.style.display = 'block';
tooltip.style.left = (event.clientX + 15) + 'px';
tooltip.style.top = (event.clientY + 80) + 'px';
        tooltip.style.borderColor = coords.color;
       
        document.getElementById('strata-tooltip-surface').textContent = coords.surface + ' SURFACE';
        document.getElementById('strata-tooltip-surface').style.color = coords.color;
        document.getElementById('strata-tooltip-x').textContent = coords.x.toLocaleString();
        document.getElementById('strata-tooltip-y').textContent = coords.y.toLocaleString();
        document.getElementById('strata-tooltip-z').textContent = coords.z.toLocaleString();
        document.getElementById('strata-tooltip-z').style.color = coords.color;
        document.getElementById('strata-tooltip-z-label').innerHTML = coords.zSymbol + ': <span style="color: ' + coords.color + ';" id="strata-tooltip-z">' + coords.z.toLocaleString() + '</span> mi';
        document.getElementById('strata-tooltip-quadrant').textContent = coords.quadrant;
        document.getElementById('strata-tooltip-dist').textContent = coords.distFromCenter.toLocaleString();
    } else {
        document.getElementById('strata-tooltip').style.display = 'none';
    }
}
        // Luminary Link System
function createLuminaryLink() {
    // DISPOSE old luminary link to prevent memory leaks
    if (luminaryLine) {
        luminaryLine.geometry.dispose();
        luminaryLine.material.dispose();
        scene.remove(luminaryLine);
    }
    if (luminaryDistanceSprite) {
        luminaryDistanceSprite.material.map.dispose();
        luminaryDistanceSprite.material.dispose();
        scene.remove(luminaryDistanceSprite);
    }
    const lineGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(6);
    const colors = new Float32Array(6);
    lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    lineGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending, depthWrite: false });
    luminaryLine = new THREE.Line(lineGeometry, lineMaterial);
    luminaryLine.visible = false;
    scene.add(luminaryLine);
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 64;
    const texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
    luminaryDistanceSprite = new THREE.Sprite(spriteMaterial);
    luminaryDistanceSprite.scale.set(1600, 200, 1);
    luminaryDistanceSprite.visible = false;
    luminaryDistanceSprite.userData = { canvas, texture };
    scene.add(luminaryDistanceSprite);
}
function createUnderworldLuminaryLink() {
    // DISPOSE old underworld luminary link to prevent memory leaks
    if (underworldLuminaryLine) {
        underworldLuminaryLine.geometry.dispose();
        underworldLuminaryLine.material.dispose();
        scene.remove(underworldLuminaryLine);
    }
    if (underworldLuminaryDistanceSprite) {
        underworldLuminaryDistanceSprite.material.map.dispose();
        underworldLuminaryDistanceSprite.material.dispose();
        scene.remove(underworldLuminaryDistanceSprite);
    }
    const lineGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(6);
    const colors = new Float32Array(6);
    lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    lineGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending, depthWrite: false });
    underworldLuminaryLine = new THREE.Line(lineGeometry, lineMaterial);
    underworldLuminaryLine.visible = false;
    scene.add(underworldLuminaryLine);
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 64;
    const texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
    underworldLuminaryDistanceSprite = new THREE.Sprite(spriteMaterial);
    underworldLuminaryDistanceSprite.scale.set(1600, 200, 1);
    underworldLuminaryDistanceSprite.visible = false;
    underworldLuminaryDistanceSprite.userData = { canvas, texture };
    scene.add(underworldLuminaryDistanceSprite);
}

    function updateLuminaryLink() {
    if (!luminaryLine || !luminaryDistanceSprite || !sunMesh || !moonMesh) return;
   
    // Always calculate and display distance in info panel
    const distance = Math.round(sunMesh.position.distanceTo(moonMesh.position));
    document.getElementById('luminary-distance-info').textContent = distance.toLocaleString() + ' mi';
   
    const showLink = luminaryLinkVisible && sunVisible && moonVisible;
    luminaryLine.visible = showLink;
    luminaryDistanceSprite.visible = showLink;
    if (!showLink) return;
   
    // Update line positions
    const positions = luminaryLine.geometry.attributes.position.array;
    const colors = luminaryLine.geometry.attributes.color.array;
    positions[0] = sunMesh.position.x; positions[1] = sunMesh.position.y; positions[2] = sunMesh.position.z;
    positions[3] = moonMesh.position.x; positions[4] = moonMesh.position.y; positions[5] = moonMesh.position.z;
    colors[0] = 1.0; colors[1] = 0.87; colors[2] = 0.27;
    colors[3] = 0.67; colors[4] = 0.73; colors[5] = 1.0;
    luminaryLine.geometry.attributes.position.needsUpdate = true;
    luminaryLine.geometry.attributes.color.needsUpdate = true;
   
    // Update floating label
    const { canvas, texture } = luminaryDistanceSprite.userData;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath(); ctx.roundRect(20, 12, 216, 40, 20); ctx.fill();
    const gradient = ctx.createLinearGradient(50, 0, 206, 0);
    gradient.addColorStop(0, '#ffdd44'); gradient.addColorStop(0.5, '#ffffff'); gradient.addColorStop(1, '#aabbff');
    ctx.font = 'Bold 22px Segoe UI'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = gradient; ctx.fillText(distance.toLocaleString() + ' mi', canvas.width/2, canvas.height/2);
    texture.needsUpdate = true;
    const midpoint = new THREE.Vector3().addVectors(sunMesh.position, moonMesh.position).multiplyScalar(0.5);
    midpoint.y += 200;
    luminaryDistanceSprite.position.copy(midpoint);

    // Scale sprite based on camera distance for visibility in all views
    const camDist = camera.position.distanceTo(midpoint);
    const scaleFactor = Math.min(300, Math.max(80, camDist * 0.06));
    luminaryDistanceSprite.scale.set(scaleFactor * 4, scaleFactor, 1);
}

    // ============ EDGE COLD SYSTEM FUNCTIONS ============
    function initEdgeColdSystem() {
    // Upper snow canvas
    const upperSnowCanvas = document.getElementById('upper-snow-canvas');
    upperSnowCanvas.width = window.innerWidth;
    upperSnowCanvas.height = window.innerHeight;
   
    // Upper frost canvas
    const upperFrostCanvas = document.getElementById('upper-frost-canvas');
    upperFrostCanvas.width = window.innerWidth;
    upperFrostCanvas.height = window.innerHeight;
   
    // Underworld snow canvas
    const underSnowCanvas = document.getElementById('under-snow-canvas');
    underSnowCanvas.width = window.innerWidth;
    underSnowCanvas.height = window.innerHeight;
   
    // Underworld frost canvas
    const underFrostCanvas = document.getElementById('under-frost-canvas');
    underFrostCanvas.width = window.innerWidth;
    underFrostCanvas.height = window.innerHeight;
}

    function spawnSnowflake(isUnderworld) {
    return {
        x: Math.random() * window.innerWidth,
        y: -10,
        size: 2 + Math.random() * 4,
        speed: 1 + Math.random() * 2,
        drift: (Math.random() - 0.5) * 2,
        opacity: 0.5 + Math.random() * 0.5,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 0.02 + Math.random() * 0.03
    };
}

    // ============ FIMBULWINTER CALCULATION FUNCTIONS ============
    // These calculate intensity based on sun/moon state - NO CAMERA CODE

function calculateUpperFimbulwinterIntensity() {
    if (!sunVisible) return 0;
    const sunBrightnessWeakness = Math.max(0, (FIMBULWINTER_SUN_BRIGHTNESS_THRESHOLD - SUN_BRIGHTNESS) / FIMBULWINTER_SUN_BRIGHTNESS_THRESHOLD);
    return sunBrightnessWeakness;
}

function calculateLowerFimbulwinterIntensity() {
    if (!underworldSunVisible) return 0;
    const uSunBrightnessWeakness = Math.max(0, (FIMBULWINTER_SUN_BRIGHTNESS_THRESHOLD - USUN_BRIGHTNESS) / FIMBULWINTER_SUN_BRIGHTNESS_THRESHOLD);
    return uSunBrightnessWeakness;
}

    function updateUpperFimbulwinter() {
    // Only build intensity when in upper ground-level views
const inUpperGroundView = isGroundView && !isUnderworldView && !isUnderworldEdgeView && !isUnderworldMidView && !isUSunView && !isUMoonView;   
    if (!inUpperGroundView) {
    upperFimbulwinterIntensity = 0;
    upperFimbulwinterActive = false;
    upperFimbulShiverIntensity = 0;
    return;
}
   
    const targetIntensity = calculateUpperFimbulwinterIntensity();
   
    if (targetIntensity > 0.05) {
        // Sun is weak - should be freezing
        if (!upperFimbulwinterActive) {
            upperFimbulwinterActive = true;
            upperFimbulwinterStartTime = Date.now();
        }
       
        // Time factor limits how fast frost can BUILD (60 sec to full)
        const elapsed = Date.now() - upperFimbulwinterStartTime;
        const timeFactor = Math.min(1, elapsed / 60000);
        const maxAllowedByTime = targetIntensity * timeFactor;
       
        // Intensity creeps toward maxAllowedByTime
        if (upperFimbulwinterIntensity < maxAllowedByTime) {
            // Freezing
            upperFimbulwinterIntensity += 0.001;
            if (upperFimbulwinterIntensity > maxAllowedByTime) {
                upperFimbulwinterIntensity = maxAllowedByTime;
            }
        } else if (upperFimbulwinterIntensity > maxAllowedByTime) {
            // Sun got brighter but still weak - slow thaw toward new ceiling
            upperFimbulwinterIntensity -= 0.0002;
        }
    } else {
        // Sun is strong - full thaw
        if (upperFimbulwinterIntensity > 0) {
            upperFimbulwinterIntensity -= 0.0002;
            if (upperFimbulwinterIntensity <= 0) {
                upperFimbulwinterIntensity = 0;
                upperFimbulwinterActive = false;
            }
        }
    }
   
    // Calculate shiver based on frost intensity
    if (upperFimbulwinterIntensity > FIMBUL_SHIVER_START_INTENSITY) {
        // Shiver scales from 0 at 20% frost to max at 100% frost
        const shiverProgress = (upperFimbulwinterIntensity - FIMBUL_SHIVER_START_INTENSITY) / (1 - FIMBUL_SHIVER_START_INTENSITY);
        upperFimbulShiverIntensity = shiverProgress * FIMBUL_SHIVER_MAX;
    } else {
        upperFimbulShiverIntensity = 0;
    }
}

    function updateLowerFimbulwinter() {
    // Only build intensity when in underworld ground-level views
    const inLowerGroundView = isGroundView && (isUnderworldView || isUnderworldEdgeView || isUnderworldMidView || isUSunView || isUMoonView);
   
    if (!inLowerGroundView) {
    // Disable camera-specific shiver, but let star fade intensity persist
    lowerFimbulShiverIntensity = 0;
    // Don't reset intensity - let it persist for orbit view star fade
    return;
}
   
    // INDEPENDENT SYSTEM - duplicated logic, no sharing
    const targetIntensity = calculateLowerFimbulwinterIntensity();
   
    if (targetIntensity > 0.05) {
        // Underworld sun is weak - should be freezing
        if (!lowerFimbulwinterActive) {
            lowerFimbulwinterActive = true;
            lowerFimbulwinterStartTime = Date.now();
        }
       
        const elapsed = Date.now() - lowerFimbulwinterStartTime;
        const timeFactor = Math.min(1, elapsed / 60000);
        const maxAllowedByTime = targetIntensity * timeFactor;
       
        if (lowerFimbulwinterIntensity < maxAllowedByTime) {
            // Freezing
            lowerFimbulwinterIntensity += 0.001;
            if (lowerFimbulwinterIntensity > maxAllowedByTime) {
                lowerFimbulwinterIntensity = maxAllowedByTime;
            }
        } else if (lowerFimbulwinterIntensity > maxAllowedByTime) {
            // Underworld sun got brighter but still weak - slow thaw
            lowerFimbulwinterIntensity -= 0.0002;
        }
    } else {
        // Underworld sun is strong - full thaw
        if (lowerFimbulwinterIntensity > 0) {
            lowerFimbulwinterIntensity -= 0.0002;
            if (lowerFimbulwinterIntensity <= 0) {
                lowerFimbulwinterIntensity = 0;
                lowerFimbulwinterActive = false;
            }
        }
    }
   
    // Calculate shiver based on frost intensity
    if (lowerFimbulwinterIntensity > FIMBUL_SHIVER_START_INTENSITY) {
        // Shiver scales from 0 at 20% frost to max at 100% frost
        const shiverProgress = (lowerFimbulwinterIntensity - FIMBUL_SHIVER_START_INTENSITY) / (1 - FIMBUL_SHIVER_START_INTENSITY);
        lowerFimbulShiverIntensity = shiverProgress * FIMBUL_SHIVER_MAX;
    } else {
        lowerFimbulShiverIntensity = 0;
    }
}

    function updateFimbulwinterFrost() {
    if (!fimbulFrostCtx || !fimbulFrostCanvas) return;
   
    // No frost in orbit view
    if (!isGroundView) {
        fimbulFrostCtx.clearRect(0, 0, fimbulFrostCanvas.width, fimbulFrostCanvas.height);
        return;
    }
   
    // Determine which intensity to use based on current view
    // Underworld views use lower intensity, all others use upper
    const inUnderworldView = isUnderworldView || isUnderworldEdgeView || isUnderworldMidView || isUSunView || isUMoonView;
    const intensity = inUnderworldView ? lowerFimbulwinterIntensity : upperFimbulwinterIntensity;
   
    // Clear if no effect
    if (intensity <= 0) {
        fimbulFrostCtx.clearRect(0, 0, fimbulFrostCanvas.width, fimbulFrostCanvas.height);
        return;
    }
   
    fimbulFrostCtx.clearRect(0, 0, fimbulFrostCanvas.width, fimbulFrostCanvas.height);
   
    const w = fimbulFrostCanvas.width;
    const h = fimbulFrostCanvas.height;
   
    // Fimbulwinter frost is MORE aggressive than edge frost
    // It covers the entire screen, not just edges
    const cornerRadius = Math.min(w, h) * 1.5 * intensity;
   
    // Color tint - dark frost (no light = dark ice)
    const frostColor = inUnderworldView ? 'rgba(20, 25, 45,' : 'rgba(30, 35, 50,';
    const iceColor = inUnderworldView ? 'rgba(15, 20, 40,' : 'rgba(25, 30, 45,';
   
    // Corner frost gradients - larger and more intense than edge frost
    let gradient;
   
    // Top-left
    gradient = fimbulFrostCtx.createRadialGradient(0, 0, 0, 0, 0, cornerRadius);
    gradient.addColorStop(0, frostColor + (intensity * 0.9) + ')');
    gradient.addColorStop(0.4, frostColor + (intensity * 0.5) + ')');
    gradient.addColorStop(0.7, frostColor + (intensity * 0.2) + ')');
    gradient.addColorStop(1, frostColor + '0)');
    fimbulFrostCtx.fillStyle = gradient;
    fimbulFrostCtx.fillRect(0, 0, cornerRadius, cornerRadius);
   
    // Top-right
    gradient = fimbulFrostCtx.createRadialGradient(w, 0, 0, w, 0, cornerRadius);
    gradient.addColorStop(0, frostColor + (intensity * 0.9) + ')');
    gradient.addColorStop(0.4, frostColor + (intensity * 0.5) + ')');
    gradient.addColorStop(0.7, frostColor + (intensity * 0.2) + ')');
    gradient.addColorStop(1, frostColor + '0)');
    fimbulFrostCtx.fillStyle = gradient;
    fimbulFrostCtx.fillRect(w - cornerRadius, 0, cornerRadius, cornerRadius);
   
    // Bottom-left
    gradient = fimbulFrostCtx.createRadialGradient(0, h, 0, 0, h, cornerRadius);
    gradient.addColorStop(0, frostColor + (intensity * 0.9) + ')');
    gradient.addColorStop(0.4, frostColor + (intensity * 0.5) + ')');
    gradient.addColorStop(0.7, frostColor + (intensity * 0.2) + ')');
    gradient.addColorStop(1, frostColor + '0)');
    fimbulFrostCtx.fillStyle = gradient;
    fimbulFrostCtx.fillRect(0, h - cornerRadius, cornerRadius, cornerRadius);
   
    // Bottom-right
    gradient = fimbulFrostCtx.createRadialGradient(w, h, 0, w, h, cornerRadius);
    gradient.addColorStop(0, frostColor + (intensity * 0.9) + ')');
    gradient.addColorStop(0.4, frostColor + (intensity * 0.5) + ')');
    gradient.addColorStop(0.7, frostColor + (intensity * 0.2) + ')');
    gradient.addColorStop(1, frostColor + '0)');
    fimbulFrostCtx.fillStyle = gradient;
    fimbulFrostCtx.fillRect(w - cornerRadius, h - cornerRadius, cornerRadius, cornerRadius);
   
    // Edge frost strips - thicker than edge view frost
    const edgeWidth = 300 * intensity;
   
    // Top edge
    gradient = fimbulFrostCtx.createLinearGradient(0, 0, 0, edgeWidth);
    gradient.addColorStop(0, iceColor + (intensity * 0.7) + ')');
    gradient.addColorStop(1, iceColor + '0)');
    fimbulFrostCtx.fillStyle = gradient;
    fimbulFrostCtx.fillRect(0, 0, w, edgeWidth);
   
    // Bottom edge
    gradient = fimbulFrostCtx.createLinearGradient(0, h, 0, h - edgeWidth);
    gradient.addColorStop(0, iceColor + (intensity * 0.7) + ')');
    gradient.addColorStop(1, iceColor + '0)');
    fimbulFrostCtx.fillStyle = gradient;
    fimbulFrostCtx.fillRect(0, h - edgeWidth, w, edgeWidth);
   
    // Left edge
    gradient = fimbulFrostCtx.createLinearGradient(0, 0, edgeWidth, 0);
    gradient.addColorStop(0, iceColor + (intensity * 0.7) + ')');
    gradient.addColorStop(1, iceColor + '0)');
    fimbulFrostCtx.fillStyle = gradient;
    fimbulFrostCtx.fillRect(0, 0, edgeWidth, h);
   
    // Right edge
    gradient = fimbulFrostCtx.createLinearGradient(w, 0, w - edgeWidth, 0);
    gradient.addColorStop(0, iceColor + (intensity * 0.7) + ')');
    gradient.addColorStop(1, iceColor + '0)');
    fimbulFrostCtx.fillStyle = gradient;
    fimbulFrostCtx.fillRect(w - edgeWidth, 0, edgeWidth, h);
   
    // At high intensity, add center vignette (world is truly dying)
    if (intensity > 0.5) {
        const vignetteIntensity = (intensity - 0.5) * 2; // 0 to 1 for intensity 0.5 to 1
        gradient = fimbulFrostCtx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h) * 0.7);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0)');
        gradient.addColorStop(1, frostColor + (vignetteIntensity * 0.4) + ')');
        fimbulFrostCtx.fillStyle = gradient;
        fimbulFrostCtx.fillRect(0, 0, w, h);
    }
   
    // Ice crystal patterns at higher intensity
    if (intensity > 0.3) {
        const crystalCount = Math.floor(intensity * 50);
        fimbulFrostCtx.strokeStyle = iceColor + (intensity * 0.5) + ')';
        fimbulFrostCtx.lineWidth = 1;
       
        for (let i = 0; i < crystalCount; i++) {
            // Crystals appear anywhere on screen during Fimbulwinter
            const cx = Math.random() * w;
            const cy = Math.random() * h;
           
            // Bias toward edges
            const edgeBias = Math.random();
            let finalX = cx, finalY = cy;
            if (edgeBias < 0.6) {
                // Push toward nearest edge
                const distToLeft = cx;
                const distToRight = w - cx;
                const distToTop = cy;
                const distToBottom = h - cy;
                const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
               
                if (minDist === distToLeft) finalX = Math.random() * edgeWidth * 2;
                else if (minDist === distToRight) finalX = w - Math.random() * edgeWidth * 2;
                else if (minDist === distToTop) finalY = Math.random() * edgeWidth * 2;
                else finalY = h - Math.random() * edgeWidth * 2;
            }
           
            const size = 5 + Math.random() * 20 * intensity;
           
            // 6-point star crystal
            fimbulFrostCtx.beginPath();
            for (let j = 0; j < 6; j++) {
                const angle = (j / 6) * Math.PI * 2;
                fimbulFrostCtx.moveTo(finalX, finalY);
                fimbulFrostCtx.lineTo(finalX + Math.cos(angle) * size, finalY + Math.sin(angle) * size);
            }
            fimbulFrostCtx.stroke();
        }
    }
}

    function updateUpperEdgeCold() {
    const snowCanvas = document.getElementById('upper-snow-canvas');
    const frostCanvas = document.getElementById('upper-frost-canvas');
    const snowCtx = snowCanvas.getContext('2d');
    const frostCtx = frostCanvas.getContext('2d');
   
    if (!upperEdgeSnowActive) {
        // Clear and hide when not active
        snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
        // Fade frost out
        if (upperEdgeFrostIntensity > 0) {
            upperEdgeFrostIntensity -= 0.005;
            if (upperEdgeFrostIntensity < 0) upperEdgeFrostIntensity = 0;
            drawFrost(frostCtx, frostCanvas, upperEdgeFrostIntensity, false);
        } else {
            frostCtx.clearRect(0, 0, frostCanvas.width, frostCanvas.height);
        }
        return;
    }
   
    // === SNOW UPDATE ===
    snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
   
    // Snowflakes disabled - frost only
    /*
    if (upperSnowflakes.length < UPPER_MAX_SNOWFLAKES && Math.random() < 0.3) {
        upperSnowflakes.push(spawnSnowflake(false));
    }
    */
   
    // Update and draw snowflakes
    for (let i = upperSnowflakes.length - 1; i >= 0; i--) {
        const flake = upperSnowflakes[i];
        flake.y += flake.speed;
        flake.wobble += flake.wobbleSpeed;
        flake.x += flake.drift + Math.sin(flake.wobble) * 0.5;
       
        // Remove if off screen
        if (flake.y > snowCanvas.height + 10 || flake.x < -10 || flake.x > snowCanvas.width + 10) {
            upperSnowflakes.splice(i, 1);
            continue;
        }
       
        // Draw snowflake
        snowCtx.beginPath();
        snowCtx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
        snowCtx.fillStyle = `rgba(255, 255, 255, ${flake.opacity})`;
        snowCtx.fill();
       
        // Add subtle glow
        snowCtx.beginPath();
        snowCtx.arc(flake.x, flake.y, flake.size * 2, 0, Math.PI * 2);
        snowCtx.fillStyle = `rgba(200, 220, 255, ${flake.opacity * 0.2})`;
        snowCtx.fill();
    }
   
    // === FROST UPDATE ===
    const elapsed = Date.now() - upperEdgeViewStartTime;
    upperEdgeFrostIntensity = Math.min(FROST_MAX_INTENSITY, elapsed / FROST_MAX_TIME);
    drawFrost(frostCtx, frostCanvas, upperEdgeFrostIntensity, false);
   
    // === SHIVER UPDATE ===
    if (elapsed > SHIVER_START_TIME) {
        const shiverElapsed = elapsed - SHIVER_START_TIME;
        upperShiverIntensity = Math.min(SHIVER_MAX_INTENSITY, (shiverElapsed / (SHIVER_MAX_TIME - SHIVER_START_TIME)) * SHIVER_MAX_INTENSITY);
    } else {
        upperShiverIntensity = 0;
    }
}

    function updateUnderEdgeCold() {
    const snowCanvas = document.getElementById('under-snow-canvas');
    const frostCanvas = document.getElementById('under-frost-canvas');
    const snowCtx = snowCanvas.getContext('2d');
    const frostCtx = frostCanvas.getContext('2d');
   
    if (!underEdgeSnowActive) {
        // Clear and hide when not active
        snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
        // Fade frost out
        if (underEdgeFrostIntensity > 0) {
            underEdgeFrostIntensity -= 0.005;
            if (underEdgeFrostIntensity < 0) underEdgeFrostIntensity = 0;
            drawFrost(frostCtx, frostCanvas, underEdgeFrostIntensity, true);
        } else {
            frostCtx.clearRect(0, 0, frostCanvas.width, frostCanvas.height);
        }
        return;
    }
   
    // === SNOW UPDATE ===
    snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
   
    // Snowflakes disabled - frost only
    /*
    if (underSnowflakes.length < UNDER_MAX_SNOWFLAKES && Math.random() < 0.3) {
        underSnowflakes.push(spawnSnowflake(true));
    }
    */
   
    // Update and draw snowflakes
    for (let i = underSnowflakes.length - 1; i >= 0; i--) {
        const flake = underSnowflakes[i];
        flake.y += flake.speed;
        flake.wobble += flake.wobbleSpeed;
        flake.x += flake.drift + Math.sin(flake.wobble) * 0.5;
       
        // Remove if off screen
        if (flake.y > snowCanvas.height + 10 || flake.x < -10 || flake.x > snowCanvas.width + 10) {
            underSnowflakes.splice(i, 1);
            continue;
        }
       
        // Draw snowflake - slightly blue tint for underworld
        snowCtx.beginPath();
        snowCtx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
        snowCtx.fillStyle = `rgba(200, 220, 255, ${flake.opacity})`;
        snowCtx.fill();
       
        // Add subtle glow - more blue for underworld
        snowCtx.beginPath();
        snowCtx.arc(flake.x, flake.y, flake.size * 2, 0, Math.PI * 2);
        snowCtx.fillStyle = `rgba(150, 180, 255, ${flake.opacity * 0.25})`;
        snowCtx.fill();
    }
   
    // === FROST UPDATE ===
    const elapsed = Date.now() - underEdgeViewStartTime;
    underEdgeFrostIntensity = Math.min(FROST_MAX_INTENSITY, elapsed / FROST_MAX_TIME);
    drawFrost(frostCtx, frostCanvas, underEdgeFrostIntensity, true);
   
    // === SHIVER UPDATE ===
    if (elapsed > SHIVER_START_TIME) {
        const shiverElapsed = elapsed - SHIVER_START_TIME;
        underShiverIntensity = Math.min(SHIVER_MAX_INTENSITY, (shiverElapsed / (SHIVER_MAX_TIME - SHIVER_START_TIME)) * SHIVER_MAX_INTENSITY);
    } else {
        underShiverIntensity = 0;
    }
}

    function drawFrost(ctx, canvas, intensity, isUnderworld) {
    if (intensity <= 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
    }
   
    ctx.clearRect(0, 0, canvas.width, canvas.height);
   
    const w = canvas.width;
    const h = canvas.height;
    const cornerRadius = Math.min(w, h) * 1.2 * intensity;
   
    // Color tint - upper is white-blue, underworld is deeper blue
    const frostColor = isUnderworld ? 'rgba(100, 140, 200,' : 'rgba(180, 210, 240,';
    const iceColor = isUnderworld ? 'rgba(60, 100, 180,' : 'rgba(150, 190, 230,';
   
    // Draw corner frost gradients
    // Top-left
    let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, cornerRadius);
    gradient.addColorStop(0, frostColor + (intensity * 0.8) + ')');
    gradient.addColorStop(0.5, frostColor + (intensity * 0.4) + ')');
    gradient.addColorStop(1, frostColor + '0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, cornerRadius, cornerRadius);
   
    // Top-right
    gradient = ctx.createRadialGradient(w, 0, 0, w, 0, cornerRadius);
    gradient.addColorStop(0, frostColor + (intensity * 0.8) + ')');
    gradient.addColorStop(0.5, frostColor + (intensity * 0.4) + ')');
    gradient.addColorStop(1, frostColor + '0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(w - cornerRadius, 0, cornerRadius, cornerRadius);
   
    // Bottom-left
    gradient = ctx.createRadialGradient(0, h, 0, 0, h, cornerRadius);
    gradient.addColorStop(0, frostColor + (intensity * 0.8) + ')');
    gradient.addColorStop(0.5, frostColor + (intensity * 0.4) + ')');
    gradient.addColorStop(1, frostColor + '0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, h - cornerRadius, cornerRadius, cornerRadius);
   
    // Bottom-right
    gradient = ctx.createRadialGradient(w, h, 0, w, h, cornerRadius);
    gradient.addColorStop(0, frostColor + (intensity * 0.8) + ')');
    gradient.addColorStop(0.5, frostColor + (intensity * 0.4) + ')');
    gradient.addColorStop(1, frostColor + '0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(w - cornerRadius, h - cornerRadius, cornerRadius, cornerRadius);
   
    // Edge frost strips
    const edgeWidth = 250 * intensity;
   
    // Top edge
    gradient = ctx.createLinearGradient(0, 0, 0, edgeWidth);
    gradient.addColorStop(0, iceColor + (intensity * 0.6) + ')');
    gradient.addColorStop(1, iceColor + '0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, edgeWidth);
   
    // Bottom edge
    gradient = ctx.createLinearGradient(0, h, 0, h - edgeWidth);
    gradient.addColorStop(0, iceColor + (intensity * 0.6) + ')');
    gradient.addColorStop(1, iceColor + '0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, h - edgeWidth, w, edgeWidth);
   
    // Left edge
    gradient = ctx.createLinearGradient(0, 0, edgeWidth, 0);
    gradient.addColorStop(0, iceColor + (intensity * 0.6) + ')');
    gradient.addColorStop(1, iceColor + '0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, edgeWidth, h);
   
    // Right edge
    gradient = ctx.createLinearGradient(w, 0, w - edgeWidth, 0);
    gradient.addColorStop(0, iceColor + (intensity * 0.6) + ')');
    gradient.addColorStop(1, iceColor + '0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(w - edgeWidth, 0, edgeWidth, h);
   
    // Ice crystal patterns (simple) - more at higher intensity
    if (intensity > 0.3) {
        const crystalCount = Math.floor(intensity * 30);
        ctx.strokeStyle = iceColor + (intensity * 0.4) + ')';
        ctx.lineWidth = 1;
       
        for (let i = 0; i < crystalCount; i++) {
            // Place crystals near edges
            let cx, cy;
            const edge = Math.floor(Math.random() * 4);
            switch(edge) {
                case 0: cx = Math.random() * w; cy = Math.random() * edgeWidth * 1.5; break;
                case 1: cx = Math.random() * w; cy = h - Math.random() * edgeWidth * 1.5; break;
                case 2: cx = Math.random() * edgeWidth * 1.5; cy = Math.random() * h; break;
                case 3: cx = w - Math.random() * edgeWidth * 1.5; cy = Math.random() * h; break;
            }
           
            const size = 5 + Math.random() * 15 * intensity;
           
            // Simple 6-point star crystal
            ctx.beginPath();
            for (let j = 0; j < 6; j++) {
                const angle = (j / 6) * Math.PI * 2;
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(angle) * size, cy + Math.sin(angle) * size);
            }
            ctx.stroke();
        }
    }
}

    function startUpperEdgeCold() {
    upperEdgeSnowActive = true;
    upperEdgeViewStartTime = Date.now();
    upperSnowflakes = [];
}

    function stopUpperEdgeCold() {
    upperEdgeSnowActive = false;
    upperShiverIntensity = 0;
    // Frost will fade in the update function
}

    function startUnderEdgeCold() {
    underEdgeSnowActive = true;
    underEdgeViewStartTime = Date.now();
    underSnowflakes = [];
}

    function stopUnderEdgeCold() {
    underEdgeSnowActive = false;
    underShiverIntensity = 0;
    // Frost will fade in the update function
}

    function initFimbulwinterFrost() {
    fimbulFrostCanvas = document.getElementById('fimbul-frost-canvas');
    fimbulFrostCanvas.width = window.innerWidth;
    fimbulFrostCanvas.height = window.innerHeight;
    fimbulFrostCtx = fimbulFrostCanvas.getContext('2d');
}

function initLightning() {
    // Keep canvas for potential future use, but hide it
    lightningCanvas = document.getElementById('lightning-canvas');
    lightningCanvas.style.display = 'none';
    
    // Create 3D group for lightning geometry
    lightningGroup = new THREE.Group();
    lightningGroup.renderOrder = 999;
    scene.add(lightningGroup);
}

function generateLightningPath3D(startPos, endPos, displacement, depth) {
    const points = [startPos.clone()];
    
    // Calculate number of segments based on distance
    const totalDist = startPos.distanceTo(endPos);
    const numSegments = Math.floor(totalDist / 300) + 2;
    
    // Main direction
    const mainDir = new THREE.Vector3().subVectors(endPos, startPos).normalize();
    
    // Build path with sharp angular offsets
    let currentPos = startPos.clone();
    
    for (let i = 1; i < numSegments; i++) {
        const t = i / numSegments;
        
        // Base position along the line
        const basePos = new THREE.Vector3().lerpVectors(startPos, endPos, t);
        
        // Sharp random offset perpendicular to main direction
        const offsetMagnitude = displacement * (1 - t * 0.5) * (Math.random() * 0.8 + 0.2);
        
        // Create perpendicular vectors (avoid NaN when parallel to Y)
        let up = new THREE.Vector3(0, 1, 0);
        if (Math.abs(mainDir.dot(up)) > 0.99) {
            up = new THREE.Vector3(1, 0, 0);
        }
        let perp1 = new THREE.Vector3().crossVectors(mainDir, up);
        if (perp1.length() < 0.001) perp1.set(1, 0, 0);
        perp1.normalize();
        let perp2 = new THREE.Vector3().crossVectors(mainDir, perp1);
        if (perp2.length() < 0.001) perp2.set(0, 0, 1);
        perp2.normalize();
        
        // Random offset in perpendicular plane
        const angle = Math.random() * Math.PI * 2;
        const offset = perp1.clone().multiplyScalar(Math.cos(angle) * offsetMagnitude)
            .add(perp2.clone().multiplyScalar(Math.sin(angle) * offsetMagnitude));
        
        currentPos = basePos.add(offset);
        points.push(currentPos.clone());
    }
    
    points.push(endPos.clone());
    
    return points;
}

function spawnLightningBolt3D(luminaryMesh, isUpperWorld, color) {
    const startPos = luminaryMesh.position.clone();
    
    // Random direction in full 360 sphere (uniform distribution)
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    
    const dirX = Math.sin(phi) * Math.cos(theta);
    const dirY = Math.cos(phi);
    const dirZ = Math.sin(phi) * Math.sin(theta);
    
    const direction = new THREE.Vector3(dirX, dirY, dirZ).normalize();
    
    // Find intersection with shell (sphere) or strata (plane)
    let endPos = null;
    
    // Ray-sphere intersection for shell
const rayA = 1;
const rayB = 2 * startPos.dot(direction);
const rayC = startPos.dot(startPos) - SHELL_RADIUS * SHELL_RADIUS;
const discriminant = rayB * rayB - 4 * rayA * rayC;
    
let shellT = Infinity;
if (discriminant >= 0) {
    const sqrtD = Math.sqrt(Math.max(0, discriminant));
    const t1 = (-rayB + sqrtD) / 2;
    const t2 = (-rayB - sqrtD) / 2;
    // Use the positive t value (forward along ray)
    if (t1 > 10) shellT = t1;
    if (t2 > 10 && t2 < shellT) shellT = t2;
}
    
    // Ray-plane intersection for strata surface
    const strataY = isUpperWorld ? (DISK_THICKNESS / 2) : -(DISK_THICKNESS / 2);
    let strataT = Infinity;
    
    if (Math.abs(direction.y) > 0.001) {
        const t = (strataY - startPos.y) / direction.y;
        if (t > 10) {
            const hitX = startPos.x + t * direction.x;
            const hitZ = startPos.z + t * direction.z;
            const distFromCenter = Math.sqrt(hitX * hitX + hitZ * hitZ);
            if (distFromCenter <= DISK_RADIUS) {
                strataT = t;
            }
        }
    }
    
    // Use closer valid intersection
    if (shellT < strataT && shellT < Infinity) {
        endPos = startPos.clone().add(direction.clone().multiplyScalar(shellT));
    } else if (strataT < Infinity) {
        endPos = startPos.clone().add(direction.clone().multiplyScalar(strataT));
    } else if (shellT < Infinity) {
        endPos = startPos.clone().add(direction.clone().multiplyScalar(shellT));
    } else {
        endPos = startPos.clone().add(direction.clone().multiplyScalar(SHELL_RADIUS));
    }
    
    const path3D = generateLightningPath3D(startPos, endPos, 80, 0);
    
    // Generate branches
    const branches = [];
    for (let i = 1; i < path3D.length - 1; i++) {
        if (Math.random() < LIGHTNING_BRANCH_CHANCE) {
            const branchStart = path3D[i].clone();
            const branchDir = new THREE.Vector3(
                (Math.random() - 0.5),
                (Math.random() - 0.5),
                (Math.random() - 0.5)
            ).normalize();
            
            const branchLength = 50 + Math.random() * 150;
            const branchEnd = branchStart.clone().add(branchDir.multiplyScalar(branchLength));
            branches.push([branchStart, branchEnd]);
            
            if (Math.random() < 0.4) {
                const subDir = branchDir.clone();
                subDir.x += (Math.random() - 0.5) * 0.8;
                subDir.z += (Math.random() - 0.5) * 0.8;
                subDir.normalize();
                
                const subLength = 25 + Math.random() * 60;
                const midPoint = branchStart.clone().lerp(branchEnd, 0.5);
                const subEnd = midPoint.clone().add(subDir.multiplyScalar(subLength));
                branches.push([midPoint, subEnd]);
            }
        }
    }
    
    // Determine color
    let r, g, b;
    if (color === 'sun') { r = 255; g = 255; b = 220; }
    else if (color === 'moon') { r = 180; g = 200; b = 255; }
    else if (color === 'usun') { r = 255; g = 120; b = 80; }
    else if (color === 'umoon') { r = 150; g = 130; b = 255; }
    
// Create main bolt as 3D Line
const mainMaterial = new THREE.LineBasicMaterial({
    color: new THREE.Color(`rgb(${Math.min(255, r * 1.5)}, ${Math.min(255, g * 1.5)}, ${Math.min(255, b * 1.5)})`),
    transparent: true,
    opacity: 1.0,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});
    
    const mainGeometry = new THREE.BufferGeometry().setFromPoints(path3D);
    const mainLine = new THREE.Line(mainGeometry, mainMaterial);
    lightningGroup.add(mainLine);
    
    // Create branch lines
    const branchLines = [];
    for (const branch of branches) {
        const branchMaterial = new THREE.LineBasicMaterial({
            color: new THREE.Color(`rgb(${r}, ${g}, ${b})`),
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const branchGeometry = new THREE.BufferGeometry().setFromPoints(branch);
        const branchLine = new THREE.Line(branchGeometry, branchMaterial);
        lightningGroup.add(branchLine);
        branchLines.push(branchLine);
    }
    
    activeLightningBolts.push({
        color: color,
        spawnTime: Date.now(),
        lifetime: LIGHTNING_BOLT_LIFETIME + Math.random() * 80,
        mainLine: mainLine,
        branchLines: branchLines
    });
}

function updateLightning() {
    const now = Date.now();
    
    // Spawn bolts during flicker
    if (sunFlickerActive && sunMesh && sunVisible) {
        const flickerElapsed = now - sunFlickerStartTime;
        const flickerProgress = flickerElapsed / SUN_FLICKER_DURATION;
        upperSunFlicker = 1 - flickerProgress;
        const spawnChance = (1 - flickerProgress) * LIGHTNING_SPAWN_RATE / 60;
        if (Math.random() < spawnChance) spawnLightningBolt3D(sunMesh, true, 'sun');
    }
    if (moonFlickerActive && moonMesh && moonVisible) {
        const flickerElapsed = now - moonFlickerStartTime;
        const flickerProgress = flickerElapsed / MOON_FLICKER_DURATION;
        upperMoonFlicker = 1 - flickerProgress;
        const spawnChance = (1 - flickerProgress) * LIGHTNING_SPAWN_RATE / 60;
        if (Math.random() < spawnChance) spawnLightningBolt3D(moonMesh, true, 'moon');
    }
    if (uSunFlickerActive && underworldSunMesh && underworldSunVisible) {
        const flickerElapsed = now - uSunFlickerStartTime;
        const flickerProgress = flickerElapsed / USUN_FLICKER_DURATION;
        lowerSunFlicker = 1 - flickerProgress;
        const spawnChance = (1 - flickerProgress) * LIGHTNING_SPAWN_RATE / 60;
        if (Math.random() < spawnChance) spawnLightningBolt3D(underworldSunMesh, false, 'usun');
    }
    if (uMoonFlickerActive && underworldMoonMesh && underworldMoonVisible) {
        const flickerElapsed = now - uMoonFlickerStartTime;
        const flickerProgress = flickerElapsed / UMOON_FLICKER_DURATION;
        lowerMoonFlicker = 1 - flickerProgress;
        const spawnChance = (1 - flickerProgress) * LIGHTNING_SPAWN_RATE / 60;
        if (Math.random() < spawnChance) spawnLightningBolt3D(underworldMoonMesh, false, 'umoon');
    }
    
    // Shell lightning during ANY re-ignition
    const anyFlickerActive = sunFlickerActive || moonFlickerActive || uSunFlickerActive || uMoonFlickerActive;
    if (anyFlickerActive) {
        const shellSpawnChance = SHELL_LIGHTNING_SPAWN_RATE / 60;
        if (Math.random() < shellSpawnChance) spawnShellLightningBolt();
    }
    
    // Update and remove expired bolts
    for (let i = activeLightningBolts.length - 1; i >= 0; i--) {
        const bolt = activeLightningBolts[i];
        const age = now - bolt.spawnTime;
        
        if (age >= bolt.lifetime) {
            // Remove from scene and dispose
            lightningGroup.remove(bolt.mainLine);
            bolt.mainLine.geometry.dispose();
            bolt.mainLine.material.dispose();
            
            for (const branchLine of bolt.branchLines) {
                lightningGroup.remove(branchLine);
                branchLine.geometry.dispose();
                branchLine.material.dispose();
            }
            
            activeLightningBolts.splice(i, 1);
            continue;
        }
        
        // Fade based on age
        const alpha = 1 - (age / bolt.lifetime);
        bolt.mainLine.material.opacity = alpha;
        for (const branchLine of bolt.branchLines) {
            branchLine.material.opacity = alpha * 0.7;
        }
        
    }
}

function spawnShellLightningBolt() {
    // Pick first random point on shell
    const theta1 = Math.random() * Math.PI * 2;
    const phi1 = Math.acos(2 * Math.random() - 1);
    const startPos = new THREE.Vector3(
        SHELL_RADIUS * Math.sin(phi1) * Math.cos(theta1),
        SHELL_RADIUS * Math.sin(phi1) * Math.sin(theta1),
        SHELL_RADIUS * Math.cos(phi1)
    );
    
    // Pick second random point on shell (not too far, not too close)
    const angleOffset = 1.0 + Math.random() * 1.5;
    const theta2 = theta1 + (Math.random() - 0.5) * angleOffset;
    const phi2 = phi1 + (Math.random() - 0.5) * angleOffset;
    const endPos = new THREE.Vector3(
        SHELL_RADIUS * Math.sin(phi2) * Math.cos(theta2),
        SHELL_RADIUS * Math.sin(phi2) * Math.sin(theta2),
        SHELL_RADIUS * Math.cos(phi2)
    );
    
    // Generate path that CRAWLS ALONG the shell surface
    const numSegments = 50 + Math.floor(Math.random() * 40);
    const path3D = [];
    
    for (let i = 0; i <= numSegments; i++) {
        const t = i / numSegments;
        
        // Spherical interpolation - stay on the shell!
        const point = new THREE.Vector3().lerpVectors(startPos, endPos, t);
        point.normalize().multiplyScalar(SHELL_RADIUS);
        
         // Add sideways jitter (stays on shell surface)
        if (i > 0 && i < numSegments) {
            const normal = point.clone().normalize();
            let upVec = new THREE.Vector3(0, 1, 0);
            if (Math.abs(normal.dot(upVec)) > 0.99) {
                upVec = new THREE.Vector3(1, 0, 0);
            }
            let tangent1 = upVec.clone().cross(normal);
            if (tangent1.length() < 0.001) tangent1.set(1, 0, 0);
            tangent1.normalize();
            let tangent2 = normal.clone().cross(tangent1);
            if (tangent2.length() < 0.001) tangent2.set(0, 0, 1);
            tangent2.normalize();
            
            const jitter = 50 + Math.random() * 100;
            point.add(tangent1.multiplyScalar((Math.random() - 0.5) * jitter));
            point.add(tangent2.multiplyScalar((Math.random() - 0.5) * jitter));
            
            // Snap back to shell surface!
            point.normalize().multiplyScalar(SHELL_RADIUS);
        }
        
        path3D.push(point);
    }
    
// Match shell lightning color to whichever luminary is flickering
let r = 200, g = 220, b = 255; // default white-blue

if (sunFlickerActive) {
    r = 255; g = 255; b = 220; // gold for upper sun
} else if (moonFlickerActive) {
    r = 180; g = 200; b = 255; // blue for upper moon
} else if (uSunFlickerActive) {
    r = 255; g = 120; b = 80;  // red for underworld sun
} else if (uMoonFlickerActive) {
    r = 150; g = 130; b = 255; // violet for underworld moon
}
    
    // Create main bolt
    const mainMaterial = new THREE.LineBasicMaterial({
        color: new THREE.Color(`rgb(${r}, ${g}, ${b})`),
        transparent: true,
        opacity: 1.0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    const mainGeometry = new THREE.BufferGeometry().setFromPoints(path3D);
    const mainLine = new THREE.Line(mainGeometry, mainMaterial);
    lightningGroup.add(mainLine);
    
    // Create branches
    const branchLines = [];
    for (let i = 1; i < path3D.length - 1; i++) {
        if (Math.random() < LIGHTNING_BRANCH_CHANCE * 0.5) {
            const branchStart = path3D[i].clone();
            
            // Branch direction along shell surface (avoid NaN when at poles)
            const normal = branchStart.clone().normalize();
            let upVec = new THREE.Vector3(0, 1, 0);
            if (Math.abs(normal.dot(upVec)) > 0.99) {
                upVec = new THREE.Vector3(1, 0, 0);
            }
            let tangent1 = upVec.clone().cross(normal);
            if (tangent1.length() < 0.001) tangent1.set(1, 0, 0);
            tangent1.normalize();
            let tangent2 = normal.clone().cross(tangent1);
            if (tangent2.length() < 0.001) tangent2.set(0, 0, 1);
            tangent2.normalize();
            
            const branchLength = 30 + Math.random() * 80;
            const branchEnd = branchStart.clone()
                .add(tangent1.multiplyScalar((Math.random() - 0.5) * branchLength))
                .add(tangent2.multiplyScalar((Math.random() - 0.5) * branchLength));
            
            // Keep branch on shell surface too
            branchEnd.normalize().multiplyScalar(SHELL_RADIUS);
            
const branchMaterial = new THREE.LineBasicMaterial({
    color: new THREE.Color(`rgb(${Math.min(255, r * 1.5)}, ${Math.min(255, g * 1.5)}, ${Math.min(255, b * 1.5)})`),
    transparent: true,
    opacity: 0.7,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});
            const branchGeometry = new THREE.BufferGeometry().setFromPoints([branchStart, branchEnd]);
            const branchLine = new THREE.Line(branchGeometry, branchMaterial);
            lightningGroup.add(branchLine);
            branchLines.push(branchLine);
        }
    }
    
    // Determine which hemisphere's flicker spawned this bolt
    const upperFlicker = sunFlickerActive || moonFlickerActive;
    const lowerFlicker = uSunFlickerActive || uMoonFlickerActive;
    
activeLightningBolts.push({
    color: 'shell',
    spawnTime: Date.now(),
    lifetime: LIGHTNING_BOLT_LIFETIME + Math.random() * 80,
    mainLine: mainLine,
    branchLines: branchLines,
    isUpperHemisphere: upperFlicker && !lowerFlicker ? true : (!upperFlicker && lowerFlicker ? false : startPos.y >= 0),
    flickerSource: sunFlickerActive ? 'sun' : (moonFlickerActive ? 'moon' : (uSunFlickerActive ? 'usun' : 'umoon'))
});
} 

     // ============ LENS FLARE SYSTEM FUNCTIONS ============
    function initLensFlare() {
    lensFlareCanvas = document.getElementById('lens-flare-canvas');
    lensFlareCanvas.width = window.innerWidth;
    lensFlareCanvas.height = window.innerHeight;
    lensFlareCtx = lensFlareCanvas.getContext('2d');
}

    function updateLensFlare() {
    if (!lensFlareCtx || !lensFlareCanvas) return;
   
    // Check if disabled, not in ground view, or at the edge (too far to see clearly)
    if (!lensFlareEnabled || !isGroundView || isEdgeView || isUnderworldEdgeView) {
        lensFlareCtx.clearRect(0, 0, lensFlareCanvas.width, lensFlareCanvas.height);
        return;
    }
   
    lensFlareCtx.clearRect(0, 0, lensFlareCanvas.width, lensFlareCanvas.height);
   
    // Get camera direction
    const cameraDir = new THREE.Vector3();
    camera.getWorldDirection(cameraDir);
   
    // Check upper sun - no flare when sun is too dim
        // Check upper sun - no flare when sun is too dim OR when in underworld view
    const inUpperGroundView = !isUnderworldView && !isUnderworldEdgeView && !isUnderworldMidView && !isUSunView && !isUMoonView;
    if (sunMesh && sunVisible && sunMesh.visible && SUN_BRIGHTNESS > 0.5 && inUpperGroundView) {
        const toSun = new THREE.Vector3().subVectors(sunMesh.position, camera.position).normalize();
        const dot = cameraDir.dot(toSun);
       
        if (dot > FLARE_THRESHOLD) {
            const intensity = (dot - FLARE_THRESHOLD) / (1 - FLARE_THRESHOLD);
            const screenPos = getScreenPosition(sunMesh.position);
            if (screenPos) {
                drawLensFlare(screenPos.x, screenPos.y, intensity, 'upper');
            }
        }
    }
   
    // Check underworld sun - no flare when sun is too dim
    if (underworldSunMesh && underworldSunVisible && underworldSunMesh.visible && USUN_BRIGHTNESS > 0.5 && (isUnderworldView || isUSunView || isUMoonView)) {
        const toUSun = new THREE.Vector3().subVectors(underworldSunMesh.position, camera.position).normalize();
        const dot = cameraDir.dot(toUSun);
       
        if (dot > FLARE_THRESHOLD) {
            const intensity = (dot - FLARE_THRESHOLD) / (1 - FLARE_THRESHOLD);
            const screenPos = getScreenPosition(underworldSunMesh.position);
            if (screenPos) {
                drawLensFlare(screenPos.x, screenPos.y, intensity, 'underworld');
            }
        }
    }
}

    function getScreenPosition(worldPos) {
    const pos = worldPos.clone();
    pos.project(camera);
   
    // Check if behind camera
    if (pos.z > 1) return null;
   
    const x = (pos.x + 1) / 2 * lensFlareCanvas.width;
    const y = (-pos.y + 1) / 2 * lensFlareCanvas.height;
   
    return { x, y };
}

    function drawLensFlare(x, y, intensity, type) {
    const ctx = lensFlareCtx;
    const w = lensFlareCanvas.width;
    const h = lensFlareCanvas.height;
    const centerX = w / 2;
    const centerY = h / 2;
   
    // Direction from sun to center (for ghost flares)
    const dx = centerX - x;
    const dy = centerY - y;
   
    // Color based on sun type
    const isUpper = type === 'upper';
    const mainColor = isUpper ? [255, 220, 100] : [255, 80, 50];
    const secondColor = isUpper ? [255, 180, 50] : [255, 50, 30];
    const thirdColor = isUpper ? [255, 255, 200] : [255, 120, 80];
   
    const alpha = intensity * FLARE_MAX_INTENSITY;
   
    // Main sun bloom - subtle glow
    let gradient = ctx.createRadialGradient(x, y, 0, x, y, 150 * intensity);
    gradient.addColorStop(0, `rgba(${mainColor[0]}, ${mainColor[1]}, ${mainColor[2]}, ${alpha * 0.3})`);
    gradient.addColorStop(0.3, `rgba(${mainColor[0]}, ${mainColor[1]}, ${mainColor[2]}, ${alpha * 0.15})`);
    gradient.addColorStop(0.6, `rgba(${secondColor[0]}, ${secondColor[1]}, ${secondColor[2]}, ${alpha * 0.05})`);
    gradient.addColorStop(1, `rgba(${secondColor[0]}, ${secondColor[1]}, ${secondColor[2]}, 0)`);
   
    // Anamorphic streak (horizontal) - only when looking almost directly at sun
    if (intensity > 0.8) {
        const streakAlpha = (intensity - 0.8) / 0.2; // Fade in from 0.8 to 1.0
        gradient = ctx.createRadialGradient(x, y, 0, x, y, 160);
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1.8, 0.07);
        ctx.translate(-x, -y);
        gradient.addColorStop(0, `rgba(${thirdColor[0]}, ${thirdColor[1]}, ${thirdColor[2]}, ${streakAlpha * 0.1})`);
        gradient.addColorStop(0.5, `rgba(${mainColor[0]}, ${mainColor[1]}, ${mainColor[2]}, ${streakAlpha * 0.03})`);
        gradient.addColorStop(1, `rgba(${mainColor[0]}, ${mainColor[1]}, ${mainColor[2]}, 0)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(x - 400, y - 200, 800, 400);
        ctx.restore();
    }
   
    // Ghost flares along the line through center
    const ghosts = [
        { dist: 0.3, size: 40, opacity: 0.15 },
        { dist: 0.5, size: 60, opacity: 0.1 },
        { dist: 0.7, size: 30, opacity: 0.12 },
        { dist: 1.0, size: 80, opacity: 0.08 },
        { dist: 1.3, size: 50, opacity: 0.1 },
        { dist: 1.6, size: 25, opacity: 0.15 }
    ];
   
    ghosts.forEach(ghost => {
        const gx = x + dx * ghost.dist;
        const gy = y + dy * ghost.dist;
        const gSize = ghost.size * (0.5 + intensity * 0.5);
       
        gradient = ctx.createRadialGradient(gx, gy, 0, gx, gy, gSize);
        gradient.addColorStop(0, `rgba(${thirdColor[0]}, ${thirdColor[1]}, ${thirdColor[2]}, ${ghost.opacity * alpha})`);
        gradient.addColorStop(0.5, `rgba(${mainColor[0]}, ${mainColor[1]}, ${mainColor[2]}, ${ghost.opacity * alpha * 0.5})`);
        gradient.addColorStop(1, `rgba(${mainColor[0]}, ${mainColor[1]}, ${mainColor[2]}, 0)`);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(gx, gy, gSize, 0, Math.PI * 2);
        ctx.fill();
    });
   
    // Hexagonal flare artifact
    if (intensity > 0.5) {
        const hexX = x + dx * 0.4;
        const hexY = y + dy * 0.4;
        const hexSize = 35 * intensity;
       
        ctx.strokeStyle = `rgba(${thirdColor[0]}, ${thirdColor[1]}, ${thirdColor[2]}, ${alpha * 0.3})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const px = hexX + Math.cos(angle) * hexSize;
            const py = hexY + Math.sin(angle) * hexSize;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
    }
}

    function updateUnderworldLuminaryLink() {
    if (!underworldLuminaryLine || !underworldLuminaryDistanceSprite || !underworldSunMesh || !underworldMoonMesh) return;
   
    // Always calculate and display distance in info panel
    const distance = Math.round(underworldSunMesh.position.distanceTo(underworldMoonMesh.position));
    document.getElementById('underworld-luminary-distance-info').textContent = distance.toLocaleString() + ' mi';
   
    const showLink = underworldLuminaryLinkVisible && underworldSunVisible && underworldMoonVisible;
    underworldLuminaryLine.visible = showLink;
    underworldLuminaryDistanceSprite.visible = showLink;
    if (!showLink) return;
   
    // Update line positions
    const positions = underworldLuminaryLine.geometry.attributes.position.array;
    const colors = underworldLuminaryLine.geometry.attributes.color.array;
    positions[0] = underworldSunMesh.position.x; positions[1] = underworldSunMesh.position.y; positions[2] = underworldSunMesh.position.z;
    positions[3] = underworldMoonMesh.position.x; positions[4] = underworldMoonMesh.position.y; positions[5] = underworldMoonMesh.position.z;
    // Underworld sun = red (ff4444), Underworld moon = dark blue (4444aa)
    colors[0] = 1.0; colors[1] = 0.27; colors[2] = 0.27;
    colors[3] = 0.27; colors[4] = 0.27; colors[5] = 0.67;
    underworldLuminaryLine.geometry.attributes.position.needsUpdate = true;
    underworldLuminaryLine.geometry.attributes.color.needsUpdate = true;
   
    // Update floating label
    const { canvas, texture } = underworldLuminaryDistanceSprite.userData;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath(); ctx.roundRect(20, 12, 216, 40, 20); ctx.fill();
    const gradient = ctx.createLinearGradient(50, 0, 206, 0);
    gradient.addColorStop(0, '#ff4444'); gradient.addColorStop(0.5, '#aa44aa'); gradient.addColorStop(1, '#4444aa');
    ctx.font = 'Bold 22px Segoe UI'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = gradient; ctx.fillText(distance.toLocaleString() + ' mi', canvas.width/2, canvas.height/2);
    texture.needsUpdate = true;
    const midpoint = new THREE.Vector3().addVectors(underworldSunMesh.position, underworldMoonMesh.position).multiplyScalar(0.5);
    midpoint.y -= 200;
    underworldLuminaryDistanceSprite.position.copy(midpoint);

    // Scale sprite based on camera distance
    const camDist = camera.position.distanceTo(midpoint);
    const scaleFactor = Math.min(300, Math.max(80, camDist * 0.06));
    underworldLuminaryDistanceSprite.scale.set(scaleFactor * 4, scaleFactor, 1);
}
       
        // Track previous positions for velocity calculation
        let prevSunY = 0, prevMoonY = 0;
        let lastVelocityUpdate = Date.now();
       
        function updateSunAndMoon(elapsedTime) {
            // Update angles based on speed
            sunAngle += 0.001 * SUN_SPEED;
            moonAngle += 0.001 * MOON_SPEED;
            
                // Smooth brightness transitions
    const brightnessLerpSpeed = 0.02;
    displayedSunBrightness += (SUN_BRIGHTNESS - displayedSunBrightness) * brightnessLerpSpeed;
    displayedMoonBrightness += (MOON_BRIGHTNESS - displayedMoonBrightness) * brightnessLerpSpeed;
    displayedUSunBrightness += (USUN_BRIGHTNESS - displayedUSunBrightness) * brightnessLerpSpeed;
    displayedUMoonBrightness += (UMOON_BRIGHTNESS - displayedUMoonBrightness) * brightnessLerpSpeed;
    
    // Sun flicker effect (re-ignition)
   let sunFlickerMultiplier = 1.0;
   if (sunFlickerActive) {
    const flickerElapsed = Date.now() - sunFlickerStartTime;
    if (flickerElapsed < SUN_FLICKER_DURATION) {
        // Decay: starts at 1.0, ends at 0.0
        const flickerDecay = 1.0 - (flickerElapsed / SUN_FLICKER_DURATION);
        // Rapid oscillation that slows down as it stabilizes
        const flickerSpeed = 9 - (flickerDecay * 10); // 30Hz -> 10Hz
        const flicker = Math.sin(flickerElapsed * flickerSpeed * 0.01) * 0.5 + 0.5;
        // Flicker intensity decreases over time
        sunFlickerMultiplier = 1.8 - (flicker * flickerDecay * 3.0);
    } else {
        sunFlickerActive = false;
    }
}
    // Moon flicker effect (re-ignition)
    let moonFlickerMultiplier = 1.0;
    if (moonFlickerActive) {
    const flickerElapsed = Date.now() - moonFlickerStartTime;
    if (flickerElapsed < MOON_FLICKER_DURATION) {
        const flickerDecay = 1.0 - (flickerElapsed / MOON_FLICKER_DURATION);
        const flickerSpeed = 9 - (flickerDecay * 10);
        const flicker = Math.sin(flickerElapsed * flickerSpeed * 0.01) * 0.5 + 0.5;
        moonFlickerMultiplier = 1.7 - (flicker * flickerDecay * 3.1);
    } else {
        moonFlickerActive = false;
    }
}
    // Underworld Sun flicker effect (re-ignition)
    let uSunFlickerMultiplier = 1.0;
    if (uSunFlickerActive) {
    const flickerElapsed = Date.now() - uSunFlickerStartTime;
    if (flickerElapsed < USUN_FLICKER_DURATION) {
        const flickerDecay = 1.0 - (flickerElapsed / USUN_FLICKER_DURATION);
        const flickerSpeed = 9 - (flickerDecay * 11);
        const flicker = Math.sin(flickerElapsed * flickerSpeed * 0.01) * 0.5 + 0.5;
        uSunFlickerMultiplier = 1.8 - (flicker * flickerDecay * 3.2);
    } else {
        uSunFlickerActive = false;
    }
}
    // Underworld Moon flicker effect (re-ignition)
    let uMoonFlickerMultiplier = 1.0;
    if (uMoonFlickerActive) {
    const flickerElapsed = Date.now() - uMoonFlickerStartTime;
    if (flickerElapsed < UMOON_FLICKER_DURATION) {
        const flickerDecay = 1.0 - (flickerElapsed / UMOON_FLICKER_DURATION);
        const flickerSpeed = 8 - (flickerDecay * 10);
        const flicker = Math.sin(flickerElapsed * flickerSpeed * 0.01) * 0.5 + 0.5;
        uMoonFlickerMultiplier = 1.8 - (flicker * flickerDecay * 3.2);
    } else {
        uMoonFlickerActive = false;
    }
}
            // Update radial phase (slower cycle for seasons)
            sunRadialPhase += 0.0001 * SUN_SPEED;
            moonRadialPhase += 0.00015 * MOON_SPEED;
           
            // Calculate radial factor (0 = at inner orbit/center, 1 = at outer orbit/edge)
            const sunRadialFactor = 0.5 + 0.5 * Math.sin(sunRadialPhase);
            const moonRadialFactor = 0.5 + 0.5 * Math.sin(moonRadialPhase);
           
            // Calculate radial distance (in-out movement)
            const sunRadialPos = SUN_RADIUS_MIN + (SUN_RADIUS_MAX - SUN_RADIUS_MIN) * sunRadialFactor;
            const moonRadialPos = MOON_RADIUS_MIN + (MOON_RADIUS_MAX - MOON_RADIUS_MIN) * moonRadialFactor;
           
            // HEIGHT LINKED TO RADIAL: closer to center = higher, farther out = lower
            // When radialFactor is 0 (inner/center) = max height
            // When radialFactor is 1 (outer/edge) = min height
            const sunDynamicHeight = SUN_HEIGHT * (1.0 - sunRadialFactor * 0.3); // 1.5x at center, 0.7x at edge
            const moonDynamicHeight = MOON_HEIGHT * (1.0 - moonRadialFactor * 0.3);
           
            // Calculate positions (circular path at current radial distance)
            const sunX = Math.cos(sunAngle) * sunRadialPos;
            const sunZ = Math.sin(sunAngle) * sunRadialPos;
            const sunY = sunDynamicHeight + (DISK_THICKNESS / 2);
           
            const moonX = Math.cos(moonAngle) * moonRadialPos;
            const moonZ = Math.sin(moonAngle) * moonRadialPos;
            const moonY = moonDynamicHeight + (DISK_THICKNESS / 2);
           
            // ============ VELOCITY CALCULATIONS ============
            // Angular velocity (radians per frame) -> convert to real-world speeds
            // Assuming 60 FPS, each frame = 1/60 second
            // Angular velocity = 0.001 * SPEED radians per frame = 0.06 * SPEED radians per second
            const FPS = 60;
            const sunAngularVelocity = 0.001 * SUN_SPEED * FPS; // radians per second
            const moonAngularVelocity = 0.001 * MOON_SPEED * FPS;
           
            // Orbital speed = angular velocity × radius (mi/sec)
            const sunOrbitalSpeedPerSec = sunAngularVelocity * sunRadialPos;
            const moonOrbitalSpeedPerSec = moonAngularVelocity * moonRadialPos;
           
            // Convert to mi/hr (× 3600)
            const sunOrbitalSpeed = sunOrbitalSpeedPerSec * 3600;
            const moonOrbitalSpeed = moonOrbitalSpeedPerSec * 3600;
           
            // Vertical speed - rate of altitude change
            // Height varies with sine wave: derivative of sin is cos
            // Vertical velocity = HEIGHT * 0.8 * 0.5 * cos(phase) * phase_velocity
            const sunPhaseVelocity = 0.0001 * SUN_SPEED * FPS; // radians per second
            const moonPhaseVelocity = 0.00015 * MOON_SPEED * FPS;
            const sunVerticalSpeedPerSec = Math.abs(SUN_HEIGHT * 0.8 * 0.5 * Math.cos(sunRadialPhase) * sunPhaseVelocity);
            const moonVerticalSpeedPerSec = Math.abs(MOON_HEIGHT * 0.8 * 0.5 * Math.cos(moonRadialPhase) * moonPhaseVelocity);
            const sunVerticalSpeed = sunVerticalSpeedPerSec * 3600;
            const moonVerticalSpeed = moonVerticalSpeedPerSec * 3600;
           
            // Total speed (Pythagorean)
            const sunTotalSpeed = Math.sqrt(sunOrbitalSpeed * sunOrbitalSpeed + sunVerticalSpeed * sunVerticalSpeed);
            const moonTotalSpeed = Math.sqrt(moonOrbitalSpeed * moonOrbitalSpeed + moonVerticalSpeed * moonVerticalSpeed);
           
            // Moon phase based on interference factor
            let moonPhaseName = 'Full';
            if (moonRadialFactor > 0.95) moonPhaseName = 'New';
            else if (moonRadialFactor > 0.75) moonPhaseName = 'Crescent';
            else if (moonRadialFactor > 0.5) moonPhaseName = 'Quarter';
            else if (moonRadialFactor > 0.25) moonPhaseName = 'Gibbous';
            else moonPhaseName = 'Full';
           
            // Update info panel with velocities
            document.getElementById('sun-altitude-info').textContent = Math.round(sunDynamicHeight).toLocaleString() + ' mi';
            document.getElementById('sun-orbital-info').textContent = Math.round(sunRadialPos).toLocaleString() + ' mi';
            document.getElementById('sun-orbital-speed-info').textContent = Math.round(sunOrbitalSpeed).toLocaleString() + ' mi/hr';
            document.getElementById('sun-vertical-speed-info').textContent = Math.round(sunVerticalSpeed).toLocaleString() + ' mi/hr';
            document.getElementById('sun-total-speed-info').textContent = Math.round(sunTotalSpeed).toLocaleString() + ' mi/hr';
           
            document.getElementById('moon-altitude-info').textContent = Math.round(moonDynamicHeight).toLocaleString() + ' mi';
            document.getElementById('moon-orbital-info').textContent = Math.round(moonRadialPos).toLocaleString() + ' mi';
            document.getElementById('moon-orbital-speed-info').textContent = Math.round(moonOrbitalSpeed).toLocaleString() + ' mi/hr';
            document.getElementById('moon-vertical-speed-info').textContent = Math.round(moonVerticalSpeed).toLocaleString() + ' mi/hr';
            document.getElementById('moon-total-speed-info').textContent = Math.round(moonTotalSpeed).toLocaleString() + ' mi/hr';
            document.getElementById('moon-phase-info').textContent = moonPhaseName;
           
            // Update Sun position
            if (sunMesh && sunVisible) {
                sunMesh.position.set(sunX, sunY, sunZ);
                // Dim sun mesh based on brightness (normalize to 0-1 range, default 1.5)
                const flickeredSunBrightness = displayedSunBrightness * sunFlickerMultiplier;
                const sunBrightnessFactor = Math.min(1, flickeredSunBrightness / 1.5);
                if (displayedSunBrightness < 0.2) {
                    // Go black at very low brightness (0.1 = minimum slider = full black)
                    const blackFactor = (displayedSunBrightness - 0.1) / 0.1;
                    sunMesh.material.color.setRGB(blackFactor * sunBrightnessFactor, blackFactor * sunBrightnessFactor * 0.87, blackFactor * sunBrightnessFactor * 0.27);
                } else {
                    sunMesh.material.color.setRGB(sunBrightnessFactor, sunBrightnessFactor * 0.87, sunBrightnessFactor * 0.27);
                }
                const sunGlowFade = Math.min(1, Math.max(0, (displayedSunBrightness - 0.1) / 0.4));
                sunGlow.position.copy(sunMesh.position);
                sunGlow.visible = displayedSunBrightness > 0.1;
                sunGlow.material.opacity = sunBrightnessFactor * sunGlowFade;
                sunHalo.position.copy(sunMesh.position);
                sunHalo.visible = displayedSunBrightness > 0.1;
                sunHalo.material.opacity = sunBrightnessFactor * 0.3 * sunGlowFade;
sunLight.position.copy(sunMesh.position);
sunLight.intensity = displayedSunBrightness > 0.2 ? (realisticLighting ? flickeredSunBrightness * 3 : flickeredSunBrightness) : 0;

sunLight.position.copy(sunMesh.position);

// Pulse BOTH intensity AND radius during flicker - reignition light blast
let sunIntensityBoost = 1.0;
let sunRadiusMultiplier = 1.0;
if (sunFlickerActive) {
    const flickerElapsed = Date.now() - sunFlickerStartTime;
    const flickerProgress = flickerElapsed / SUN_FLICKER_DURATION;
    const flickerDecay = 1.0 - flickerProgress;
    const flickerSpeed = 9 - (flickerDecay * 10);
    const flicker = Math.sin(flickerElapsed * flickerSpeed * 0.01) * 0.5 + 0.5;
    const sharpFlicker = Math.pow(flicker, 0.5); // Sharper peaks - bright flashes pop harder
    
    // Intensity spikes up to 8x during peaks - DRAMATIC
    sunIntensityBoost = 1.0 + (sharpFlicker * flickerDecay * 7.0);
    // Radius expands up to 2.5x during peaks
    sunRadiusMultiplier = 1.0 + (sharpFlicker * flickerDecay * 1.0);
}

const baseIntensity = displayedSunBrightness > 0.2 ? (realisticLighting ? flickeredSunBrightness * 3 : flickeredSunBrightness) : 0;
sunLight.intensity = baseIntensity * sunIntensityBoost;
sunLight.distance = SUN_LIGHT_RADIUS * sunRadiusMultiplier;
sunLight.distance = SUN_LIGHT_RADIUS * sunRadiusMultiplier;
            } else if (sunMesh) {
                sunMesh.visible = false;
                sunGlow.visible = false;
                sunHalo.visible = false;
                sunLight.intensity = 0;
            }
           
            // Update ambient light based on realistic lighting mode AND Fimbulwinter
            const baseFimbulIntensity = Math.max(upperFimbulwinterIntensity, lowerFimbulwinterIntensity);
            if (baseFimbulIntensity > 0.1) {
                // World is freezing - kill all ambient light
                ambientLight.intensity = 0;
            } else {
                // Normal state - no ambient light
                ambientLight.color.setRGB(1, 1, 1);
                ambientLight.intensity = 0;
            }
           
    // Update Moon position with INTERFERENCE model
            // Moon LOW (radialFactor HIGH, close to strata) = MORE interference = DIMMER
            // Moon HIGH (radialFactor LOW, away from strata) = LESS interference = BRIGHTER
            // SUBTLE effect through most of journey, but COMPLETE blackout at absolute lowest
            const rawInterference = moonInterferenceEnabled ? (1 - moonRadialFactor) : 1;
            // Custom curve: 100% at top, ~80% at 50% down, ~65% at 25% down, 0% at bottom
            const moonInterferenceFactor = Math.pow(rawInterference, INTERFERENCE_DURATION);
            const moonEffectiveBrightness = displayedMoonBrightness * moonInterferenceFactor;
            const moonGlowOpacity = moonInterferenceFactor;
            const moonHaloOpacity = moonInterferenceFactor * 0.25;
            
            // Update Sun/Moon coordinate displays
            if (sunMesh && sunVisible) {
                // Project sun position onto shell for shell coordinates
                const sunShellPoint = sunMesh.position.clone().normalize().multiplyScalar(SHELL_RADIUS);
                const sunShellCoords = getShellCoordinates(sunShellPoint);
                document.getElementById('sun-shell-coords').textContent = 
                    `${sunShellCoords.quadrant} X:${sunShellCoords.x.toLocaleString()} Y:${sunShellCoords.y.toLocaleString()} ${sunShellCoords.zSymbol}:${sunShellCoords.z.toLocaleString()}`;
                
                // Sun strata coordinates (position above disk)
                const sunStrataCoords = getStrataCoordinates(sunMesh.position);
                document.getElementById('sun-strata-coords').textContent = 
                    `${sunStrataCoords.quadrant} X:${sunStrataCoords.x.toLocaleString()} Y:${sunStrataCoords.y.toLocaleString()} Dist:${sunStrataCoords.distFromCenter.toLocaleString()}`;
            } else {
                document.getElementById('sun-shell-coords').textContent = '--';
                document.getElementById('sun-strata-coords').textContent = '--';
            }
            
            if (moonMesh && moonVisible) {
                const moonShellPoint = moonMesh.position.clone().normalize().multiplyScalar(SHELL_RADIUS);
                const moonShellCoords = getShellCoordinates(moonShellPoint);
                document.getElementById('moon-shell-coords').textContent = 
                    `${moonShellCoords.quadrant} X:${moonShellCoords.x.toLocaleString()} Y:${moonShellCoords.y.toLocaleString()} ${moonShellCoords.zSymbol}:${moonShellCoords.z.toLocaleString()}`;
                const moonStrataCoords = getStrataCoordinates(moonMesh.position);
                document.getElementById('moon-strata-coords').textContent = 
                    `${moonStrataCoords.quadrant} X:${moonStrataCoords.x.toLocaleString()} Y:${moonStrataCoords.y.toLocaleString()} Dist:${moonStrataCoords.distFromCenter.toLocaleString()}`;
            } else {
                document.getElementById('moon-shell-coords').textContent = '--';
                document.getElementById('moon-strata-coords').textContent = '--';
            }
            
            if (moonMesh && moonVisible) {
                moonMesh.position.set(moonX, moonY, moonZ);
                
                // Combine brightness slider AND interference factor
                const flickeredMoonBrightness = displayedMoonBrightness * moonFlickerMultiplier;
                const moonBrightnessFactor = Math.min(1, flickeredMoonBrightness / 0.8);
                const combinedMoonFactor = moonBrightnessFactor * moonInterferenceFactor;
                
                // Surface goes dark when either brightness is low OR interference is high
                // Blood moon when sun is dying
                let bloodRedFactor = 0;
                if (displayedSunBrightness < 0.8 && displayedSunBrightness > 0.2) {
                    bloodRedFactor = displayedSunBrightness > 0.5 
                        ? 1 - ((displayedSunBrightness - 0.5) / 0.3)
                        : (displayedSunBrightness - 0.2) / 0.3;
                }
                
                // Fade to black as brightness slider approaches minimum (0.1)
                const moonBlackFactor = displayedMoonBrightness < 0.2 ? Math.max(0, (displayedMoonBrightness - 0.1) / 0.1) : 1;
                
                if (combinedMoonFactor < 0.02 || moonBlackFactor <= 0) {
                    moonMesh.material.color.setRGB(0, 0, 0);
                } else {
                    const r = combinedMoonFactor * (1 + bloodRedFactor * 0.5) * moonBlackFactor;
                    const g = combinedMoonFactor * (1 - bloodRedFactor * 0.7) * moonBlackFactor;
                    const b = combinedMoonFactor * (1.02 - bloodRedFactor * 0.9) * moonBlackFactor;
                    moonMesh.material.color.setRGB(r, g, b);
                }
                moonMesh.visible = displayedMoonBrightness > 0.05;
               
                moonGlow.position.copy(moonMesh.position);
                const moonGlowFade = Math.min(1, Math.max(0, (displayedMoonBrightness - 0.1) / 0.4));
                moonGlow.visible = displayedMoonBrightness > 0.1;
                moonGlow.material.opacity = moonGlowOpacity * 0.6 * combinedMoonFactor * moonGlowFade;

                moonHalo.position.copy(moonMesh.position);
                moonHalo.visible = displayedMoonBrightness > 0.1;
                moonHalo.material.opacity = moonHaloOpacity * 1.4 * combinedMoonFactor * moonGlowFade;
               
moonLight.position.copy(moonMesh.position);

// Pulse BOTH intensity AND radius during flicker - reignition light blast
let moonIntensityBoost = 1.0;
let moonRadiusMultiplier = 1.0;
if (moonFlickerActive) {
    const flickerElapsed = Date.now() - moonFlickerStartTime;
    const flickerProgress = flickerElapsed / MOON_FLICKER_DURATION;
    const flickerDecay = 1.0 - flickerProgress;
    const flickerSpeed = 9 - (flickerDecay * 10);
    const flicker = Math.sin(flickerElapsed * flickerSpeed * 0.01) * 0.5 + 0.5;
    const sharpFlicker = Math.pow(flicker, 0.5); // Sharper peaks - bright flashes pop harder
    
    // Intensity spikes up to 8x during peaks - DRAMATIC
    moonIntensityBoost = 1.0 + (sharpFlicker * flickerDecay * 7.0);
    // Radius expands up to 2x during peaks
    moonRadiusMultiplier = 1.0 + (sharpFlicker * flickerDecay * 1.0);
}

const baseMoonIntensity = displayedMoonBrightness > 0.2 ? (realisticLighting ? moonEffectiveBrightness * moonFlickerMultiplier * 8 * combinedMoonFactor : moonEffectiveBrightness * moonFlickerMultiplier * 4 * combinedMoonFactor) : 0;
moonLight.intensity = baseMoonIntensity * moonIntensityBoost;
moonLight.color.setHex(0x0033ff);
moonLight.distance = MOON_LIGHT_RADIUS * moonRadiusMultiplier;
            } else if (moonMesh) {
                moonMesh.visible = false;
                moonGlow.visible = false;
                moonHalo.visible = false;
                moonLight.intensity = 0;
            }       
            
            // ============ UNDERWORLD LUMINARIES UPDATE ============
            // Mirror physics of upper luminaries, positioned BELOW the disk
           
            underworldSunAngle += 0.001 * USUN_SPEED;
            underworldMoonAngle += 0.001 * UMOON_SPEED;
            underworldSunRadialPhase += 0.0001 * USUN_SPEED;
            underworldMoonRadialPhase += 0.00015 * UMOON_SPEED;
           
            const uSunRadialFactor = 0.5 + 0.5 * Math.sin(underworldSunRadialPhase);
            const uMoonRadialFactor = 0.5 + 0.5 * Math.sin(underworldMoonRadialPhase);
           
            const uSunRadialPos = USUN_RADIUS_MIN + (USUN_RADIUS_MAX - USUN_RADIUS_MIN) * uSunRadialFactor;
            const uMoonRadialPos = UMOON_RADIUS_MIN + (UMOON_RADIUS_MAX - UMOON_RADIUS_MIN) * uMoonRadialFactor;
           
            const uSunDynamicHeight = USUN_HEIGHT * (1.0 - uSunRadialFactor * 0.3);
            const uMoonDynamicHeight = UMOON_HEIGHT * (1.0 - uMoonRadialFactor * 0.3);
           
            // UNDERWORLD positions - BELOW the disk (negative Y)
            const uSunX = Math.cos(underworldSunAngle) * uSunRadialPos;
            const uSunZ = Math.sin(underworldSunAngle) * uSunRadialPos;
            const uSunY = -(uSunDynamicHeight + (DISK_THICKNESS / 2)); // NEGATIVE - below disk
           
            const uMoonX = Math.cos(underworldMoonAngle) * uMoonRadialPos;
            const uMoonZ = Math.sin(underworldMoonAngle) * uMoonRadialPos;
            const uMoonY = -(uMoonDynamicHeight + (DISK_THICKNESS / 2)); // NEGATIVE - below disk
           
            // Underworld Sun phase name
            let uSunPhaseName = 'Full';
            if (uSunRadialFactor > 0.95) uSunPhaseName = 'New';
            else if (uSunRadialFactor > 0.75) uSunPhaseName = 'Crescent';
            else if (uSunRadialFactor > 0.5) uSunPhaseName = 'Quarter';
            else if (uSunRadialFactor > 0.25) uSunPhaseName = 'Gibbous';
           
            // Underworld Moon phase name
            let uMoonPhaseName = 'Full';
            if (uMoonRadialFactor > 0.95) uMoonPhaseName = 'New';
            else if (uMoonRadialFactor > 0.75) uMoonPhaseName = 'Crescent';
            else if (uMoonRadialFactor > 0.5) uMoonPhaseName = 'Quarter';
            else if (uMoonRadialFactor > 0.25) uMoonPhaseName = 'Gibbous';
           
            // Update info panel
            document.getElementById('usun-altitude-info').textContent = Math.round(uSunDynamicHeight).toLocaleString() + ' mi';
            document.getElementById('usun-orbital-info').textContent = Math.round(uSunRadialPos).toLocaleString() + ' mi';
            document.getElementById('usun-phase-info').textContent = uSunPhaseName;
            document.getElementById('umoon-altitude-info').textContent = Math.round(uMoonDynamicHeight).toLocaleString() + ' mi';
            document.getElementById('umoon-orbital-info').textContent = Math.round(uMoonRadialPos).toLocaleString() + ' mi';
            document.getElementById('umoon-phase-info').textContent = uMoonPhaseName;
           
            // Update Underworld Sun position
            if (underworldSunMesh && underworldSunVisible) {
                underworldSunMesh.position.set(uSunX, uSunY, uSunZ);
                underworldSunMesh.visible = true;
                underworldSunGlow.position.copy(underworldSunMesh.position);
                underworldSunGlow.visible = true;
                underworldSunHalo.position.copy(underworldSunMesh.position);
                underworldSunHalo.visible = true;
                underworldSunLight.position.copy(underworldSunMesh.position);
                underworldSunLight.intensity = realisticLighting ? USUN_BRIGHTNESS * 3 : USUN_BRIGHTNESS;
                underworldSunLight.distance = USUN_LIGHT_RADIUS;
            } else if (underworldSunMesh) {
                underworldSunMesh.visible = false;
                underworldSunGlow.visible = false;
                underworldSunHalo.visible = false;
                underworldSunLight.intensity = 0;
            }
           
            // Underworld Moon interference (same physics as upper moon)
            const uRawInterference = underworldMoonInterferenceEnabled ? (1 - uMoonRadialFactor) : 1;
            const uMoonInterferenceFactor = Math.pow(uRawInterference, UMOON_INTERFERENCE_DURATION);
           
            // Update Underworld Moon position
            if (underworldMoonMesh && underworldMoonVisible) {
                underworldMoonMesh.position.set(uMoonX, uMoonY, uMoonZ);
                
                // Combine brightness slider AND interference factor
                const flickeredUMoonBrightness = displayedUMoonBrightness * uMoonFlickerMultiplier;
                const uMoonBrightnessFactor = Math.min(1, flickeredUMoonBrightness / 0.8);
                const combinedUMoonFactor = uMoonBrightnessFactor * uMoonInterferenceFactor;
                
                // Blood moon when underworld sun is dying
                let uBloodRedFactor = 0;
                if (displayedUSunBrightness < 0.8 && displayedUSunBrightness > 0.2) {
                    uBloodRedFactor = displayedUSunBrightness > 0.5 
                        ? 1 - ((displayedUSunBrightness - 0.5) / 0.3)
                        : (displayedUSunBrightness - 0.2) / 0.3;
                }
                
                // Fade to black as brightness slider approaches minimum (0.1)
                const uMoonBlackFactor = displayedUMoonBrightness < 0.2 ? Math.max(0, (displayedUMoonBrightness - 0.1) / 0.1) : 1;
                
                if (combinedUMoonFactor < 0.02 || uMoonBlackFactor <= 0) {
                    underworldMoonMesh.material.color.setRGB(0, 0, 0);
                } else {
                    const r = combinedUMoonFactor * (0.13 + uBloodRedFactor * 0.87) * uMoonBlackFactor;
                    const g = combinedUMoonFactor * (0.2 - uBloodRedFactor * 0.1) * uMoonBlackFactor;
                    const b = combinedUMoonFactor * (0.67 - uBloodRedFactor * 0.6) * uMoonBlackFactor;
                    underworldMoonMesh.material.color.setRGB(r, g, b);
                }
                underworldMoonMesh.visible = displayedUMoonBrightness > 0.05;
                
                underworldMoonGlow.position.copy(underworldMoonMesh.position);
                const uMoonGlowFade = Math.min(1, Math.max(0, (displayedUMoonBrightness - 0.1) / 0.4));
                underworldMoonGlow.visible = displayedUMoonBrightness > 0.1;
                underworldMoonGlow.material.opacity = combinedUMoonFactor * 0.6 * uMoonGlowFade;

                underworldMoonHalo.position.copy(underworldMoonMesh.position);
                underworldMoonHalo.visible = displayedUMoonBrightness > 0.1;
                underworldMoonHalo.material.opacity = combinedUMoonFactor * 0.5 * uMoonGlowFade;
                
underworldMoonLight.position.copy(underworldMoonMesh.position);

// Pulse BOTH intensity AND radius during flicker - reignition light blast
let uMoonIntensityBoost = 1.0;
let uMoonRadiusMultiplier = 1.0;
if (uMoonFlickerActive) {
    const flickerElapsed = Date.now() - uMoonFlickerStartTime;
    const flickerProgress = flickerElapsed / UMOON_FLICKER_DURATION;
    const flickerDecay = 1.0 - flickerProgress;
    const flickerSpeed = 8 - (flickerDecay * 10);
    const flicker = Math.sin(flickerElapsed * flickerSpeed * 0.01) * 0.5 + 0.5;
    const sharpFlicker = Math.pow(flicker, 0.5); // Sharper peaks - bright flashes pop harder
    
    // Intensity spikes up to 8x during peaks - DRAMATIC
    uMoonIntensityBoost = 1.0 + (sharpFlicker * flickerDecay * 7.0);
    // Radius expands up to 2x during peaks
    uMoonRadiusMultiplier = 1.0 + (sharpFlicker * flickerDecay * 1.0);
}
const baseUMoonIntensity = displayedUMoonBrightness > 0.2 ? (realisticLighting ? flickeredUMoonBrightness * 8 * combinedUMoonFactor : flickeredUMoonBrightness * 4 * combinedUMoonFactor) : 0;
underworldMoonLight.intensity = baseUMoonIntensity * uMoonIntensityBoost;
underworldMoonLight.distance = UMOON_LIGHT_RADIUS * uMoonRadiusMultiplier;
underworldMoonLight.color.setHex(0x0033ff);
                underworldMoonLight.color.setHex(0x0033ff);
            } else if (underworldMoonMesh) {
                underworldMoonMesh.visible = false;
                underworldMoonGlow.visible = false;
                underworldMoonHalo.visible = false;
                underworldMoonLight.intensity = 0;
            }
            // Update Underworld Sun position
            if (underworldSunMesh && underworldSunVisible) {
                underworldSunMesh.position.set(uSunX, uSunY, uSunZ);
                // Dim underworld sun mesh based on brightness (normalize to 0-1, default 1.5)
                const flickeredUSunBrightness = displayedUSunBrightness * uSunFlickerMultiplier;
                const uSunBrightnessFactor = Math.min(1, flickeredUSunBrightness / 1.5);
                if (displayedUSunBrightness < 0.2) {
                    // Go black at very low brightness (0.1 = minimum slider = full black)
                    const blackFactor = (displayedUSunBrightness - 0.1) / 0.1;
                    underworldSunMesh.material.color.setRGB(blackFactor * uSunBrightnessFactor, blackFactor * uSunBrightnessFactor * 0.13, blackFactor * uSunBrightnessFactor * 0.13);
                } else {
                    underworldSunMesh.material.color.setRGB(uSunBrightnessFactor, uSunBrightnessFactor * 0.13, uSunBrightnessFactor * 0.13);
                }
                underworldSunMesh.visible = displayedUSunBrightness > 0.05;
                underworldSunGlow.position.copy(underworldSunMesh.position);
                const uSunGlowFade = Math.min(1, Math.max(0, (displayedUSunBrightness - 0.1) / 0.4));
                underworldSunGlow.visible = displayedUSunBrightness > 0.1;
                underworldSunGlow.material.opacity = uSunBrightnessFactor * uSunGlowFade;
                underworldSunHalo.position.copy(underworldSunMesh.position);
                underworldSunHalo.visible = displayedUSunBrightness > 0.1;
                underworldSunHalo.material.opacity = uSunBrightnessFactor * 0.3 * uSunGlowFade;
underworldSunLight.position.copy(underworldSunMesh.position);

// Pulse BOTH intensity AND radius during flicker - reignition light blast
let uSunIntensityBoost = 1.0;
let uSunRadiusMultiplier = 1.0;
if (uSunFlickerActive) {
    const flickerElapsed = Date.now() - uSunFlickerStartTime;
    const flickerProgress = flickerElapsed / USUN_FLICKER_DURATION;
    const flickerDecay = 1.0 - flickerProgress;
    const flickerSpeed = 9 - (flickerDecay * 11);
    const flicker = Math.sin(flickerElapsed * flickerSpeed * 0.01) * 0.5 + 0.5;
    const sharpFlicker = Math.pow(flicker, 0.5); // Sharper peaks - bright flashes pop harder
    
    // Intensity spikes up to 8x during peaks - DRAMATIC
    uSunIntensityBoost = 1.0 + (sharpFlicker * flickerDecay * 7.0);
    // Radius expands up to 2x during peaks
    uSunRadiusMultiplier = 1.0 + (sharpFlicker * flickerDecay * 1.0);
}

const baseUSunIntensity = displayedUSunBrightness > 0.2 ? (realisticLighting ? flickeredUSunBrightness * 3 : flickeredUSunBrightness) : 0;
underworldSunLight.intensity = baseUSunIntensity * uSunIntensityBoost;
underworldSunLight.distance = USUN_LIGHT_RADIUS * uSunRadiusMultiplier;
                
                const uSunShellPoint = underworldSunMesh.position.clone().normalize().multiplyScalar(SHELL_RADIUS);
                const uSunShellCoords = getShellCoordinates(uSunShellPoint);
                document.getElementById('usun-shell-coords').textContent = 
                    `${uSunShellCoords.quadrant} X:${uSunShellCoords.x.toLocaleString()} Y:${uSunShellCoords.y.toLocaleString()} ${uSunShellCoords.zSymbol}:${uSunShellCoords.z.toLocaleString()}`;
                const uSunStrataCoords = getStrataCoordinates(underworldSunMesh.position);
                document.getElementById('usun-strata-coords').textContent = 
                    `${uSunStrataCoords.quadrant} X:${uSunStrataCoords.x.toLocaleString()} Y:${uSunStrataCoords.y.toLocaleString()} Dist:${uSunStrataCoords.distFromCenter.toLocaleString()}`;
            } else if (underworldSunMesh) {
                underworldSunMesh.visible = false;
                underworldSunGlow.visible = false;
                underworldSunHalo.visible = false;
                underworldSunLight.intensity = 0;
                document.getElementById('usun-shell-coords').textContent = '--';
                document.getElementById('usun-strata-coords').textContent = '--';
            }
           
            if (underworldMoonMesh && underworldMoonVisible) {
                const uMoonShellPoint = underworldMoonMesh.position.clone().normalize().multiplyScalar(SHELL_RADIUS);
                const uMoonShellCoords = getShellCoordinates(uMoonShellPoint);
                document.getElementById('umoon-shell-coords').textContent = `${uMoonShellCoords.quadrant} X:${uMoonShellCoords.x.toLocaleString()} Y:${uMoonShellCoords.y.toLocaleString()} ${uMoonShellCoords.zSymbol}:${uMoonShellCoords.z.toLocaleString()}`;
                const uMoonStrataCoords = getStrataCoordinates(underworldMoonMesh.position);
                document.getElementById('umoon-strata-coords').textContent = `${uMoonStrataCoords.quadrant} X:${uMoonStrataCoords.x.toLocaleString()} Y:${uMoonStrataCoords.y.toLocaleString()} Dist:${uMoonStrataCoords.distFromCenter.toLocaleString()}`;
            } else {
                document.getElementById('umoon-shell-coords').textContent = '--';
                document.getElementById('umoon-strata-coords').textContent = '--';
            }
            updateLuminaryLink();  // <-- MOVE IT HERE - runs every frame!
            updateUnderworldLuminaryLink();
        }
       
function createStarAxis() {
    // DISPOSE old star axis to prevent memory leaks
    if (starAxisPivot) {
        if (starAxisLine) {
            starAxisLine.geometry.dispose();
            starAxisLine.material.dispose();
        }
        if (starAxisHandles && starAxisHandles.length > 0) {
            starAxisHandles.forEach(handle => {
                handle.geometry.dispose();
                handle.material.dispose();
            });
        }
        scene.remove(starAxisPivot);
    }
            starAxisPivot = new THREE.Group();
            scene.add(starAxisPivot);
            const axisLength = SHELL_RADIUS * 1.3;
            const starAxisGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-axisLength, 0, 0), new THREE.Vector3(axisLength, 0, 0)]);
            starAxisLine = new THREE.Line(starAxisGeometry, new THREE.LineBasicMaterial({ color: 0xffd54f }));
            starAxisLine.name = 'starAxis';
            starAxisPivot.add(starAxisLine);
            const handleGeometry = new THREE.SphereGeometry(150, 16, 16);
            const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xffd54f, transparent: true, opacity: 0.7 });
            const handle1 = new THREE.Mesh(handleGeometry, handleMaterial.clone());
            handle1.position.set(-axisLength, 0, 0); handle1.name = 'starAxisHandle';
            starAxisPivot.add(handle1);
            const handle2 = new THREE.Mesh(handleGeometry, handleMaterial.clone());
            handle2.position.set(axisLength, 0, 0); handle2.name = 'starAxisHandle';
            starAxisPivot.add(handle2);
            starAxisHandles = [handle1, handle2];
        }
       
        let horizonPlane, gulfLabel, gulfLabel2;
        let gulfRippling = false;
       
        function updateGulfRipple(time) {
            if (!horizonPlane || !horizonPlane.geometry || !horizonPlane.geometry.userData.originalPositions) return;
            if (!gulfRippling) return;
           
            const positions = horizonPlane.geometry.attributes.position.array;
            const original = horizonPlane.geometry.userData.originalPositions;
            const waveSpeed = 4.0;
            const waveHeight = 50;
            const waveFrequency = 0.0008;
           
            for (let i = 0; i < positions.length; i += 3) {
                const x = original[i];
                const y = original[i + 1];
                const dist = Math.sqrt(x * x + y * y);
               
                const ripple = Math.sin(dist * waveFrequency - time * waveSpeed) * waveHeight;
                const ripple2 = Math.sin(dist * waveFrequency * 1.5 + time * waveSpeed * 0.7) * waveHeight * 0.5;
               
                positions[i] = original[i];
                positions[i + 1] = original[i + 1];
                positions[i + 2] = original[i + 2] + ripple + ripple2;
            }
            horizonPlane.geometry.attributes.position.needsUpdate = true;
        }
       
        function createTextSprite(text, fontSize, color, subText) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = subText ? 192 : 128;
            context.font = `Bold ${fontSize}px Arial`;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            const mainY = subText ? canvas.height / 2 - 30 : canvas.height / 2;
            context.fillText(text, canvas.width / 2, mainY);
            if (subText) {
                context.font = `Bold ${Math.floor(fontSize * 0.5)}px Arial`;
                context.fillText(subText, canvas.width / 2, canvas.height / 2 + 35);
            }
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1500, subText ? 562 : 375, 1);
            return sprite;
        }
       
        function updateGulfLabels() {
            const gulfDistance = SHELL_RADIUS - DISK_RADIUS;
            const distanceText = gulfDistance.toLocaleString() + ' mi';
           
            if (gulfLabel) scene.remove(gulfLabel);
            if (gulfLabel2) scene.remove(gulfLabel2);
           
            gulfLabel = createTextSprite('GULF', 96, '#ff6b6b', distanceText);
            gulfLabel.position.set(SHELL_RADIUS * 0.92, 200, 0);
            gulfLabel.visible = horizonVisible;
            scene.add(gulfLabel);
           
            gulfLabel2 = createTextSprite('GULF', 96, '#ff6b6b', distanceText);
            gulfLabel2.position.set(-SHELL_RADIUS * 0.92, 200, 0);
            gulfLabel2.visible = horizonVisible;
            scene.add(gulfLabel2);
        }
       
function createGeometry() {
    // DISPOSE old geometry to prevent memory leaks
    if (shellWireframe) {
        shellWireframe.geometry.dispose();
        shellWireframe.material.dispose();
        scene.remove(shellWireframe);
    }
    if (diskWireframe) {
        diskWireframe.geometry.dispose();
        // diskMaterial is reused, don't dispose
        scene.remove(diskWireframe);
    }
    if (diskFill) {
        diskFill.geometry.dispose();
        diskFill.material.dispose();
        scene.remove(diskFill);
    }
    if (axisLine) {
        axisLine.geometry.dispose();
        axisLine.material.dispose();
        scene.remove(axisLine);
    }
    if (horizonPlane) {
        horizonPlane.geometry.dispose();
        horizonPlane.material.dispose();
        scene.remove(horizonPlane);
    }
    if (gulfLabel) {
        gulfLabel.material.map.dispose();
        gulfLabel.material.dispose();
        scene.remove(gulfLabel);
    }
    if (gulfLabel2) {
        gulfLabel2.material.map.dispose();
        gulfLabel2.material.dispose();
        scene.remove(gulfLabel2);
    }
    if (frostShell) {
        frostShell.geometry.dispose();
        // frostShellMaterial is reused, don't dispose
        scene.remove(frostShell);
    }
            shellWireframe = new THREE.Mesh(new THREE.SphereGeometry(SHELL_RADIUS, 24, 16), new THREE.MeshBasicMaterial({ color: 0x64b5f6, wireframe: true, transparent: true, opacity: 0.4, depthWrite: false }));
            scene.add(shellWireframe);
           
            diskMaterial = new THREE.MeshPhongMaterial({ color: 0x2d5016, shininess: 30, side: THREE.DoubleSide, wireframe: strataWireframe });
diskWireframe = new THREE.Mesh(new THREE.CylinderGeometry(DISK_RADIUS, DISK_RADIUS, DISK_THICKNESS, 64, 1), diskMaterial);
diskWireframe.castShadow = true;
diskWireframe.receiveShadow = false;
scene.add(diskWireframe);
           
            // Transparent fill for wireframe mode
            diskFillMaterial = new THREE.MeshBasicMaterial({ color: 0x2d5016, transparent: true, opacity: 0.25, side: THREE.DoubleSide });
            diskFill = new THREE.Mesh(new THREE.CylinderGeometry(DISK_RADIUS, DISK_RADIUS, DISK_THICKNESS, 64, 1), diskFillMaterial);
            diskFill.visible = strataWireframe;
            scene.add(diskFill);
           
            axisLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -SHELL_RADIUS * 1.3, 0), new THREE.Vector3(0, SHELL_RADIUS * 1.3, 0)]), new THREE.LineBasicMaterial({ color: 0xffd54f }));
            scene.add(axisLine);
            horizonPlane = new THREE.Mesh(
                new THREE.CircleGeometry(SHELL_RADIUS, 96),
                new THREE.MeshBasicMaterial({ color: 0xff6b6b, wireframe: true, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            horizonPlane.rotation.x = -Math.PI / 2;
            horizonPlane.geometry.userData.originalPositions = horizonPlane.geometry.attributes.position.array.slice();
            scene.add(horizonPlane);
            updateGulfLabels();
            // Frost shell
            if (frostShell) scene.remove(frostShell);
            if (!frostShellMaterial) createFrostShellMaterial();
            const frostGeometry = new THREE.SphereGeometry(SHELL_RADIUS + 5, 64, 64);
            frostShell = new THREE.Mesh(frostGeometry, frostShellMaterial);
            frostShell.visible = false;
            frostShell.renderOrder = 10;
            scene.add(frostShell);
            frostShellMaterial.uniforms.uShellRadius.value = SHELL_RADIUS;
           
            updateInfoPanel();
        }
       
        function updateInfoPanel() {
            const gap = SHELL_RADIUS - DISK_RADIUS;
            document.getElementById('shell-info').textContent = SHELL_RADIUS.toLocaleString() + ' mi';
            document.getElementById('shell-diameter').textContent = (SHELL_RADIUS * 2).toLocaleString() + ' mi';
            document.getElementById('shell-circum').textContent = '~' + Math.round(2 * Math.PI * SHELL_RADIUS).toLocaleString() + ' mi';
            document.getElementById('disk-info').textContent = DISK_RADIUS.toLocaleString() + ' mi';
            document.getElementById('disk-circum').textContent = '~' + Math.round(2 * Math.PI * DISK_RADIUS).toLocaleString() + ' mi';
            document.getElementById('thickness-info').textContent = DISK_THICKNESS.toLocaleString() + ' mi';
            document.getElementById('gap-info').textContent = gap.toLocaleString() + ' mi';
           
            // Heights & Distances calculations
            const skyHeight = SHELL_RADIUS - (DISK_THICKNESS / 2);
            const underworldDepth = SHELL_RADIUS - (DISK_THICKNESS / 2);
            const starsFromSurface = STARFIELD_RADIUS - (DISK_THICKNESS / 2);
            const meteorsFromSurface = SHELL_RADIUS - (DISK_THICKNESS / 2); // Meteors travel on shell
           
            document.getElementById('sky-height-info').textContent = Math.round(skyHeight).toLocaleString() + ' mi';
            document.getElementById('underworld-depth-info').textContent = Math.round(underworldDepth).toLocaleString() + ' mi';
            document.getElementById('stars-surface-info').textContent = Math.round(starsFromSurface).toLocaleString() + ' mi';
            document.getElementById('meteors-surface-info').textContent = Math.round(meteorsFromSurface).toLocaleString() + ' mi';
           
            if (starAxisPivot) {
                const toDeg = 180 / Math.PI;
                document.getElementById('axis-x-info').textContent = (starAxisPivot.rotation.x * toDeg).toFixed(1);
                document.getElementById('axis-y-info').textContent = (starAxisPivot.rotation.y * toDeg).toFixed(1);
                document.getElementById('axis-z-info').textContent = (starAxisPivot.rotation.z * toDeg).toFixed(1);
            }
        }
    initEdgeColdSystem();  
    initFimbulwinterFrost();
    initLensFlare();
    initLightning();
    createStarAxis();
    createGeometry();
    createStarfield();
    createSunAndMoon();
    createLuminaryLink();
    createUnderworldLuminaryLink();
    createShellGrid();
    createShellGridLabels();
    createGridHoverSphere();
    createStrataGrid();
    createStrataGridLabels();
    createStrataHoverMesh();
    initMeteorSystem();
    createMeteorClickSphere();
       
        let isDragging = false, isPanning = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: 0.3, y: 0.8 };
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let cameraDistance = 15000;
        let isGroundView = false, isUnderworldView = false, isEdgeView = false, isMidView = false, isUnderworldEdgeView = false, isUnderworldMidView = false, cameraTransitioning = false;
        let isGroundToGroundTransition = false, previousGroundPosition = null;
        let transitionStartTime = 0, transitionDuration = 2000;
        let groundViewAngles = { pitch: 0, yaw: 0 };
let upperMidPosition = { x: 0, z: 0 };
let lowerMidPosition = { x: 0, z: 0 };
let keysPressed = { w: false, a: false, s: false, d: false, shift: false };
        let savedOrbitView = { position: { x: 12000, y: 7000, z: 12000 }, rotation: { x: 0.3, y: 0.8 }, distance: 15000, target: { x: 0, y: 0, z: 0 } };
       
        function getGroundViewPosition() {
            const cameraHeight = 10;
            let yPosition = isUnderworldView ? -DISK_THICKNESS / 2 - cameraHeight : DISK_THICKNESS / 2 + cameraHeight;
            return { position: new THREE.Vector3(0, yPosition, 0), rotation: { x: 0, y: 0 } };
        }
       
        function getGroundViewLookTarget() {
            const groundView = getGroundViewPosition();
            const lookDistance = 1000;
            const pitchMultiplier = isUnderworldView ? -1 : 1;
            return new THREE.Vector3(
                groundView.position.x + Math.cos(groundViewAngles.pitch * pitchMultiplier) * Math.sin(groundViewAngles.yaw) * lookDistance,
                groundView.position.y + Math.sin(groundViewAngles.pitch * pitchMultiplier) * lookDistance,
                groundView.position.z + Math.cos(groundViewAngles.pitch * pitchMultiplier) * Math.cos(groundViewAngles.yaw) * lookDistance
            );
        }
       
        function getEdgeViewPosition() {
            const cameraHeight = 10;
            let yPosition = isUnderworldView ? -DISK_THICKNESS / 2 - cameraHeight : DISK_THICKNESS / 2 + cameraHeight;
            return { position: new THREE.Vector3(DISK_RADIUS - 0.05, yPosition, 0), rotation: { x: 0, y: 0 } };
        }
       
        function getEdgeViewLookTarget() {
            const edgeView = getEdgeViewPosition();
            const lookDistance = 1000;
            const pitchMultiplier = isUnderworldView ? -1 : 1;
            return new THREE.Vector3(
                edgeView.position.x + Math.cos(groundViewAngles.pitch * pitchMultiplier) * Math.sin(groundViewAngles.yaw) * lookDistance,
                edgeView.position.y + Math.sin(groundViewAngles.pitch * pitchMultiplier) * lookDistance,
                edgeView.position.z + Math.cos(groundViewAngles.pitch * pitchMultiplier) * Math.cos(groundViewAngles.yaw) * lookDistance
            );
        }
       
function getMidViewPosition() {
    const cameraHeight = 10;
    let yPosition = isUnderworldView ? -DISK_THICKNESS / 2 - cameraHeight : DISK_THICKNESS / 2 + cameraHeight;
    const pos = isUnderworldView ? lowerMidPosition : upperMidPosition;
    return { position: new THREE.Vector3(pos.x, yPosition, pos.z), rotation: { x: 0, y: 0 } };
}
       
        function getMidViewLookTarget() {
            const midView = getMidViewPosition();
            const lookDistance = 1000;
            const pitchMultiplier = isUnderworldView ? -1 : 1;
            return new THREE.Vector3(
                midView.position.x + Math.cos(groundViewAngles.pitch * pitchMultiplier) * Math.sin(groundViewAngles.yaw) * lookDistance,
                midView.position.y + Math.sin(groundViewAngles.pitch * pitchMultiplier) * lookDistance,
                midView.position.z + Math.cos(groundViewAngles.pitch * pitchMultiplier) * Math.cos(groundViewAngles.yaw) * lookDistance
            );
        }
        function getUnderworldEdgeViewPosition() {
    const cameraHeight = 10;
    let yPosition = -DISK_THICKNESS / 2 - cameraHeight;
    return { position: new THREE.Vector3(DISK_RADIUS - 0.05, yPosition, 0), rotation: { x: 0, y: 0 } };
}

    function getUnderworldEdgeViewLookTarget() {
    const edgeView = getUnderworldEdgeViewPosition();
    const lookDistance = 1000;
    return new THREE.Vector3(
        edgeView.position.x + Math.cos(-groundViewAngles.pitch) * Math.sin(groundViewAngles.yaw) * lookDistance,
        edgeView.position.y + Math.sin(-groundViewAngles.pitch) * lookDistance,
        edgeView.position.z + Math.cos(-groundViewAngles.pitch) * Math.cos(groundViewAngles.yaw) * lookDistance
    );
}

function getUnderworldMidViewPosition() {
    const cameraHeight = 10;
    let yPosition = -DISK_THICKNESS / 2 - cameraHeight;
    return { position: new THREE.Vector3(lowerMidPosition.x, yPosition, lowerMidPosition.z), rotation: { x: 0, y: 0 } };
}

    function getUnderworldMidViewLookTarget() {
    const midView = getUnderworldMidViewPosition();
    const lookDistance = 1000;
    return new THREE.Vector3(
        midView.position.x + Math.cos(-groundViewAngles.pitch) * Math.sin(groundViewAngles.yaw) * lookDistance,
        midView.position.y + Math.sin(-groundViewAngles.pitch) * lookDistance,
        midView.position.z + Math.cos(-groundViewAngles.pitch) * Math.cos(groundViewAngles.yaw) * lookDistance
    );
}
        function getSunViewPosition() {
    if (!sunMesh) return { position: new THREE.Vector3(0, 1000, 0) };
    const sunPos = sunMesh.position.clone();
    const orbitTangent = new THREE.Vector3(-Math.sin(sunAngle), 0, Math.cos(sunAngle));
    const offset = orbitTangent.multiplyScalar(-SUN_SIZE * 8);
    offset.y += SUN_SIZE * 1.5;
    return { position: sunPos.add(offset) };
}

    function getSunViewLookTarget() {
    const sunView = getSunViewPosition();
    const lookDistance = 2000;
    const baseForward = new THREE.Vector3(Math.sin(sunAngle), 0, -Math.cos(sunAngle));
    const baseUp = new THREE.Vector3(0, 1, 0);
    const baseRight = new THREE.Vector3().crossVectors(baseForward, baseUp).normalize();
   
    const pitchedForward = baseForward.clone()
        .multiplyScalar(Math.cos(luminaryViewAngles.pitch))
        .add(baseUp.clone().multiplyScalar(Math.sin(luminaryViewAngles.pitch)));
   
    const finalDir = pitchedForward.clone()
        .multiplyScalar(Math.cos(luminaryViewAngles.yaw))
        .add(baseRight.clone().multiplyScalar(Math.sin(luminaryViewAngles.yaw)));
   
    return sunView.position.clone().add(finalDir.multiplyScalar(lookDistance));
}

    function getMoonViewPosition() {
    if (!moonMesh) return { position: new THREE.Vector3(0, 1000, 0) };
    const moonPos = moonMesh.position.clone();
    const orbitTangent = new THREE.Vector3(-Math.sin(moonAngle), 0, Math.cos(moonAngle));
    const offset = orbitTangent.multiplyScalar(-MOON_SIZE * 8);
    offset.y += MOON_SIZE * 1.5;
    return { position: moonPos.add(offset) };
}

    function getMoonViewLookTarget() {
    const moonView = getMoonViewPosition();
    const lookDistance = 2000;
    const baseForward = new THREE.Vector3(Math.sin(moonAngle), 0, -Math.cos(moonAngle));
    const baseUp = new THREE.Vector3(0, 1, 0);
    const baseRight = new THREE.Vector3().crossVectors(baseForward, baseUp).normalize();
   
    const pitchedForward = baseForward.clone()
        .multiplyScalar(Math.cos(luminaryViewAngles.pitch))
        .add(baseUp.clone().multiplyScalar(Math.sin(luminaryViewAngles.pitch)));
   
    const finalDir = pitchedForward.clone()
        .multiplyScalar(Math.cos(luminaryViewAngles.yaw))
        .add(baseRight.clone().multiplyScalar(Math.sin(luminaryViewAngles.yaw)));
   
    return moonView.position.clone().add(finalDir.multiplyScalar(lookDistance));
}

    function getUSunViewPosition() {
    if (!underworldSunMesh) return { position: new THREE.Vector3(0, -1000, 0) };
    const sunPos = underworldSunMesh.position.clone();
    const orbitTangent = new THREE.Vector3(-Math.sin(underworldSunAngle), 0, Math.cos(underworldSunAngle));
    const offset = orbitTangent.multiplyScalar(-USUN_SIZE * 8);
    offset.y -= USUN_SIZE * 1.5;
    return { position: sunPos.add(offset) };
}

    function getUSunViewLookTarget() {
    const sunView = getUSunViewPosition();
    const lookDistance = 2000;
    const baseForward = new THREE.Vector3(Math.sin(underworldSunAngle), 0, -Math.cos(underworldSunAngle));
    const baseUp = new THREE.Vector3(0, -1, 0);
    const baseRight = new THREE.Vector3().crossVectors(baseForward, baseUp).normalize();
   
    const pitchedForward = baseForward.clone()
        .multiplyScalar(Math.cos(underworldLuminaryViewAngles.pitch))
        .add(baseUp.clone().multiplyScalar(Math.sin(underworldLuminaryViewAngles.pitch)));
   
    const finalDir = pitchedForward.clone()
        .multiplyScalar(Math.cos(underworldLuminaryViewAngles.yaw))
        .add(baseRight.clone().multiplyScalar(Math.sin(underworldLuminaryViewAngles.yaw)));
   
    return sunView.position.clone().add(finalDir.multiplyScalar(lookDistance));
}

    function getUMoonViewPosition() {
    if (!underworldMoonMesh) return { position: new THREE.Vector3(0, -1000, 0) };
    const moonPos = underworldMoonMesh.position.clone();
    const orbitTangent = new THREE.Vector3(-Math.sin(underworldMoonAngle), 0, Math.cos(underworldMoonAngle));
    const offset = orbitTangent.multiplyScalar(-UMOON_SIZE * 8);
    offset.y -= UMOON_SIZE * 1.5;
    return { position: moonPos.add(offset) };
}

    function getUMoonViewLookTarget() {
    const moonView = getUMoonViewPosition();
    const lookDistance = 2000;
    const baseForward = new THREE.Vector3(Math.sin(underworldMoonAngle), 0, -Math.cos(underworldMoonAngle));
    const baseUp = new THREE.Vector3(0, -1, 0);
    const baseRight = new THREE.Vector3().crossVectors(baseForward, baseUp).normalize();
   
    const pitchedForward = baseForward.clone()
        .multiplyScalar(Math.cos(underworldLuminaryViewAngles.pitch))
        .add(baseUp.clone().multiplyScalar(Math.sin(underworldLuminaryViewAngles.pitch)));
   
    const finalDir = pitchedForward.clone()
        .multiplyScalar(Math.cos(underworldLuminaryViewAngles.yaw))
        .add(baseRight.clone().multiplyScalar(Math.sin(underworldLuminaryViewAngles.yaw)));
   
    return moonView.position.clone().add(finalDir.multiplyScalar(lookDistance));
}

            // Helper to get current view position/target based on active view mode
    const getCurrentViewPosition = () => {
    if (isSunView) return getSunViewPosition();
    if (isMoonView) return getMoonViewPosition();
    if (isUSunView) return getUSunViewPosition();
    if (isUMoonView) return getUMoonViewPosition();
    if (isUnderworldEdgeView) return getUnderworldEdgeViewPosition();
    if (isUnderworldMidView) return getUnderworldMidViewPosition();
    if (isMidView) return getMidViewPosition();
    if (isEdgeView) return getEdgeViewPosition();
    return getGroundViewPosition();
};
    const getCurrentLookTarget = () => {
    if (isSunView) return getSunViewLookTarget();
    if (isMoonView) return getMoonViewLookTarget();
    if (isUSunView) return getUSunViewLookTarget();
    if (isUMoonView) return getUMoonViewLookTarget();
    if (isUnderworldEdgeView) return getUnderworldEdgeViewLookTarget();
    if (isUnderworldMidView) return getUnderworldMidViewLookTarget();
    if (isMidView) return getMidViewLookTarget();
    if (isEdgeView) return getEdgeViewLookTarget();
    return getGroundViewLookTarget();
};
       
        function checkAxisHover(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            return raycaster.intersectObjects(starAxisHandles).length > 0 || raycaster.intersectObject(starAxisLine).length > 0;
        }
       
        function checkMeteorClick(event) {
            if (!meteorMode) return null;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(meteorClickSphere);
            return intersects.length > 0 ? intersects[0].point : null;
        }
       
        // Event listeners for sliders
    document.getElementById('shell-radius').addEventListener('input', (e) => {
    SHELL_RADIUS = parseInt(e.target.value);
    document.getElementById('shell-radius-value').textContent = SHELL_RADIUS + ' mi';
    createGeometry();
    createStarAxis();
    createStarfield();
    createShellGrid();
    createShellGridLabels();
    createGridHoverSphere();
    createMeteorClickSphere();
    activeMeteorSources.forEach(s => s.position.normalize().multiplyScalar(SHELL_RADIUS));
    // Restore visibility states
    shellWireframe.visible = shellVisible;
    axisLine.visible = axesVisible;
    starAxisLine.visible = axesVisible;
    starAxisHandles.forEach(h => h.visible = axesVisible);
    horizonPlane.visible = horizonVisible;
    if (gulfLabel) gulfLabel.visible = horizonVisible;
    if (gulfLabel2) gulfLabel2.visible = horizonVisible;
    if (starfield) starfield.visible = starfieldVisible;
});
    document.getElementById('earth-radius').addEventListener('input', (e) => {
    DISK_RADIUS = parseInt(e.target.value);
    document.getElementById('earth-radius-value').textContent = DISK_RADIUS + ' mi';
    if (DISK_THICKNESS > DISK_RADIUS) { DISK_THICKNESS = DISK_RADIUS; document.getElementById('strata-thickness').value = DISK_THICKNESS; document.getElementById('strata-thickness-value').textContent = DISK_THICKNESS + ' mi'; }
    createGeometry();
    createStrataGrid();
    createStrataGridLabels();
    createStrataHoverMesh();
    shellWireframe.visible = shellVisible;
    horizonPlane.visible = horizonVisible;
    if (gulfLabel) gulfLabel.visible = horizonVisible;
    if (gulfLabel2) gulfLabel2.visible = horizonVisible;
});

document.getElementById('strata-thickness').addEventListener('input', (e) => { 
    DISK_THICKNESS = parseInt(e.target.value); 
    document.getElementById('strata-thickness-value').textContent = DISK_THICKNESS + ' mi'; 
    createGeometry(); 
    createStrataGrid(); 
    createStrataGridLabels(); 
    createStrataHoverMesh();
    // Restore visibility states
    shellWireframe.visible = shellVisible;
    horizonPlane.visible = horizonVisible;
    if (gulfLabel) gulfLabel.visible = horizonVisible;
    if (gulfLabel2) gulfLabel2.visible = horizonVisible;
});
    document.getElementById('starfield-radius').addEventListener('input', (e) => {
    STARFIELD_RADIUS = parseInt(e.target.value);
    document.getElementById('starfield-radius-value').textContent = STARFIELD_RADIUS + ' mi';
    createStarfield();
    if (starfield) starfield.visible = starfieldVisible;
});
        document.getElementById('starfield-speed').addEventListener('input', (e) => { STARFIELD_SPEED = parseFloat(e.target.value); document.getElementById('starfield-speed-value').textContent = STARFIELD_SPEED.toFixed(1) + 'x'; });
        document.getElementById('star-brightness').addEventListener('input', (e) => { STAR_BRIGHTNESS = parseFloat(e.target.value); document.getElementById('star-brightness-value').textContent = STAR_BRIGHTNESS.toFixed(2); if (starfieldMaterial) starfieldMaterial.uniforms.uBrightness.value = STAR_BRIGHTNESS; });
        document.getElementById('twinkle-intensity').addEventListener('input', (e) => { TWINKLE_INTENSITY = parseFloat(e.target.value); document.getElementById('twinkle-value').textContent = TWINKLE_INTENSITY.toFixed(1); if (starfieldMaterial) starfieldMaterial.uniforms.uTwinkleIntensity.value = TWINKLE_INTENSITY; });
        document.getElementById('glow-size').addEventListener('input', (e) => { GLOW_SIZE = parseFloat(e.target.value); document.getElementById('glow-size-value').textContent = GLOW_SIZE.toFixed(1); if (starfieldMaterial) starfieldMaterial.uniforms.uGlowSize.value = GLOW_SIZE; });
        document.getElementById('core-sharpness').addEventListener('input', (e) => { CORE_SHARPNESS = parseFloat(e.target.value); document.getElementById('core-sharpness-value').textContent = CORE_SHARPNESS.toFixed(2); if (starfieldMaterial) starfieldMaterial.uniforms.uCoreSharpness.value = CORE_SHARPNESS; });
        document.getElementById('glow-intensity').addEventListener('input', (e) => { GLOW_INTENSITY = parseFloat(e.target.value); document.getElementById('glow-intensity-value').textContent = GLOW_INTENSITY.toFixed(2); if (starfieldMaterial) starfieldMaterial.uniforms.uGlowIntensity.value = GLOW_INTENSITY; });
        document.getElementById('meteor-count').addEventListener('input', (e) => { METEOR_RATE = parseInt(e.target.value); document.getElementById('meteor-count-value').textContent = METEOR_RATE; });
       
        // Sun controls
        document.getElementById('sun-speed').addEventListener('input', (e) => { SUN_SPEED = parseFloat(e.target.value); document.getElementById('sun-speed-value').textContent = SUN_SPEED.toFixed(1) + 'x'; });
        document.getElementById('sun-height').addEventListener('input', (e) => { SUN_HEIGHT = parseInt(e.target.value); document.getElementById('sun-height-value').textContent = SUN_HEIGHT + ' mi'; });
        document.getElementById('sun-radius-min').addEventListener('input', (e) => { SUN_RADIUS_MIN = parseInt(e.target.value); document.getElementById('sun-radius-min-value').textContent = SUN_RADIUS_MIN + ' mi'; });
        document.getElementById('sun-radius-max').addEventListener('input', (e) => { SUN_RADIUS_MAX = parseInt(e.target.value); document.getElementById('sun-radius-max-value').textContent = SUN_RADIUS_MAX + ' mi'; });
    document.getElementById('sun-brightness').addEventListener('input', (e) => {
    const newBrightness = parseFloat(e.target.value);
    
    // Detect re-ignition: was off, now turning back on
    if (sunWasOff && newBrightness >= SUN_OFF_THRESHOLD) {
        sunFlickerActive = true;
        sunFlickerStartTime = Date.now();
        sunWasOff = false;
    }
    
    // Track if sun is currently "off"
    if (newBrightness < SUN_OFF_THRESHOLD) {
        sunWasOff = true;
    }
    
    SUN_BRIGHTNESS = newBrightness;
    document.getElementById('sun-brightness-value').textContent = SUN_BRIGHTNESS.toFixed(1);
});
        document.getElementById('sun-size').addEventListener('input', (e) => {
            SUN_SIZE = parseInt(e.target.value);
            document.getElementById('sun-size-value').textContent = SUN_SIZE + ' mi';
            if (sunMesh) { sunMesh.geometry.dispose(); sunMesh.geometry = new THREE.SphereGeometry(SUN_SIZE, 32, 32); }
            if (sunGlow) sunGlow.scale.set(SUN_SIZE * 10, SUN_SIZE * 10, 1);
            if (sunHalo) sunHalo.scale.set(SUN_SIZE * 18, SUN_SIZE * 18, 1);
        });
       
        // Moon controls
        document.getElementById('moon-speed').addEventListener('input', (e) => { MOON_SPEED = parseFloat(e.target.value); document.getElementById('moon-speed-value').textContent = MOON_SPEED.toFixed(2) + 'x'; });
        document.getElementById('moon-height').addEventListener('input', (e) => { MOON_HEIGHT = parseInt(e.target.value); document.getElementById('moon-height-value').textContent = MOON_HEIGHT + ' mi'; });
        document.getElementById('moon-radius-min').addEventListener('input', (e) => { MOON_RADIUS_MIN = parseInt(e.target.value); document.getElementById('moon-radius-min-value').textContent = MOON_RADIUS_MIN + ' mi'; });
        document.getElementById('moon-radius-max').addEventListener('input', (e) => { MOON_RADIUS_MAX = parseInt(e.target.value); document.getElementById('moon-radius-max-value').textContent = MOON_RADIUS_MAX + ' mi'; });
    document.getElementById('moon-brightness').addEventListener('input', (e) => {
    const newBrightness = parseFloat(e.target.value);
    
    // Detect re-ignition: was off, now turning back on
    if (moonWasOff && newBrightness >= MOON_OFF_THRESHOLD) {
        moonFlickerActive = true;
        moonFlickerStartTime = Date.now();
        moonWasOff = false;
    }
    
    // Track if moon is currently "off"
    if (newBrightness < MOON_OFF_THRESHOLD) {
        moonWasOff = true;
    }
    
    MOON_BRIGHTNESS = newBrightness;
    document.getElementById('moon-brightness-value').textContent = MOON_BRIGHTNESS.toFixed(1);
});
        document.getElementById('moon-size').addEventListener('input', (e) => {
            MOON_SIZE = parseInt(e.target.value);
            document.getElementById('moon-size-value').textContent = MOON_SIZE + ' mi';
            if (moonMesh) { moonMesh.geometry.dispose(); moonMesh.geometry = new THREE.SphereGeometry(MOON_SIZE, 32, 32); }
            if (moonGlow) moonGlow.scale.set(MOON_SIZE * 10, MOON_SIZE * 10, 1);
            if (moonHalo) moonHalo.scale.set(MOON_SIZE * 16, MOON_SIZE * 16, 1);
        });
        document.getElementById('sun-light-radius').addEventListener('input', (e) => { SUN_LIGHT_RADIUS = parseInt(e.target.value); document.getElementById('sun-light-radius-value').textContent = SUN_LIGHT_RADIUS + ' mi'; });
        document.getElementById('moon-light-radius').addEventListener('input', (e) => { MOON_LIGHT_RADIUS = parseInt(e.target.value); document.getElementById('moon-light-radius-value').textContent = MOON_LIGHT_RADIUS + ' mi'; });
       
        document.getElementById('interference-duration').addEventListener('input', (e) => { INTERFERENCE_DURATION = parseFloat(e.target.value); document.getElementById('interference-duration-value').textContent = INTERFERENCE_DURATION.toFixed(2); });
       
        // Underworld Sun controls
    document.getElementById('usun-speed').addEventListener('input', (e) => { USUN_SPEED = parseFloat(e.target.value); document.getElementById('usun-speed-value').textContent = USUN_SPEED.toFixed(1) + 'x'; });
    document.getElementById('usun-brightness').addEventListener('input', (e) => {
    const newBrightness = parseFloat(e.target.value);
    
    // Detect re-ignition: was off, now turning back on
    if (uSunWasOff && newBrightness >= USUN_OFF_THRESHOLD) {
        uSunFlickerActive = true;
        uSunFlickerStartTime = Date.now();
        uSunWasOff = false;
    }
    
    // Track if underworld sun is currently "off"
    if (newBrightness < USUN_OFF_THRESHOLD) {
        uSunWasOff = true;
    }
    
    USUN_BRIGHTNESS = newBrightness;
    document.getElementById('usun-brightness-value').textContent = USUN_BRIGHTNESS.toFixed(1);
});
document.getElementById('usun-size').addEventListener('input', (e) => { USUN_SIZE = parseInt(e.target.value); document.getElementById('usun-size-value').textContent = USUN_SIZE + ' mi'; if (underworldSunMesh) { underworldSunMesh.geometry.dispose(); underworldSunMesh.geometry = new THREE.SphereGeometry(USUN_SIZE, 32, 32); } if (underworldSunGlow) underworldSunGlow.scale.set(USUN_SIZE * 10, USUN_SIZE * 10, 1); if (underworldSunHalo) underworldSunHalo.scale.set(USUN_SIZE * 18, USUN_SIZE * 18, 1); });
document.getElementById('usun-height').addEventListener('input', (e) => { USUN_HEIGHT = parseInt(e.target.value); document.getElementById('usun-height-value').textContent = USUN_HEIGHT + ' mi'; });
document.getElementById('usun-radius-min').addEventListener('input', (e) => { USUN_RADIUS_MIN = parseInt(e.target.value); document.getElementById('usun-radius-min-value').textContent = USUN_RADIUS_MIN + ' mi'; });
document.getElementById('usun-radius-max').addEventListener('input', (e) => { USUN_RADIUS_MAX = parseInt(e.target.value); document.getElementById('usun-radius-max-value').textContent = USUN_RADIUS_MAX + ' mi'; });
document.getElementById('usun-light-radius').addEventListener('input', (e) => { USUN_LIGHT_RADIUS = parseInt(e.target.value); document.getElementById('usun-light-radius-value').textContent = USUN_LIGHT_RADIUS + ' mi'; });
// Underworld Moon controls
document.getElementById('umoon-speed').addEventListener('input', (e) => { UMOON_SPEED = parseFloat(e.target.value); document.getElementById('umoon-speed-value').textContent = UMOON_SPEED.toFixed(2) + 'x'; });
document.getElementById('umoon-brightness').addEventListener('input', (e) => {
    const newBrightness = parseFloat(e.target.value);
    
    // Detect re-ignition: was off, now turning back on
    if (uMoonWasOff && newBrightness >= UMOON_OFF_THRESHOLD) {
        uMoonFlickerActive = true;
        uMoonFlickerStartTime = Date.now();
        uMoonWasOff = false;
    }
    
    // Track if underworld moon is currently "off"
    if (newBrightness < UMOON_OFF_THRESHOLD) {
        uMoonWasOff = true;
    }
    
    UMOON_BRIGHTNESS = newBrightness;
    document.getElementById('umoon-brightness-value').textContent = UMOON_BRIGHTNESS.toFixed(1);
});;
    document.getElementById('umoon-size').addEventListener('input', (e) => { UMOON_SIZE = parseInt(e.target.value); document.getElementById('umoon-size-value').textContent = UMOON_SIZE + ' mi'; if (underworldMoonMesh) { underworldMoonMesh.geometry.dispose(); underworldMoonMesh.geometry = new THREE.SphereGeometry(UMOON_SIZE, 32, 32); } if (underworldMoonGlow) underworldMoonGlow.scale.set(UMOON_SIZE * 10, UMOON_SIZE * 10, 1); if (underworldMoonHalo) underworldMoonHalo.scale.set(UMOON_SIZE * 16, UMOON_SIZE * 16, 1); });
    document.getElementById('umoon-height').addEventListener('input', (e) => { UMOON_HEIGHT = parseInt(e.target.value); document.getElementById('umoon-height-value').textContent = UMOON_HEIGHT + ' mi'; });
    document.getElementById('umoon-radius-min').addEventListener('input', (e) => { UMOON_RADIUS_MIN = parseInt(e.target.value); document.getElementById('umoon-radius-min-value').textContent = UMOON_RADIUS_MIN + ' mi'; });
    document.getElementById('umoon-radius-max').addEventListener('input', (e) => { UMOON_RADIUS_MAX = parseInt(e.target.value); document.getElementById('umoon-radius-max-value').textContent = UMOON_RADIUS_MAX + ' mi'; });
    document.getElementById('umoon-light-radius').addEventListener('input', (e) => { UMOON_LIGHT_RADIUS = parseInt(e.target.value); document.getElementById('umoon-light-radius-value').textContent = UMOON_LIGHT_RADIUS + ' mi'; });
    document.getElementById('umoon-interference').addEventListener('input', (e) => { UMOON_INTERFERENCE_DURATION = parseFloat(e.target.value); document.getElementById('umoon-interference-value').textContent = UMOON_INTERFERENCE_DURATION.toFixed(2); });

     // Helper function to reset all view states and button appearances
    function resetAllViewStates() {
    // Reset all view flags
    isEdgeView = false;
    isMidView = false;
    isSunView = false;
    isMoonView = false;
    isUSunView = false;
    isUMoonView = false;
    isUnderworldEdgeView = false;
    isUnderworldMidView = false;
   
    // Stop edge cold effects
    stopUpperEdgeCold();
    stopUnderEdgeCold();
   
    // Remove active class from ALL view buttons
    document.getElementById('ground-view-button').classList.remove('active');
    document.getElementById('underworld-view-button').classList.remove('active');
    document.getElementById('edge-view-button').classList.remove('active');
    document.getElementById('mid-view-button').classList.remove('active');
    document.getElementById('underworld-edge-view-button').classList.remove('active');
    document.getElementById('underworld-mid-view-button').classList.remove('active');
    document.getElementById('sun-view-button').classList.remove('active');
    document.getElementById('moon-view-button').classList.remove('active');
    document.getElementById('usun-view-button').classList.remove('active');
    document.getElementById('umoon-view-button').classList.remove('active');
   
    // Reset all button text to defaults
    document.getElementById('ground-view-button').textContent = 'Upper World Ground View';
    document.getElementById('underworld-view-button').textContent = 'Underworld Ground View';
    document.getElementById('edge-view-button').textContent = 'Upper realm Edge View';
    document.getElementById('mid-view-button').textContent = 'Upper Realm Midplane View';
    document.getElementById('underworld-edge-view-button').textContent = 'Underworld Edge View';
    document.getElementById('underworld-mid-view-button').textContent = 'Underworld Midplane View';
    document.getElementById('sun-view-button').textContent = 'Upper Realm Sun View';
    document.getElementById('moon-view-button').textContent = 'Upper Realm Moon View';
    document.getElementById('usun-view-button').textContent = 'Underworld Sun View';
    document.getElementById('umoon-view-button').textContent = 'Underworld Moon View';
}

    function exitToOrbit() {
    resetAllViewStates();
    isGroundView = false;
    isUnderworldView = false;
    camera.fov = originalFOV;
    camera.updateProjectionMatrix();
    cameraTransitioning = true;
    transitionStartTime = Date.now();
}
       
        // Button handlers
        document.getElementById('ground-view-button').addEventListener('click', () => {
            const isCurrentlyGroundCenter = isGroundView && !isUnderworldView && !isEdgeView && !isMidView && !isSunView && !isMoonView && !isUSunView && !isUMoonView && !isUnderworldEdgeView && !isUnderworldMidView;
           
            if (!isGroundView) {
                savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
                resetAllViewStates();
                isUnderworldView = false;
                groundViewAngles = { pitch: 0.1, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('ground-view-button').textContent = 'Exit Upper Realm Ground View';
                document.getElementById('ground-view-button').classList.add('active');
            } else if (!isCurrentlyGroundCenter) {
                previousGroundPosition = getCurrentViewPosition();
                resetAllViewStates();
                isUnderworldView = false;
                groundViewAngles = { pitch: 0.1, yaw: 0 };
                isGroundToGroundTransition = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('ground-view-button').textContent = 'Exit Upper Ground View';
                document.getElementById('ground-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });
        document.getElementById('underworld-view-button').addEventListener('click', () => {
            const isCurrentlyUnderworldCenter = isGroundView && isUnderworldView && !isUnderworldEdgeView && !isUnderworldMidView && !isUSunView && !isUMoonView;
           
            if (!isGroundView) {
                savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
                resetAllViewStates();
                isUnderworldView = true;
                groundViewAngles = { pitch: -0.1, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('underworld-view-button').textContent = 'Exit Ground Underworld';
                document.getElementById('underworld-view-button').classList.add('active');
            } else if (!isCurrentlyUnderworldCenter) {
                previousGroundPosition = getCurrentViewPosition();
                resetAllViewStates();
                isUnderworldView = true;
                groundViewAngles = { pitch: -0.1, yaw: 0 };
                isGroundToGroundTransition = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('underworld-view-button').textContent = 'Exit Underworld Ground View';
                document.getElementById('underworld-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });
       
    document.getElementById('edge-view-button').addEventListener('click', () => {
            const isCurrentlyEdge = isGroundView && isEdgeView && !isUnderworldView;
           
            if (!isGroundView) {
                savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
                resetAllViewStates();
                isUnderworldView = false;
                isEdgeView = true;
                groundViewAngles = { pitch: 0, yaw: Math.PI };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                startUpperEdgeCold();
                document.getElementById('edge-view-button').textContent = 'Exit Upper Plane Edge View';
                document.getElementById('edge-view-button').classList.add('active');
            } else if (!isCurrentlyEdge) {
                previousGroundPosition = getCurrentViewPosition();
                resetAllViewStates();
                isUnderworldView = false;
                isEdgeView = true;
                groundViewAngles = { pitch: 0, yaw: Math.PI };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                isGroundToGroundTransition = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                startUpperEdgeCold();
                document.getElementById('edge-view-button').textContent = 'Exit Upper Plane Edge View';
                document.getElementById('edge-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });

       
document.getElementById('mid-view-button').addEventListener('click', () => {
    const isCurrentlyMid = isGroundView && isMidView && !isUnderworldView;
   
    if (!isGroundView) {
        savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
        resetAllViewStates();
        upperMidPosition = { x: DISK_RADIUS * 0.5, z: 0 };
        isMidView = true;
                groundViewAngles = { pitch: 0.1, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('mid-view-button').textContent = 'Exit Upper Realm Mid Plane View';
                document.getElementById('mid-view-button').classList.add('active');
            } else if (!isCurrentlyMid) {
                previousGroundPosition = getCurrentViewPosition();
                resetAllViewStates();
                isUnderworldView = false;
                isMidView = true;
                groundViewAngles = { pitch: 0.1, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                isGroundToGroundTransition = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('mid-view-button').textContent = 'Exit Upper Mid Plane View';
                document.getElementById('mid-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });
        document.getElementById('underworld-edge-view-button').addEventListener('click', () => {
            const isCurrentlyUnderworldEdge = isGroundView && isUnderworldEdgeView;
           
            if (!isGroundView) {
                savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
                resetAllViewStates();
                isUnderworldView = true;
                isUnderworldEdgeView = true;
                groundViewAngles = { pitch: -0.1, yaw: Math.PI };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                startUnderEdgeCold();
                document.getElementById('underworld-edge-view-button').textContent = 'Exit Underworld Edge';
                document.getElementById('underworld-edge-view-button').classList.add('active');
            } else if (!isCurrentlyUnderworldEdge) {
                previousGroundPosition = getCurrentViewPosition();
                resetAllViewStates();
                isUnderworldView = true;
                isUnderworldEdgeView = true;
                groundViewAngles = { pitch: -0.1, yaw: Math.PI };
                isGroundToGroundTransition = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                startUnderEdgeCold();
                document.getElementById('underworld-edge-view-button').textContent = 'Exit Underworld Edge';
                document.getElementById('underworld-edge-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });
document.getElementById('underworld-mid-view-button').addEventListener('click', () => {
    const isCurrentlyUnderworldMid = isGroundView && isUnderworldMidView;
   
    if (!isGroundView) {
        savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
        resetAllViewStates();
        lowerMidPosition = { x: DISK_RADIUS * 0.5, z: 0 };
        isUnderworldView = true;
        isUnderworldMidView = true;
                groundViewAngles = { pitch: -0.1, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('underworld-mid-view-button').textContent = 'Exit Underworld Mid Plane view';
                document.getElementById('underworld-mid-view-button').classList.add('active');
            } else if (!isCurrentlyUnderworldMid) {
                previousGroundPosition = getCurrentViewPosition();
                resetAllViewStates();
                isUnderworldView = true;
                isUnderworldMidView = true;
                groundViewAngles = { pitch: -0.1, yaw: 0 };
                isGroundToGroundTransition = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('underworld-mid-view-button').textContent = 'Exit Underworld Mid';
                document.getElementById('underworld-mid-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });
        document.getElementById('sun-view-button').addEventListener('click', () => {
            if (!isSunView) {
                if (!isGroundView) {
                    savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
                } else {
                    previousGroundPosition = getCurrentViewPosition();
                    isGroundToGroundTransition = true;
                }
    resetAllViewStates();
                isUnderworldView = false;
                isSunView = true;
                luminaryViewAngles = { pitch: 0, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('sun-view-button').textContent = 'Exit Upper Sun View';
                document.getElementById('sun-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });
        document.getElementById('usun-view-button').addEventListener('click', () => {
            if (!isUSunView) {
                if (!isGroundView) {
                    savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
                } else {
                    previousGroundPosition = getCurrentViewPosition();
                    isGroundToGroundTransition = true;
                }
                resetAllViewStates();
                isUnderworldView = true;
                isUSunView = true;
                underworldLuminaryViewAngles = { pitch: 0, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('usun-view-button').textContent = 'Exit Underworld Sun View';
                document.getElementById('usun-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });
        document.getElementById('umoon-view-button').addEventListener('click', () => {
            if (!isUMoonView) {
                if (!isGroundView) {
                    savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
                } else {
                    previousGroundPosition = getCurrentViewPosition();
                    isGroundToGroundTransition = true;
                }
                resetAllViewStates();
                isUnderworldView = true;
                isUMoonView = true;
                underworldLuminaryViewAngles = { pitch: 0, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('umoon-view-button').textContent = 'Exit Underworld Moon View';
                document.getElementById('umoon-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });

        document.getElementById('moon-view-button').addEventListener('click', () => {
            if (!isMoonView) {
                if (!isGroundView) {
                    savedOrbitView = { position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }, rotation: { x: cameraRotation.x, y: cameraRotation.y }, distance: cameraDistance, target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z } };
                } else {
                    previousGroundPosition = getCurrentViewPosition();
                    isGroundToGroundTransition = true;
                }
    resetAllViewStates();
                isUnderworldView = false;
                isMoonView = true;
                luminaryViewAngles = { pitch: 0, yaw: 0 };
                luminaryViewAngles = { pitch: 0, yaw: 0 };
                camera.fov = groundViewFOV;
                camera.updateProjectionMatrix();
                isGroundView = true;
                cameraTransitioning = true;
                transitionStartTime = Date.now();
                document.getElementById('moon-view-button').textContent = 'Exit Upper Realm Moon View';
                document.getElementById('moon-view-button').classList.add('active');
            } else {
                exitToOrbit();
            }
        });
       
        document.getElementById('toggle-shell-button').addEventListener('click', () => { shellVisible = !shellVisible; shellWireframe.visible = shellVisible; document.getElementById('toggle-shell-button').textContent = shellVisible ? 'Hide Shell' : 'Show Shell'; });
        document.getElementById('toggle-sun-button').addEventListener('click', () => {
            sunVisible = !sunVisible;
            document.getElementById('toggle-sun-button').textContent = sunVisible ? 'Hide Upper World Sun' : 'Show Upper Realm Sun';
        });
        document.getElementById('toggle-moon-button').addEventListener('click', () => {
            moonVisible = !moonVisible;
            document.getElementById('toggle-moon-button').textContent = moonVisible ? 'Hide Upper Realm Moon' : 'Show Upper Realm Moon';
        });
        document.getElementById('toggle-underworld-sun-button').addEventListener('click', () => {
            underworldSunVisible = !underworldSunVisible;
            document.getElementById('toggle-underworld-sun-button').textContent = underworldSunVisible ? 'Hide Underworld Sun' : 'Show Underworld Sun';
        });
        document.getElementById('toggle-underworld-moon-button').addEventListener('click', () => {
            underworldMoonVisible = !underworldMoonVisible;
            document.getElementById('toggle-underworld-moon-button').textContent = underworldMoonVisible ? 'Hide Underworld Moon' : 'Show Underworld Moon';
        });
        document.getElementById('toggle-luminary-link-button').addEventListener('click', () => {
    luminaryLinkVisible = !luminaryLinkVisible;
    document.getElementById('toggle-luminary-link-button').textContent = luminaryLinkVisible ? 'Upper Luminary Distance ON' : 'Upper Realm Luminary Distance';
    document.getElementById('toggle-luminary-link-button').classList.toggle('active', luminaryLinkVisible);
});
    document.getElementById('toggle-underworld-link-button').addEventListener('click', () => {
    underworldLuminaryLinkVisible = !underworldLuminaryLinkVisible;
    document.getElementById('toggle-underworld-link-button').textContent = underworldLuminaryLinkVisible ? 'Underworld Luminary Distance ON' : 'Underworld Luminary Distance';
    document.getElementById('toggle-underworld-link-button').classList.toggle('active', underworldLuminaryLinkVisible);
});
        document.getElementById('toggle-interference-button').addEventListener('click', () => {
            moonInterferenceEnabled = !moonInterferenceEnabled;
            document.getElementById('toggle-interference-button').textContent = moonInterferenceEnabled ? 'Upper Moon Phases ON' : 'Upper Moon Phase OFF';
            document.getElementById('toggle-interference-button').classList.toggle('active', moonInterferenceEnabled);
        });
        document.getElementById('toggle-umoon-interference-button').addEventListener('click', () => {
    underworldMoonInterferenceEnabled = !underworldMoonInterferenceEnabled;
    document.getElementById('toggle-umoon-interference-button').textContent = underworldMoonInterferenceEnabled ? 'Underworld Moon Phases ON' : 'Underworld Moon Phases OFF';
    document.getElementById('toggle-umoon-interference-button').classList.toggle('active', underworldMoonInterferenceEnabled);
});
    document.getElementById('toggle-shell-grid-button').addEventListener('click', () => {
    shellGridVisible = !shellGridVisible;
    updateShellGridVisibility();
    document.getElementById('toggle-shell-grid-button').textContent = shellGridVisible ? 'Kayleigh Coordinates ON' : 'Kayleigh Coordinate System';
    document.getElementById('toggle-shell-grid-button').classList.toggle('active', shellGridVisible);
    if (!shellGridVisible) {
        document.getElementById('grid-tooltip').style.display = 'none';
    }
});

    document.getElementById('toggle-strata-grid-button').addEventListener('click', () => {
    strataGridVisible = !strataGridVisible;
    updateStrataGridVisibility();
    document.getElementById('toggle-strata-grid-button').textContent = strataGridVisible ? 'Strata Coordinates ON' : 'Strata Coordinates';
    document.getElementById('toggle-strata-grid-button').classList.toggle('active', strataGridVisible);
});
        document.getElementById('toggle-realistic-lighting-button').addEventListener('click', () => {
            realisticLighting = !realisticLighting;
            document.getElementById('toggle-realistic-lighting-button').textContent = realisticLighting ? 'Realistic ON' : 'Realistic Lighting';
            document.getElementById('toggle-realistic-lighting-button').classList.toggle('active', realisticLighting);
        });
        document.getElementById('toggle-strata-wire-button').addEventListener('click', () => {
            strataWireframe = !strataWireframe;
            diskMaterial.wireframe = strataWireframe;
            diskFill.visible = strataWireframe;
            document.getElementById('toggle-strata-wire-button').textContent = strataWireframe ? 'Strata Solid' : 'Strata Wireframe';
            document.getElementById('toggle-strata-wire-button').classList.toggle('active', strataWireframe);
        });
        document.getElementById('toggle-lens-flare-button').addEventListener('click', () => {
    lensFlareEnabled = !lensFlareEnabled;
    document.getElementById('toggle-lens-flare-button').textContent = lensFlareEnabled ? 'Lens Flare ON' : 'Lens Flare';
    document.getElementById('toggle-lens-flare-button').classList.toggle('active', lensFlareEnabled);
    if (!lensFlareEnabled && lensFlareCtx) {
        lensFlareCtx.clearRect(0, 0, lensFlareCanvas.width, lensFlareCanvas.height);
    }
});
        document.getElementById('reset-axis-button').addEventListener('click', () => { starAxisPivot.rotation.set(0, 0, 0); axisVelocity = { x: 0, y: 0 }; updateInfoPanel(); });
        document.getElementById('toggle-axes-button').addEventListener('click', () => {
            axesVisible = !axesVisible;
            axisLine.visible = axesVisible;
            starAxisLine.visible = axesVisible;
            starAxisHandles.forEach(h => h.visible = axesVisible);
            document.getElementById('toggle-axes-button').textContent = axesVisible ? 'Hide Axes' : 'Show Axes';
        });
        document.getElementById('toggle-resonance-button').addEventListener('click', () => { shellResonating = !shellResonating; document.getElementById('toggle-resonance-button').textContent = shellResonating ? 'Stop Resonance' : 'Shell Resonance'; });
    document.getElementById('toggle-starfield-button').addEventListener('click', () => {
    starfieldVisible = !starfieldVisible;
    if (starfield) starfield.visible = starfieldVisible;
    document.getElementById('toggle-starfield-button').textContent = starfieldVisible ? 'Hide Starfield' : 'Show Starfield';
});
        document.getElementById('toggle-horizon-button').addEventListener('click', () => { horizonVisible = !horizonVisible; horizonPlane.visible = horizonVisible; gulfLabel.visible = horizonVisible; gulfLabel2.visible = horizonVisible; document.getElementById('toggle-horizon-button').textContent = horizonVisible ? 'Hide Gulf' : 'Show Gulf'; });
        document.getElementById('toggle-ripple-button').addEventListener('click', () => { gulfRippling = !gulfRippling; document.getElementById('toggle-ripple-button').textContent = gulfRippling ? 'Stop Ripple' : 'Gulf Ripple'; document.getElementById('toggle-ripple-button').classList.toggle('active', gulfRippling); });
        document.getElementById('random-lightning-button').addEventListener('click', () => {
    randomLightningMode = !randomLightningMode;
    document.getElementById('random-lightning-button').textContent = randomLightningMode ? 'Lightning ON' : 'Random Lightning';
    document.getElementById('random-lightning-button').classList.toggle('active', randomLightningMode);
});
        document.getElementById('shooting-stars-button').addEventListener('click', () => {
            shootingStarsMode = !shootingStarsMode;
            lastShootingStarTime = Date.now();
            document.getElementById('shooting-stars-button').textContent = shootingStarsMode ? 'Stars ON' : 'Shooting Stars';
            document.getElementById('shooting-stars-button').classList.toggle('active', shootingStarsMode);
        });
        document.getElementById('meteor-mode-button').addEventListener('click', () => {
            meteorMode = !meteorMode;
            document.getElementById('meteor-mode-button').textContent = meteorMode ? 'Leonid Shower ON' : 'Leonid shower Mode';
            document.getElementById('meteor-mode-button').classList.toggle('active', meteorMode);
            document.getElementById('meteor-indicator').classList.toggle('visible', meteorMode);
            renderer.domElement.style.cursor = meteorMode ? 'crosshair' : 'auto';
        });
        document.getElementById('stop-meteors-button').addEventListener('click', stopAllMeteors);
        document.getElementById('reset-button').addEventListener('click', () => {
            SHELL_RADIUS = 4039; DISK_RADIUS = 3959; DISK_THICKNESS = 1980; STARFIELD_RADIUS = 3977; STARFIELD_SPEED = 1.0; STAR_BRIGHTNESS = 1.0; TWINKLE_INTENSITY = 0.5; METEOR_RATE = 80;
            GLOW_SIZE = 1.8; CORE_SHARPNESS = 0.6; GLOW_INTENSITY = 0.15;
            SUN_SPEED = 1.0; SUN_HEIGHT = 1243; SUN_RADIUS_MIN = 621; SUN_RADIUS_MAX = 3107; SUN_BRIGHTNESS = 1.5; SUN_SIZE = 124; SUN_LIGHT_RADIUS = 8000;
            MOON_SPEED = 0.97; MOON_HEIGHT = 1118; MOON_RADIUS_MIN = 621; MOON_RADIUS_MAX = 3107; MOON_BRIGHTNESS = 0.8; MOON_SIZE = 112; MOON_LIGHT_RADIUS = 6000;
            document.getElementById('shell-radius').value = SHELL_RADIUS; document.getElementById('shell-radius-value').textContent = SHELL_RADIUS + ' mi';
            document.getElementById('earth-radius').value = DISK_RADIUS; document.getElementById('earth-radius-value').textContent = DISK_RADIUS + ' mi';
            document.getElementById('strata-thickness').value = DISK_THICKNESS; document.getElementById('strata-thickness-value').textContent = DISK_THICKNESS + ' mi';
            document.getElementById('starfield-radius').value = STARFIELD_RADIUS; document.getElementById('starfield-radius-value').textContent = STARFIELD_RADIUS + ' mi';
            document.getElementById('starfield-speed').value = STARFIELD_SPEED; document.getElementById('starfield-speed-value').textContent = '1.0x';
            document.getElementById('star-brightness').value = STAR_BRIGHTNESS; document.getElementById('star-brightness-value').textContent = '1.00';
            document.getElementById('twinkle-intensity').value = TWINKLE_INTENSITY; document.getElementById('twinkle-value').textContent = '0.5';
            document.getElementById('glow-size').value = GLOW_SIZE; document.getElementById('glow-size-value').textContent = '1.8';
            document.getElementById('core-sharpness').value = CORE_SHARPNESS; document.getElementById('core-sharpness-value').textContent = '0.60';
            document.getElementById('glow-intensity').value = GLOW_INTENSITY; document.getElementById('glow-intensity-value').textContent = '0.15';
            document.getElementById('meteor-count').value = METEOR_RATE; document.getElementById('meteor-count-value').textContent = '80';
            document.getElementById('sun-speed').value = SUN_SPEED; document.getElementById('sun-speed-value').textContent = '1.0x';
            document.getElementById('sun-size').value = SUN_SIZE; document.getElementById('sun-size-value').textContent = SUN_SIZE + ' mi';
            document.getElementById('sun-height').value = SUN_HEIGHT; document.getElementById('sun-height-value').textContent = SUN_HEIGHT + ' mi';
            document.getElementById('sun-radius-min').value = SUN_RADIUS_MIN; document.getElementById('sun-radius-min-value').textContent = SUN_RADIUS_MIN + ' mi';
            document.getElementById('sun-radius-max').value = SUN_RADIUS_MAX; document.getElementById('sun-radius-max-value').textContent = SUN_RADIUS_MAX + ' mi';
            document.getElementById('sun-brightness').value = SUN_BRIGHTNESS; document.getElementById('sun-brightness-value').textContent = '1.5';
            document.getElementById('moon-speed').value = MOON_SPEED; document.getElementById('moon-speed-value').textContent = '0.97x';
            document.getElementById('moon-size').value = MOON_SIZE; document.getElementById('moon-size-value').textContent = MOON_SIZE + ' mi';
            document.getElementById('moon-height').value = MOON_HEIGHT; document.getElementById('moon-height-value').textContent = MOON_HEIGHT + ' mi';
            document.getElementById('moon-radius-min').value = MOON_RADIUS_MIN; document.getElementById('moon-radius-min-value').textContent = MOON_RADIUS_MIN + ' mi';
            document.getElementById('moon-radius-max').value = MOON_RADIUS_MAX; document.getElementById('moon-radius-max-value').textContent = MOON_RADIUS_MAX + ' mi';
            document.getElementById('moon-brightness').value = MOON_BRIGHTNESS; document.getElementById('moon-brightness-value').textContent = '0.8';
            document.getElementById('sun-light-radius').value = SUN_LIGHT_RADIUS; document.getElementById('sun-light-radius-value').textContent = SUN_LIGHT_RADIUS + ' mi';
            document.getElementById('moon-light-radius').value = MOON_LIGHT_RADIUS; document.getElementById('moon-light-radius-value').textContent = MOON_LIGHT_RADIUS + ' mi';
            if (starfieldMaterial) { starfieldMaterial.uniforms.uBrightness.value = 1.0; starfieldMaterial.uniforms.uTwinkleIntensity.value = 0.5; starfieldMaterial.uniforms.uGlowSize.value = 1.8; starfieldMaterial.uniforms.uCoreSharpness.value = 0.6; starfieldMaterial.uniforms.uGlowIntensity.value = 0.15; }
            if (sunLight) sunLight.intensity = SUN_BRIGHTNESS;
            if (moonLight) moonLight.intensity = MOON_BRIGHTNESS * 2;
            if (sunMesh) { sunMesh.geometry.dispose(); sunMesh.geometry = new THREE.SphereGeometry(SUN_SIZE, 32, 32); }
            if (sunGlow) sunGlow.scale.set(SUN_SIZE * 10, SUN_SIZE * 10, 1);
            if (sunHalo) sunHalo.scale.set(SUN_SIZE * 18, SUN_SIZE * 18, 1);
            if (moonMesh) { moonMesh.geometry.dispose(); moonMesh.geometry = new THREE.SphereGeometry(MOON_SIZE, 32, 32); }
            if (moonGlow) moonGlow.scale.set(MOON_SIZE * 10, MOON_SIZE * 10, 1);
            if (moonHalo) moonHalo.scale.set(MOON_SIZE * 16, MOON_SIZE * 16, 1);
            starAxisPivot.rotation.set(0, 0, 0); axisVelocity = { x: 0, y: 0 };
            shellResonating = false; document.getElementById('toggle-resonance-button').textContent = 'Shell Resonance';
            strataWireframe = false; diskMaterial.wireframe = false; diskFill.visible = false; document.getElementById('toggle-strata-wire-button').textContent = 'Strata Wireframe'; document.getElementById('toggle-strata-wire-button').classList.remove('active');
            meteorMode = false; document.getElementById('meteor-mode-button').textContent = 'Meteor Mode'; document.getElementById('meteor-mode-button').classList.remove('active'); document.getElementById('meteor-indicator').classList.remove('visible');
            shootingStarsMode = false; document.getElementById('shooting-stars-button').textContent = 'Shooting Stars'; document.getElementById('shooting-stars-button').classList.remove('active');
            realisticLighting = false; document.getElementById('toggle-realistic-lighting-button').textContent = 'Realistic Lighting'; document.getElementById('toggle-realistic-lighting-button').classList.remove('active');
            stopAllMeteors();
            createGeometry(); createStarfield(); createSunAndMoon();
        });
        
        function updateMidplaneMovement() {
    if (!isGroundView || (!isMidView && !isUnderworldMidView)) return;
    if (cameraTransitioning) return;
    
    const speed = keysPressed.shift ? MOVE_SPEED * 3 : MOVE_SPEED;
    const pos = isUnderworldMidView ? lowerMidPosition : upperMidPosition;
    
    // Calculate forward and right vectors based on yaw
    const forwardX = Math.sin(groundViewAngles.yaw);
    const forwardZ = Math.cos(groundViewAngles.yaw);
const rightX = -Math.cos(groundViewAngles.yaw);
const rightZ = Math.sin(groundViewAngles.yaw);
    
    // Apply movement
    if (keysPressed.w) {
        pos.x += forwardX * speed;
        pos.z += forwardZ * speed;
    }
    if (keysPressed.s) {
        pos.x -= forwardX * speed;
        pos.z -= forwardZ * speed;
    }
    if (keysPressed.a) {
        pos.x -= rightX * speed;
        pos.z -= rightZ * speed;
    }
    if (keysPressed.d) {
        pos.x += rightX * speed;
        pos.z += rightZ * speed;
    }
    
    // Clamp to disk radius (can't walk off the edge)
    const distFromCenter = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
    if (distFromCenter > DISK_RADIUS - 100) {
        const scale = (DISK_RADIUS - 100) / distFromCenter;
        pos.x *= scale;
        pos.z *= scale;
    }
}
       
        let clickStartPos = { x: 0, y: 0 }, clickMoved = false;
        
        // Keyboard controls for midplane movement
document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (key === 'w') keysPressed.w = true;
    if (key === 'a') keysPressed.a = true;
    if (key === 's') keysPressed.s = true;
    if (key === 'd') keysPressed.d = true;
    if (key === 'shift' || e.shiftKey) keysPressed.shift = true;
});

document.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    if (key === 'w') keysPressed.w = false;
    if (key === 'a') keysPressed.a = false;
    if (key === 's') keysPressed.s = false;
    if (key === 'd') keysPressed.d = false;
    if (key === 'shift' || e.key === 'Shift') keysPressed.shift = false;
});
       
        renderer.domElement.addEventListener('mousedown', (e) => {
            clickStartPos = { x: e.clientX, y: e.clientY };
            clickMoved = false;
            if (e.button === 0) {
                if (!meteorMode && !isGroundView && checkAxisHover(e)) {
                    isDraggingAxis = true; axisDragStart.set(e.clientX, e.clientY); axisRotationStart.copy(starAxisPivot.rotation);
                    lastDragPosition = { x: e.clientX, y: e.clientY }; lastDragTime = Date.now(); axisVelocity = { x: 0, y: 0 };
                    document.getElementById('axis-drag-indicator').classList.add('visible');
                } else if (!meteorMode) { isDragging = true; }
            }
            if (e.button === 2) isPanning = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
       
    renderer.domElement.addEventListener('mousemove', (e) => {
    const dx = e.clientX - clickStartPos.x, dy = e.clientY - clickStartPos.y;
    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) clickMoved = true;
   
    if (meteorMode) renderer.domElement.style.cursor = 'crosshair';
    else if (!isGroundView) {
        const isOverAxis = checkAxisHover(e);
        if (isOverAxis !== axisHovered) {
            axisHovered = isOverAxis;
            renderer.domElement.style.cursor = axisHovered ? 'grab' : 'auto';
            starAxisHandles.forEach(h => { h.material.opacity = axisHovered ? 1.0 : 0.7; h.material.color.setHex(axisHovered ? 0xffeb3b : 0xffd54f); });
        }
    }
   
    if (isDraggingAxis) {
        renderer.domElement.style.cursor = 'grabbing';
        const deltaX = e.clientX - axisDragStart.x, deltaY = e.clientY - axisDragStart.y;
        const now = Date.now(), timeDelta = now - lastDragTime;
        if (timeDelta > 0) {
            axisVelocity.x = axisVelocity.x * 0.5 + (e.clientX - lastDragPosition.x) / timeDelta * 0.5;
            axisVelocity.y = axisVelocity.y * 0.5 + (e.clientY - lastDragPosition.y) / timeDelta * 0.5;
        }
        lastDragPosition = { x: e.clientX, y: e.clientY }; lastDragTime = now;
        const cameraRight = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
        const rotY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
        const rotX = new THREE.Quaternion().setFromAxisAngle(cameraRight.normalize(), deltaY * 0.005);
        starAxisPivot.rotation.setFromQuaternion(rotY.multiply(rotX).multiply(new THREE.Quaternion().setFromEuler(axisRotationStart)));
        updateInfoPanel();
    }
    if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x, deltaY = e.clientY - previousMousePosition.y;
        if (isGroundView) {
    if (isSunView || isMoonView) {
    luminaryViewAngles.yaw += deltaX * 0.005;
    luminaryViewAngles.pitch += deltaY * 0.005;
    luminaryViewAngles.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, luminaryViewAngles.pitch));
    } else if (isUSunView || isUMoonView) {
    underworldLuminaryViewAngles.yaw += deltaX * 0.005;
    underworldLuminaryViewAngles.pitch += deltaY * 0.005;
    underworldLuminaryViewAngles.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, underworldLuminaryViewAngles.pitch));
    } else {
    groundViewAngles.yaw += deltaX * 0.005;
    groundViewAngles.pitch += deltaY * 0.005;
    groundViewAngles.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, groundViewAngles.pitch));
}
        }
        else { cameraRotation.y -= deltaX * 0.005; cameraRotation.x += deltaY * 0.005; cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x)); }
    }
    if (isPanning && !isGroundView) { cameraTarget.x -= (e.clientX - previousMousePosition.x) * cameraDistance * 0.0008; cameraTarget.y += (e.clientY - previousMousePosition.y) * cameraDistance * 0.0008; }
    previousMousePosition = { x: e.clientX, y: e.clientY };
   
    // Grid coordinate tooltip
    updateGridTooltip(e);
    updateStrataTooltip(e);
});
        renderer.domElement.addEventListener('mouseup', (e) => {
            if (meteorMode && e.button === 0 && !clickMoved) {
                const hitPoint = checkMeteorClick(e);
                if (hitPoint) toggleMeteorSource(hitPoint);
            }
            isDragging = false; isPanning = false; isDraggingAxis = false;
            document.getElementById('axis-drag-indicator').classList.remove('visible');
            renderer.domElement.style.cursor = meteorMode ? 'crosshair' : (axisHovered ? 'grab' : 'auto');
        });
       
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        renderer.domElement.addEventListener('wheel', (e) => { if (!isGroundView) { e.preventDefault(); cameraDistance = Math.max(5000, Math.min(200000, cameraDistance + e.deltaY * 15)); } });
       
        let startTime = Date.now();
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = (Date.now() - startTime) * 0.001;
            if (!window.fpsFrames) { window.fpsFrames = 0; window.fpsTime = Date.now(); } window.fpsFrames++; if (Date.now() - window.fpsTime >= 1000) { document.getElementById('fps-counter').textContent = window.fpsFrames + ' FPS'; window.fpsFrames = 0; window.fpsTime = Date.now(); }
            if (starfieldMaterial) starfieldMaterial.uniforms.uTime.value = elapsedTime;
updateMeteorSystem();
updateGulfRipple(elapsedTime);
updateSunAndMoon(elapsedTime);
updateMidplaneMovement();
            if (cameraTransitioning) {
                const progress = Math.min((Date.now() - transitionStartTime) / transitionDuration, 1.0);
                const eased = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
               
                if (isGroundToGroundTransition && isGroundView) {
                    const target = getCurrentViewPosition();
                    camera.position.lerpVectors(previousGroundPosition.position, target.position, eased);
                    camera.up.set(0, isUnderworldView ? -1 : 1, 0);
                    camera.lookAt(getCurrentLookTarget());
                } else if (isGroundView) {
                    const groundView = getCurrentViewPosition();
                    camera.position.set(
                        savedOrbitView.position.x + (groundView.position.x - savedOrbitView.position.x) * eased,
                        savedOrbitView.position.y + (groundView.position.y - savedOrbitView.position.y) * eased,
                        savedOrbitView.position.z + (groundView.position.z - savedOrbitView.position.z) * eased
                    );
                    camera.lookAt(getCurrentLookTarget());
                } else {
                    const groundView = getCurrentViewPosition();
                    camera.position.set(
                        groundView.position.x + (savedOrbitView.position.x - groundView.position.x) * eased,
                        groundView.position.y + (savedOrbitView.position.y - groundView.position.y) * eased,
                        groundView.position.z + (savedOrbitView.position.z - groundView.position.z) * eased
                    );
                    cameraRotation.x = groundView.rotation.x + (savedOrbitView.rotation.x - groundView.rotation.x) * eased;
                    cameraRotation.y = groundView.rotation.y + (savedOrbitView.rotation.y - groundView.rotation.y) * eased;
                    cameraDistance += (savedOrbitView.distance - cameraDistance) * eased * 0.1;
                    camera.lookAt(cameraTarget);
                }
                if (progress >= 1.0) { cameraTransitioning = false; isGroundToGroundTransition = false; }
            } else if (!isGroundView) {
                camera.up.set(0, 1, 0);
                camera.position.set(
                    cameraTarget.x + cameraDistance * Math.cos(cameraRotation.x) * Math.sin(cameraRotation.y),
                    cameraTarget.y + cameraDistance * Math.sin(cameraRotation.x),
                    cameraTarget.z + cameraDistance * Math.cos(cameraRotation.x) * Math.cos(cameraRotation.y)
                );
                camera.lookAt(cameraTarget);
            } else {
                const viewPos = getCurrentViewPosition();
                const lookTarget = getCurrentLookTarget();
                camera.position.copy(viewPos.position);
    camera.up.set(0, (isUnderworldView || isUSunView || isUMoonView) ? -1 : 1, 0);
                camera.lookAt(lookTarget);
            }
           
            if (!isDraggingAxis && (Math.abs(axisVelocity.x) > minVelocityThreshold || Math.abs(axisVelocity.y) > minVelocityThreshold)) {
                const cameraRight = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
                starAxisPivot.quaternion.premultiply(
                    new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), axisVelocity.x * 0.15)
                    .multiply(new THREE.Quaternion().setFromAxisAngle(cameraRight.normalize(), axisVelocity.y * 0.15))
                );
                axisVelocity.x *= momentumDecay; axisVelocity.y *= momentumDecay;
                updateInfoPanel();
            }
           
            if (shellResonating && shellWireframe && shellWireframe.visible) {
                const time = (Date.now() - startTime) * 0.001;
                const pulse = (Math.sin(time * 900) + 2) * 0.5;
                shellWireframe.position.set(Math.sin(time * 990) * 2, Math.sin(time * 810) * 2, Math.sin(time * 945) * 2);
                shellWireframe.material.opacity = 0.15 + pulse * 0.70;
                shellWireframe.material.color.copy(new THREE.Color(0x1565c0)).lerp(new THREE.Color(0xe1f5fe), pulse);
            } else if (shellWireframe) {
                shellWireframe.material.opacity = 0.4;
                shellWireframe.material.color.setHex(0x64b5f6);
                shellWireframe.position.set(0, 0, 0);
            }
           
    if (starfield && !isDraggingAxis) {
                const rotationAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(starAxisPivot.quaternion);
                starAxisPivot.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(rotationAxis.normalize(), 0.0003 * STARFIELD_SPEED));
            }
           
            // Gulf label scaling
            if (gulfLabel && gulfLabel.visible) {
                const camDist = camera.position.distanceTo(gulfLabel.position);
    const scaleFactor = Math.min(4000, Math.max(200, camDist * 0.1));
                gulfLabel.scale.set(scaleFactor, scaleFactor * 0.375, 1);
            }
            if (gulfLabel2 && gulfLabel2.visible) {
                const camDist = camera.position.distanceTo(gulfLabel2.position);
    const scaleFactor = Math.min(4000, Math.max(200, camDist * 0.1));
                gulfLabel2.scale.set(scaleFactor, scaleFactor * 0.375, 1);
            }
            // Update Fimbulwinter systems (dying sun/moon cold)
            updateUpperFimbulwinter();
            updateLowerFimbulwinter();
           
    // Fade stars and nebulae during Fimbulwinter - INDEPENDENT HEMISPHERES
    if (starfieldMaterial) {
    starfieldMaterial.uniforms.uUpperFimbul.value = displayedUpperFrost;
    starfieldMaterial.uniforms.uLowerFimbul.value = displayedLowerFrost;}
            updateFimbulwinterFrost();
            updateFrostShell(elapsedTime);
            // Update edge cold systems
            updateUpperEdgeCold();
            updateUnderEdgeCold();
            updateLensFlare();
// Random lightning mode - unpredictable strikes
if (randomLightningMode && Math.random() < 0.0004) {
    // Random color selection
    const colors = ['sun', 'moon', 'usun', 'umoon'];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    
    // Pick a random luminary to strike from
    const luminaries = [];
    if (sunMesh && sunVisible) luminaries.push({ mesh: sunMesh, upper: true, type: 'sun' });
    if (moonMesh && moonVisible) luminaries.push({ mesh: moonMesh, upper: true, type: 'moon' });
    if (underworldSunMesh && underworldSunVisible) luminaries.push({ mesh: underworldSunMesh, upper: false, type: 'usun' });
    if (underworldMoonMesh && underworldMoonVisible) luminaries.push({ mesh: underworldMoonMesh, upper: false, type: 'umoon' });
    
    if (luminaries.length > 0) {
        const source = luminaries[Math.floor(Math.random() * luminaries.length)];
        
// Trigger a SHORT flicker for random lightning (half duration)
const flickerOffset = 2500; // Skip ahead 2.5 seconds into the flicker
if (source.type === 'sun') {
    sunFlickerActive = true;
    sunFlickerStartTime = Date.now() - flickerOffset;
} else if (source.type === 'moon') {
    moonFlickerActive = true;
    moonFlickerStartTime = Date.now() - flickerOffset;
} else if (source.type === 'usun') {
    uSunFlickerActive = true;
    uSunFlickerStartTime = Date.now() - flickerOffset;
} else if (source.type === 'umoon') {
    uMoonFlickerActive = true;
    uMoonFlickerStartTime = Date.now() - flickerOffset;
}
        
        // Spawn a burst of 5-12 bolts
        const boltCount = 5 + Math.floor(Math.random() * 8);
        for (let i = 0; i < boltCount; i++) {
            const burstColor = source.type; // Match color to flickering luminary
            spawnLightningBolt3D(source.mesh, source.upper, burstColor);
        }
    }
    
    // Also spawn shell lightning occasionally
    if (Math.random() < 0.4) {
        spawnShellLightningBolt();
    }
}
            updateLightning();

           
            // Apply camera shiver at edge OR from Fimbulwinter
            const inUnderworldView = isUnderworldView || isUnderworldEdgeView || isUnderworldMidView || isUSunView || isUMoonView;
            const edgeShiver = inUnderworldView ? underShiverIntensity : upperShiverIntensity;
            const fimbulShiver = inUnderworldView ? lowerFimbulShiverIntensity : upperFimbulShiverIntensity;
           
            // Edge shiver only at edge views, Fimbul shiver at ALL ground views including luminary
            const isLuminaryView = isSunView || isMoonView || isUSunView || isUMoonView;
            const isEdgeOnlyView = isEdgeView || isUnderworldEdgeView;
            
            // Luminary views only get Fimbul shiver, not edge shiver
            const activeShiver = isLuminaryView ? fimbulShiver : Math.max(edgeShiver, fimbulShiver);
           
            if (activeShiver > 0 && isGroundView) {
                camera.position.x += (Math.random() - 0.5) * activeShiver;
                camera.position.y += (Math.random() - 0.5) * activeShiver * 0.5;
                camera.position.z += (Math.random() - 0.5) * activeShiver;
            }
            
            renderer.render(scene, camera);
        }
       
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Resize cold system canvases
    const canvasIds = ['upper-snow-canvas', 'upper-frost-canvas', 'under-snow-canvas', 'under-frost-canvas', 'fimbul-frost-canvas', 'lens-flare-canvas', 'lightning-canvas'];
            canvasIds.forEach(id => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
            });
            if (starfieldMaterial) starfieldMaterial.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        });
        animate();
    </script>
</body>
</html>
