<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bonnie & Clyde vs The Law</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bonnie & Clyde vs The Law</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{--gold:#c9a227;--crimson:#6b1c1c;--steel:#3d4f5f;--night:#0d0d12;--smoke:#181820;--border:#2a2a35}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--night);color:#e0e0e0;min-height:100vh;overflow-x:hidden}
.hidden{display:none!important}

/* Header */
header{background:var(--smoke);padding:10px 20px;text-align:center;border-bottom:1px solid var(--border);box-shadow:0 2px 10px rgba(0,0,0,.5)}
header h1{font-size:1.2em;font-weight:600;letter-spacing:4px;color:#fff;text-transform:uppercase}

/* Main Layout */
.game-wrap{display:grid;grid-template-columns:240px 1fr 240px;gap:12px;padding:12px;height:calc(100vh - 54px)}
.side-panel{background:var(--smoke);border:1px solid var(--border);padding:12px;overflow-y:auto;display:flex;flex-direction:column}
.battlefield{background:linear-gradient(180deg,#0a0a0f 0%,#12121a 100%);border:1px solid var(--border);position:relative;display:grid;grid-template-rows:1fr auto 1fr;gap:8px;padding:12px}

/* Nerd Stats */
.nerd-stats{flex-shrink:0}
.nerd-stats-content{font-size:.7em;color:#888}
.nerd-row{display:flex;justify-content:space-between;padding:2px 0;border-bottom:1px solid rgba(255,255,255,.05)}
.nerd-row span:last-child{color:#aaa;font-weight:600}

/* Action Feed */
.action-feed-section{flex:1;min-height:0;display:flex;flex-direction:column}
.action-feed{flex:1;overflow-y:auto;font-size:.75em;scroll-behavior:smooth;min-height:120px;max-height:300px;background:rgba(0,0,0,.3);border:1px solid var(--border);padding:6px}
.action-feed::-webkit-scrollbar{width:4px}
.action-feed::-webkit-scrollbar-track{background:rgba(0,0,0,.3)}
.action-feed::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.action-feed::-webkit-scrollbar-thumb:hover{background:#444}

/* Combat Predictor Tooltip */
.combat-predictor-tooltip{position:fixed;background:rgba(13,13,18,.98);border:2px solid var(--gold);padding:14px;font-size:.8em;min-width:280px;max-width:320px;z-index:200;border-radius:6px;box-shadow:0 8px 32px rgba(0,0,0,.8);pointer-events:none}
.combat-predictor-tooltip.hidden{display:none}
.predictor-header{display:flex;align-items:center;gap:10px;margin-bottom:12px;padding-bottom:10px;border-bottom:2px solid var(--gold)}
.predictor-header-portrait{font-size:2em}
.predictor-header-info{flex:1}
.predictor-header-name{color:var(--gold);font-weight:700;font-size:1.1em}
.predictor-header-status{font-size:.85em;margin-top:2px}
.predictor-target{display:flex;align-items:center;gap:8px;margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--border)}
.predictor-target span:first-child{font-size:1.5em}
.predictor-target-name{color:var(--gold);font-weight:600}
.predictor-row{display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px dotted #333}
.predictor-label{color:#888}
.predictor-value{font-weight:600}
.predictor-value.good{color:#4ade80}
.predictor-value.neutral{color:#fbbf24}
.predictor-value.bad{color:#f87171}
.predictor-breakdown{margin-top:10px;padding-top:8px;border-top:1px solid var(--border)}
.predictor-line{display:flex;justify-content:space-between;padding:2px 0;font-size:.95em}
.predictor-line.add span:last-child{color:#4ade80}
.predictor-line.sub span:last-child{color:#f87171}
.predictor-line.result{border-top:1px solid #333;margin-top:4px;padding-top:4px;font-weight:600}
.predictor-warning{color:#f87171;font-size:.9em;margin-top:8px;padding:6px;background:rgba(248,113,113,.15);border-radius:4px;border:1px solid rgba(248,113,113,.3)}
.predictor-info{color:#60a5fa;font-size:.9em;margin-top:8px;padding:6px;background:rgba(96,165,250,.1);border-radius:4px}
.predictor-section{margin-top:10px;padding-top:8px;border-top:1px solid var(--border)}
.predictor-section-title{color:var(--gold);font-weight:600;margin-bottom:6px;font-size:.9em}

.feed-entry{padding:6px 8px;margin:4px 0;border-radius:3px;animation:feedSlide .3s ease;border-left:3px solid transparent}
@keyframes feedSlide{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}
.feed-entry.attack{background:rgba(201,48,44,.15);border-left-color:#c9302c}
.feed-entry.defend{background:rgba(64,145,108,.15);border-left-color:#40916c}
.feed-entry.suppress{background:rgba(155,107,204,.15);border-left-color:#9b6bcc}
.feed-entry.scavenge{background:rgba(26,90,94,.15);border-left-color:#1a5a5e}
.feed-entry.rally{background:rgba(139,90,0,.15);border-left-color:#8b5a00}
.feed-entry.deploy{background:rgba(201,162,39,.15);border-left-color:var(--gold)}
.feed-entry.event{background:rgba(107,91,149,.15);border-left-color:#6b5b95}
.feed-entry.kill{background:rgba(255,0,0,.2);border-left-color:#ff0000}
.feed-entry.share{background:rgba(90,74,26,.15);border-left-color:#5a4a1a}
.feed-entry.debuff{background:rgba(139,0,0,.15);border-left-color:#8b0000}
.feed-entry.heal{background:rgba(74,222,128,.15);border-left-color:#4ade80}
.feed-entry.bleeding{background:rgba(139,0,0,.2);border-left-color:#8b0000}
.feed-entry .feed-icon{font-size:1.1em;margin-right:4px}
.feed-entry .feed-time{float:right;color:#555;font-size:.85em}
.feed-entry .feed-detail{color:#666;font-size:.9em;margin-top:2px}

/* Event Ticker */
.event-ticker{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);background:rgba(107,91,149,.9);color:#fff;padding:6px 16px;font-size:.75em;border-radius:20px;opacity:0;transition:opacity .3s ease;white-space:nowrap}
.event-ticker.show{opacity:1}

/* Cards */
.card-zone{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;align-content:flex-start;padding:10px;min-height:140px}
.card {
    width:125px;
    height:200px;
    border-radius:6px;
    cursor:pointer;
    position:relative;
    transition:transform .15s ease, box-shadow .15s ease;
    font-size:11px;
    background-image: url('https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/97ab3c1826adf3727d2c7a49bda971b9ea699d11/KaMSickle.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border:1px solid var(--border);
    overflow:visible;}
.card:hover{transform:translateY(-3px);box-shadow:0 6px 20px rgba(0,0,0,.6)}
.card.selected{box-shadow:0 0 0 2px var(--gold),0 6px 20px rgba(0,0,0,.6);transform:translateY(-3px)}
.card.outlaw{border-color:var(--crimson);background:linear-gradient(180deg,#1a1215 0%,#0f0a0c 100%)}
.card.law{border-color:var(--steel);background:linear-gradient(180deg,#131519 0%,#0a0c0f 100%)}
.card-name{text-align:center;font-weight:600;padding:6px 4px;font-size:9px;background:rgba(0,0,0,.4);border-bottom:1px solid var(--border);text-transform:uppercase;letter-spacing:.5px;color:#fff}
.card-portrait{height:44px;display:none;background:rgba(0,0,0,.2)}
.card-stats{padding:6px;font-size:8px;line-height:1.5;color:#aaa}
.card-stats span{display:block}
.card-abilities{display:flex;justify-content:center;gap:4px;padding:2px 4px;font-size:12px;max-width:100%;margin-top:-4px}
.stat-hp{color:#5cb85c}.stat-ammo{color:#d9a34a}.stat-move{color:#5bc0de}.stat-fire{color:#c9302c}.stat-supp{color:#9b6bcc}.stat-dodge{color:#3dbdbd}
/* Rattled Panic Shake ‚Äî Light hand tremor for low State */
.card.rattled-shake {
    animation: panicShake 0.4s infinite ease-in-out;
}

@keyframes panicShake {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    10% { transform: translate(-1px, 0.5px) rotate(-0.5deg); }
    20% { transform: translate(1px, -0.5px) rotate(0.5deg); }
    30% { transform: translate(-0.5px, 1px) rotate(-0.3deg); }
    40% { transform: translate(0.5px, -0.8px) rotate(0.2deg); }
    50% { transform: translate(-0.2px, 0.3px) rotate(-0.1deg); }
    60% { transform: translate(0.3px, -0.2px) rotate(0.4deg); }
    70% { transform: translate(-0.8px, 0.4px) rotate(-0.4deg); }
    80% { transform: translate(0.6px, 0.2px) rotate(0.3deg); }
    90% { transform: translate(-0.3px, -0.1px) rotate(-0.2deg); }
}
.card.pulse {
    animation: pulseBeat 0.9s infinite ease-in-out;
}

@keyframes pulseBeat {
    0%   { transform: scale(1); }
    50%  { transform: scale(1.03); }
    100% { transform: scale(1); }
}

/* Center Area */
.center-zone{background:rgba(0,0,0,.4);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;gap:20px;padding:12px;min-height:80px;height:80px}
.phase-display{text-align:center}
.phase-display h2{color:var(--gold);font-size:1em;font-weight:600;letter-spacing:2px;text-transform:uppercase}
.turn-indicator{padding:5px 14px;font-size:.75em;margin-top:6px;text-transform:uppercase;letter-spacing:1px;font-weight:600;min-width:140px;display:inline-block;text-align:center}
.turn-indicator.outlaw{background:var(--crimson);color:#fff}
.turn-indicator.law{background:var(--steel);color:#fff}

/* Buttons */
.btn{padding:3px 6px;border:none;cursor:pointer;font-family:inherit;font-weight:600;transition:all .15s ease;text-transform:uppercase;font-size:.65em;letter-spacing:1px}
#btnEndTurn{min-width:180px;max-width:180px;width:180px}
.btn-gold{background:var(--gold);color:#000}.btn-gold:hover{background:#ddb32e;box-shadow:0 2px 10px rgba(201,162,39,.3)}
.btn-red{background:var(--crimson);color:#fff}.btn-red:hover{background:#7d2222}
.btn-blue{background:var(--steel);color:#fff}.btn-blue:hover{background:#4a6070}
.btn-green{background:#2a5a40;color:#fff}.btn-green:hover{background:#357a52}
.btn-rally{background:#8b5a00;color:#fff}.btn-rally:hover{background:#a36a00}
.btn-cover{background:#2d5a4a;color:#fff}.btn-cover:hover{background:#3d7a6a}
.btn-scav{background:#1a4a5e;color:#fff}.btn-scav:hover{background:#236b85}
.btn-share{background:#5a4a1a;color:#fff}.btn-share:hover{background:#7a6a2a}
.btn-hide{background:#6b5b95;color:#fff}.btn-hide:hover{background:#8b7bb5}

.btn:disabled{opacity:.3;cursor:not-allowed}

.action-bar{display:flex;flex-wrap:wrap;gap:4px;justify-content:center;align-items:center;min-height:55px}
#btnSound{min-width:50px;max-width:50px;width:50px}
#btnRadio{min-width:90px;max-width:90px;width:90px}
#btnForce{min-width:70px;max-width:70px;width:70px}

/* Event Results Panel */
.event-panel{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--smoke);border:1px solid #6b5b95;padding:0;z-index:150;min-width:420px;max-width:90vw;overflow:hidden;box-shadow:0 25px 80px rgba(0,0,0,.9)}
.event-header{background:#3d3560;padding:14px;text-align:center;font-size:1em;font-weight:600;letter-spacing:2px;text-transform:uppercase;color:#fff}
.event-body{padding:20px}
.event-description{text-align:center;margin-bottom:16px;font-size:.9em;color:#b8a8d4}
.event-affects{background:rgba(0,0,0,.3);border:1px solid var(--border);padding:12px;margin-bottom:16px}
.event-affects h4{color:#9b6bcc;margin-bottom:10px;font-size:.8em;text-transform:uppercase;letter-spacing:1px}
.affected-card{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;margin:4px 0;background:rgba(0,0,0,.3);border:1px solid var(--border);font-size:.85em}
.affected-card .name{display:flex;align-items:center;gap:8px}
.affected-card .change{font-weight:600}
.affected-card .change.positive{color:#5cb85c}
.affected-card .change.negative{color:#c9302c}
.affected-card .change.neutral{color:#d9a34a}
.event-footer{text-align:center;padding:14px;background:rgba(0,0,0,.3);border-top:1px solid var(--border)}

/* Rally Panel */
.rally-panel{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--smoke);border:1px solid #8b5a00;padding:0;z-index:150;min-width:380px;overflow:hidden;box-shadow:0 25px 80px rgba(0,0,0,.9)}
.rally-header{background:#5c3d00;padding:14px;text-align:center;font-size:1em;font-weight:600;text-transform:uppercase;letter-spacing:2px;color:#fff}
.rally-body{padding:24px;text-align:center}
.rally-chance{font-size:2.2em;color:var(--gold);margin:16px 0;font-weight:300}
.rally-meter{height:6px;background:#1a1a1a;overflow:hidden;margin:16px 0;border:1px solid var(--border)}
.rally-fill{height:100%;background:linear-gradient(90deg,#c9302c,#d9a34a,#5cb85c);transition:width .8s ease}
.rally-result{font-size:1.3em;margin:16px 0;font-weight:600}
.rally-result.success{color:#5cb85c}.rally-result.fail{color:#c9302c}

/* Scavenge Panel */
.scavenge-panel{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--smoke);border:1px solid #1a5a5e;padding:0;z-index:150;min-width:380px;overflow:hidden;box-shadow:0 25px 80px rgba(0,0,0,.9)}
.scavenge-header{background:#0d3a3e;padding:14px;text-align:center;font-size:1em;font-weight:600;text-transform:uppercase;letter-spacing:2px;color:#fff}
.scavenge-body{padding:24px;text-align:center}
.scavenge-result{font-size:1.8em;margin:16px 0;font-weight:600}
.scavenge-result.success{color:#3dbdbd}.scavenge-result.fail{color:#666}
.scavenge-ammo{font-size:2.5em;color:#d9a34a;margin:12px 0}

/* Suppressed indicator */
.card.suppressed{border-color:#6b5b95!important}
.card.selected.in-cover{box-shadow:0 0 0 4px #2d5a4a, 0 6px 20px rgba(0,0,0,.6) !important; transform:translateY(-3px)}
.suppression-badge{position:absolute;top:-4px;left:-4px;background:#5c4a8a;color:#fff;font-size:9px;padding:2px 6px;font-weight:600;border-radius:2px}
.defend-badge{position:absolute;top:-4px;right:-4px;background:#5bc0de;color:#000;font-size:9px;padding:2px 6px;font-weight:600;border-radius:2px}
.cover-badge{position:absolute;top:-4px;right:30px;background:#2d5a4a;color:#fff;font-size:9px;padding:2px 6px;font-weight:600;border-radius:2px}
.bleeding-indicator{position:absolute;top:18px;left:50%;transform:translateX(-50%);background:#8b0000;color:#fff;font-size:8px;padding:3px 6px;font-weight:700;border-radius:3px;white-space:nowrap;z-index:10}
.vehicle-badge{position:absolute;top:-4px;left:50%;transform:translateX(-50%);background:#d97706;color:#000;font-size:9px;padding:2px 8px;font-weight:700;border-radius:2px;white-space:nowrap}
.roadblock-badge{position:absolute;top:33px;left:50%;transform:translateX(-50%);background:#ff6b00;color:#000;font-size:8px;padding:3px 7px;font-weight:700;border-radius:3px;white-space:nowrap;z-index:10;border:1px solid #000}
.arrested-indicator{position:absolute;top:-4px;left:50%;transform:translateX(-50%);background:#8b0000;color:#fff;font-size:9px;padding:2px 8px;font-weight:700;border-radius:3px;white-space:nowrap;z-index:10;border:1px solid #000}
.forest-badge{position:absolute;top:-15px;left:15%;transform:translateX(-50%);background:#2d5a1a;color:#90ee90;font-size:12px;padding:2px 6px;font-weight:700;border-radius:3px;white-space:nowrap;z-index:10;border:1px solid #1a3d0a}

/* Combat Results Panel */
.combat-panel{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--smoke);border:1px solid var(--gold);padding:0;z-index:150;min-width:480px;max-width:90vw;max-height:85vh;overflow:hidden;box-shadow:0 25px 80px rgba(0,0,0,.9);display:flex;flex-direction:column}
.combat-header{background:linear-gradient(90deg,var(--crimson),#2a2a35,var(--steel));padding:14px;text-align:center;font-size:1em;font-weight:600;letter-spacing:3px;text-transform:uppercase;color:#fff}
.combat-body{padding:24px;display:flex;align-items:center;justify-content:center;gap:24px}
.combat-card{text-align:center;padding:16px;background:rgba(0,0,0,.3);border:1px solid var(--border);min-width:130px}
.combat-card.attacker{border-color:var(--crimson)}.combat-card.defender{border-color:var(--steel)}.combat-card.winner{box-shadow:0 0 15px rgba(201,162,39,.4)}
.combat-portrait{font-size:42px;margin:8px 0}
.combat-name{font-weight:600;color:var(--gold);margin-bottom:8px;font-size:.9em}
.combat-hp{font-size:.85em;color:#aaa}
.combat-hp-bar{height:4px;background:#1a1a1a;margin-top:6px;overflow:hidden}
.combat-hp-fill{height:100%;transition:width .4s ease}
.combat-hp-fill.healthy{background:#5cb85c}.combat-hp-fill.wounded{background:#d9a34a}.combat-hp-fill.critical{background:#c9302c}
.combat-vs{font-size:1.5em;color:var(--gold);font-weight:300}
.combat-result{padding:16px;text-align:center;background:rgba(0,0,0,.3);border-top:1px solid var(--border)}
.combat-damage{font-size:1.4em;margin-bottom:8px;font-weight:600}
.combat-damage.hit{color:#c9302c}.combat-damage.miss{color:#666}.combat-damage.blocked{color:#5bc0de}
.combat-details{font-size:.8em;color:#666;margin-bottom:12px}
.combat-breakdown{background:#0d0d12;border:1px solid var(--border);padding:12px;margin:12px 0;font-size:.8em;text-align:left;max-height:35vh;overflow-y:auto}
.combat-breakdown-title{color:var(--gold);font-weight:600;margin-bottom:8px;text-transform:uppercase;letter-spacing:1px;font-size:.9em}
.combat-breakdown-row{display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid #1a1a1f}
.combat-breakdown-row:last-child{border-bottom:none}
.combat-breakdown-row.add span:last-child{color:#5cb85c}
.combat-breakdown-row.sub span:last-child{color:#c9302c}
.combat-breakdown-row.result{border-top:1px solid var(--border);margin-top:6px;padding-top:6px;font-weight:600}
.combat-breakdown-row.result span:last-child{color:#fff}
.combat-breakdown-section{margin-top:10px;padding-top:10px;border-top:1px solid var(--border)}
.combat-effects{display:flex;flex-wrap:wrap;gap:6px;justify-content:center;margin-bottom:12px}
.combat-effect{padding:4px 10px;font-size:.7em;font-weight:600;text-transform:uppercase;letter-spacing:.5px}
.combat-effect.buff{background:#1e3a2a;color:#5cb85c;border:1px solid #2a5a40}.combat-effect.debuff{background:#3a1e1e;color:#c9302c;border:1px solid #5a2a2a}.combat-effect.neutral{background:#2a2a35;color:#aaa;border:1px solid var(--border)}
.defending{box-shadow:0 0 0 2px #5bc0de!important;border-color:#5bc0de!important}
.defending::after{content:'üõ°Ô∏è';position:absolute;top:-6px;right:-6px;font-size:14px}

/* Action Bar */
.action-bar{display:flex;gap:3px;justify-content:center;flex-wrap:wrap}

/* Side Panel Sections */
.panel-section{margin-bottom:16px}
.panel-section h3{color:var(--gold);font-size:.75em;border-bottom:1px solid var(--border);padding-bottom:6px;margin-bottom:10px;text-transform:uppercase;letter-spacing:1px;font-weight:600}
.stat-row{display:flex;justify-content:space-between;font-size:.8em;margin:6px 0;color:#aaa}
.stat-row span:last-child{color:#fff;font-weight:600}
.log{font-size:.7em;max-height:160px;overflow-y:auto;background:#0d0d12;padding:8px;border:1px solid var(--border)}
.log-entry{padding:4px 0;border-bottom:1px solid #1a1a1f}
.log-entry.outlaw{color:#c9302c}.log-entry.law{color:#5bc0de}.log-entry.event{color:#9b6bcc}

/* Combat Predictor */
.predictor-row{display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid #1a1a1f}
.predictor-row:last-child{border-bottom:none}
.predictor-label{color:#666}
.predictor-value{font-weight:600}
.predictor-value.good{color:#5cb85c}
.predictor-value.neutral{color:#d9a34a}
.predictor-value.bad{color:#c9302c}
.predictor-breakdown{background:#0d0d12;border:1px solid var(--border);padding:8px;margin-top:8px;font-size:.9em}
.predictor-line{padding:2px 0;display:flex;justify-content:space-between}
.predictor-line.add{color:#5cb85c}
.predictor-line.sub{color:#c9302c}
.predictor-line.result{border-top:1px solid var(--border);margin-top:4px;padding-top:4px;font-weight:600;color:#fff}
.predictor-target{background:#1a1a20;border:1px solid var(--border);padding:6px 8px;margin-bottom:8px;display:flex;align-items:center;gap:8px}
.predictor-target-name{color:var(--gold);font-weight:600}

/* Deck/Hand indicator */
.deck-info{text-align:center;font-size:.8em;margin-top:8px;padding:10px;background:#0d0d12;border:1px solid var(--border)}

/* Event Banner */
.event-banner{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--smoke);border:1px solid var(--gold);padding:28px;text-align:center;z-index:100;max-width:400px;box-shadow:0 25px 80px rgba(0,0,0,.9)}
.event-banner h2{color:var(--gold);margin-bottom:14px;font-weight:600}
.event-banner p{margin-bottom:18px;font-size:.9em;color:#aaa}

/* Modal */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.85);display:flex;align-items:center;justify-content:center;z-index:200;backdrop-filter:blur(4px)}
.modal-content{background:var(--smoke);border:1px solid var(--border);padding:24px;max-width:600px;max-height:85vh;overflow-y:auto;width:90%}
.modal h2{color:var(--gold);margin-bottom:16px;text-align:center;font-weight:600;text-transform:uppercase;letter-spacing:2px}
.form-group{margin-bottom:14px}
.form-group label{display:block;font-size:.75em;margin-bottom:6px;color:#888;text-transform:uppercase;letter-spacing:.5px}
.form-group input,.form-group select,.form-group textarea{width:100%;padding:10px 12px;border:1px solid var(--border);background:#0d0d12;color:#fff;font-family:inherit;font-size:.9em;transition:border-color .15s ease}
.form-group input:focus,.form-group select:focus,.form-group textarea:focus{outline:none;border-color:var(--gold)}
.form-row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.preview-card{margin:16px auto}

/* Menu Screen */
.menu-screen{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;gap:12px;padding:20px;background:radial-gradient(ellipse at center,#151520 0%,#0d0d12 100%)}
.menu-screen h1{font-size:1.8em;color:#fff;text-align:center;font-weight:300;letter-spacing:6px;text-transform:uppercase;margin-bottom:4px}
.menu-screen h1 br+*{font-size:.6em}
.menu-screen .subtitle{color:#555;margin-bottom:30px;text-transform:uppercase;letter-spacing:3px;font-size:.75em}
.menu-btn{width:280px;padding:14px;font-size:.8em}

/* Deck Builder */
.deck-builder{padding:16px}
.deck-builder-grid{display:grid;grid-template-columns:1fr 280px;gap:16px;margin-top:16px}
.card-pool{display:flex;flex-wrap:wrap;gap:10px;background:#0d0d12;padding:14px;border:1px solid var(--border);max-height:400px;overflow-y:auto}
.current-deck{background:rgba(0,0,0,.3);padding:14px;border:1px solid var(--border)}
.deck-list{max-height:300px;overflow-y:auto}
.deck-item{display:flex;justify-content:space-between;padding:8px 10px;background:#0d0d12;margin:4px 0;border:1px solid var(--border);font-size:.8em}
.faction-tabs{display:flex;gap:0;margin-bottom:16px}
.faction-tab{padding:10px 20px;cursor:pointer;background:#1a1a20;border:1px solid var(--border);border-bottom:none;font-size:.75em;text-transform:uppercase;letter-spacing:1px;color:#666;transition:all .15s ease}
.faction-tab:first-child{border-right:none}
.faction-tab.active{background:var(--smoke);color:var(--gold);border-color:var(--gold);border-bottom:1px solid var(--smoke);margin-bottom:-1px}

/* Victory Screen */
.victory-screen{position:fixed;inset:0;background:rgba(0,0,0,.95);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:300}
.victory-screen h1{font-size:2.5em;margin-bottom:20px;font-weight:300;letter-spacing:8px;text-transform:uppercase}
.victory-screen.outlaw h1{color:var(--crimson)}
.victory-screen.law h1{color:var(--steel)}
.victory-stats{background:var(--smoke);padding:30px 50px;border:1px solid var(--border);margin:20px;text-align:center}

/* Signal Charge Screen Flash */
.screen-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: white;
    z-index: 9999;
    opacity: 0;
    pointer-events: none;
    transition: opacity 10.0s ease-out;
}
.screen-flash.flash {
    opacity: 1;
}

#phaseText{display:none}

body.flash-desaturate {
    filter: saturate(0.2) brightness(1.3);
    transition: filter 1s ease-out;
}

body.dynamite-shake {
    animation: shake 0.5s ease-in-out;
}
@keyframes shake {
    0%, 100% { transform: translate(0, 0) }
    10% { transform: translate(-8px, 2px) }
    20% { transform: translate(8px, -2px) }
    30% { transform: translate(-6px, -4px) }
    40% { transform: translate(6px, 4px) }
    50% { transform: translate(-10px, 2px) }
    60% { transform: translate(10px, -2px) }
    70% { transform: translate(-8px, -3px) }
    80% { transform: translate(8px, 3px) }
    90% { transform: translate(-4px, 1px) }
}

body.dynamite-blur {
    filter: blur(4px) brightness(1.2);
    transition: filter 10s ease-out;
}

/* NEW: Combined state when both effects are active */
body.flash-desaturate.dynamite-blur {
    filter: saturate(0.2) blur(4px) brightness(1.25);
    transition: filter 25s ease-out;
}


</style>
<script>
// Force browser to parse CSS animations immediately (fixes flash timing bug)
document.addEventListener('DOMContentLoaded', function() {
    document.body.offsetHeight; // Trigger reflow to force CSS parse
});
</script>
</head>
<body>

<!-- Menu Screen -->
<div id="menuScreen" class="menu-screen">
    <h1>üî´ BONNIE & CLYDE<br>vs THE LAW üöî</h1>
    <p class="subtitle">A Tactical Card Game</p>
   
    <div style="background:var(--smoke);border:1px solid var(--border);padding:20px;margin:10px 0;width:300px">
        <div style="color:var(--gold);font-weight:600;margin-bottom:12px;text-align:center">‚öîÔ∏è GAME MODE</div>
        <div style="display:flex;flex-direction:column;gap:8px">
            <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                <input type="radio" name="gameMode" value="ai_law" checked onchange="updateGameMode()">
                <span>ü§† Play as <strong style="color:#f87171">Outlaws</strong> vs AI Law</span>
            </label>
            <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                <input type="radio" name="gameMode" value="ai_outlaw" onchange="updateGameMode()">
                <span>üöî Play as <strong style="color:#60a5fa">Law</strong> vs AI Outlaws</span>
            </label>
            <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                <input type="radio" name="gameMode" value="pvp" onchange="updateGameMode()">
                <span>üë• Two Players (Hot Seat)</span>
            </label>
        </div>
        <div id="aiDifficultySection" style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border)">
            <div style="color:#aaa;font-size:.85em;margin-bottom:8px">AI Difficulty:</div>
            <select id="aiDifficulty" style="width:100%;padding:6px;background:var(--night);color:#fff;border:1px solid var(--border)">
                <option value="easy">Easy - Makes mistakes</option>
                <option value="medium" selected>Medium - Balanced</option>
                <option value="hard">Hard - Ruthless</option>
            </select>
        </div>
    </div>
   
    <button class="btn btn-gold menu-btn" onclick="startGame()">‚öîÔ∏è START BATTLE</button>
    <button class="btn btn-red menu-btn" onclick="startBankRobbery()">üí∞ BANK ROBBERY</button>
    <button class="btn btn-blue menu-btn" onclick="showDeckBuilder()">üì¶ DECK BUILDER</button>
    <button class="btn btn-red menu-btn" onclick="showCardCreator()">‚ú® CREATE CARD</button>
    <button class="btn btn-blue menu-btn" onclick="showEventCreator()">üé≤ CREATE EVENT</button>
    <button class="btn btn-green menu-btn" onclick="showAbilityCreator()">‚ö° CREATE ABILITY</button>
    <button class="btn btn-gold menu-btn" onclick="showRules()">üìú HOW TO PLAY</button>
    <button class="btn btn-red menu-btn" onclick="clearAllData()">üóëÔ∏è CLEAR CACHE</button>
</div>

<!-- Game Screen -->
<div id="gameScreen" class="hidden">
    <header><h1>üî´ BONNIE & CLYDE vs THE LAW üöî</h1></header>
    <div class="game-wrap">
        <!-- Left Panel - Outlaw Info -->
        <div class="side-panel">
            <div class="panel-section">
                <h3>üî´ OUTLAW GANG</h3>
                <div class="stat-row"><span>Score:</span><span id="outlawScore">0</span></div>
                <div class="stat-row"><span>Cards in Deck:</span><span id="outlawDeckCount">0</span></div>
                <div class="stat-row"><span>Cards in Hand:</span><span id="outlawHandCount">0</span></div>
            </div>
            <div class="panel-section action-feed-section">
                <h3>‚öîÔ∏è COMBAT FEED</h3>
                <div class="action-feed" id="lawCombatFeed"></div>
            </div>
            <div class="panel-section action-feed-section">
                <h3>‚öîÔ∏è OUTLAW ACTIONS</h3>
                <div class="action-feed" id="outlawFeed"></div>
                <button class="btn btn-hide" onclick="showEventTrigger()" style="width:100%;margin-top:8px;font-size:.65em;padding:6px">üé≤ Trigger Event</button>
            </div>
        </div>

        <!-- Battlefield -->
        <div class="battlefield">
            <div class="card-zone" id="lawZone"></div>
            <div class="center-zone">
                <div class="phase-display">
                    <h2 id="phaseText">DEPLOYMENT</h2>
                </div>
                <div class="action-bar">
                    <button class="btn btn-gold" id="btnDeploy" onclick="deployCard()">Deploy</button>
                    <button class="btn btn-red" id="btnAttack" onclick="attackMode()">Attack</button>
                    <button class="btn btn-blue" id="btnSuppress" onclick="suppressMode()">Suppress</button>
                    <button class="btn btn-red" id="btnArrest" onclick="arrestMode()" title="ARREST: Lock up enemy (2 Move, 100% success)">üîí ARREST</button>
                    <button class="btn btn-green" id="btnDefend" onclick="defendAction()">Defend</button>
                    <button class="btn btn-cover" id="btnCover" onclick="takeCoverAction()">Take Cover</button>
                    <button class="btn btn-scav" id="btnScavenge" onclick="scavengeAmmo()">Scavenge</button>
                    <button class="btn btn-hide" id="btnHide" onclick="hideMember()" title="Hide: Retreat to hand (team suppression penalty)">Hide</button>
                    <button class="btn btn-share" id="btnShare" onclick="shareAmmoMode()">Share Ammo</button>
                    <button class="btn btn-gold" id="btnBoard" onclick="boardVehicle()">üöó Board</button>
                    <button class="btn btn-red" id="btnRam" onclick="ramAction()" title="RAM: Suicide charge (kills 1-3 enemies)">üöóüí• RAM</button>
                    <button class="btn btn-red" id="btnDisembark" onclick="disembarkVehicle()">üö™ Disembark</button>
                    <button class="btn btn-rally" id="btnRally" onclick="attemptRally()">Rally!</button>
                    <button class="btn btn-gold" id="btnEndTurn" onclick="endTurn()">End Turn</button>
                    <button class="btn btn-force" id="btnForceTurn" onclick="forceTurn()" title="Emergency: Force next turn if game hangs">‚ö†Ô∏è Force</button>
                    <button class="btn" id="btnSound" onclick="toggleSound()" title="Toggle Sound" style="background:#333">üîä</button>
<button class="btn" id="btnRadio" onclick="toggleRadio()" title="1930s Radio - Jazz & Gunfire">
    üìª RADIO
</button>
                </div>
                <div class="event-ticker" id="eventTicker"></div>
            </div>
            <div class="card-zone" id="outlawZone"></div>
        </div>

        <!-- Right Panel - Law Info -->
        <div class="side-panel">
            <div class="panel-section">
                <h3>üöî THE LAW</h3>
                <div class="stat-row"><span>Score:</span><span id="lawScore">0</span></div>
                <div class="stat-row"><span>Cards in Deck:</span><span id="lawDeckCount">0</span></div>
                <div class="stat-row"><span>Cards in Hand:</span><span id="lawHandCount">0</span></div>
            </div>
                <div class="panel-section action-feed-section">
                <h3>‚öîÔ∏è COMBAT FEED</h3>
                <div class="action-feed" id="outlawCombatFeed"></div>
            </div>
            <div class="panel-section action-feed-section">
                <h3>‚öîÔ∏è LAW ACTIONS</h3>
                <div class="action-feed" id="lawFeed"></div>
                <button class="btn btn-hide" onclick="showEventTrigger()" style="width:100%;margin-top:8px;font-size:.65em;padding:6px">üé≤ Trigger Event</button>
            </div>
        </div>
    </div>
</div>

<!-- Hand Modal -->
<div id="handModal" class="modal hidden">
    <div class="modal-content">
        <h2 id="handTitle">YOUR HAND</h2>
        <div class="card-zone" id="handCards" style="min-height:150px"></div>
        <div style="text-align:center;margin-top:16px">
            <button class="btn btn-gold" onclick="closeHand()">Close</button>
        </div>
    </div>
</div>

<!-- Card Creator Modal -->
<div id="cardCreator" class="modal hidden">
    <div class="modal-content">
        <h2>‚ú® CREATE CUSTOM CARD</h2>
        <div class="form-row">
            <div class="form-group">
                <label>Card Name</label>
                <input type="text" id="ccName" placeholder="Wild Bill">
            </div>
            <div class="form-group">
                <label>Faction</label>
                <select id="ccFaction">
                    <option value="outlaw">Outlaw</option>
                    <option value="law">Law</option>
                </select>
            </div>
        </div>
<div class="form-group">
    <label>Portrait (Emoji)</label>
    <select id="ccPortrait" required>
        <option value="" disabled selected>Choose portrait...</option>
        
        <!-- Outlaw-themed -->
        <option value="ü§†">ü§† Cowboy / Outlaw</option>
        <option value="üë©">üë© Bonnie-style woman</option>
        <option value="üëß">üëß Kayleigh Marie -style woman</option>
        <option value="ü§µ">ü§µ Clyde-style gangster</option>
        <option value="üßî">üßî Bearded gang member</option>
        <option value="üòé">üòé Cool tough guy</option>
        <option value="üíÄ">üíÄ Skull / Thug</option>
        
        <!-- Law-themed -->
        <option value="üëÆ">üëÆ Sheriff / Deputy</option>
        <option value="üëÆ‚Äç‚ôÇÔ∏è">üëÆ‚Äç‚ôÇÔ∏è Male officer</option>
        <option value="üïµÔ∏è">üïµÔ∏è Detective</option>
        <option value="‚≠ê">‚≠ê Marshal / Ranger</option>
        <option value="üéØ">üéØ Sniper / Marksman</option>
        
        <!-- Neutral / Special -->
        <option value="üöó">üöó Vehicle / Car</option>
        <option value="üå≤">üå≤ Tree / Forest</option>
        <option value="üî´">üî´ Gun / Weapon</option>
        <!-- Add more as you want ‚Äì keep it tight -->
    </select>
</div>
        <div class="form-row">
            <div class="form-group">
                <label>HP (1-20)</label>
                <input type="number" id="ccHP" value="10" min="1" max="20">
            </div>
            <div class="form-group">
                <label>Ammo (1-10)</label>
                <input type="number" id="ccAmmo" value="6" min="1" max="10">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Movement (1-5)</label>
                <input type="number" id="ccMove" value="2" min="1" max="5">
            </div>
            <div class="form-group">
                <label>Fire Power (1-10)</label>
                <input type="number" id="ccFire" value="3" min="1" max="10">
            </div>
        </div>
        <div class="form-row">
    <div class="form-group">
        <label>Suppression (1-5)</label>
        <input type="number" id="ccSupp" value="2" min="1" max="5">
    </div>
    <div class="form-group">
        <label>Dodge % (5-40)</label>
        <input type="number" id="ccDodge" value="15" min="5" max="40">
    </div>
</div>
<div class="form-row">
    <div class="form-group">
        <label>Accuracy % (50-100)</label>
        <input type="number" id="ccAccuracy" value="100" min="50" max="100">
    </div>
    <div class="form-group">
        <label>Card Cost (1-10)</label>
        <input type="number" id="ccCost" value="3" min="1" max="10">
    </div>
</div>

<div class="form-group" style="margin-top:16px;">
    <label>Background Image</label>
    <div style="display:flex;gap:8px;align-items:center;">
        <input type="text" id="ccBgUrl" placeholder="https://example.com/image.jpg" style="flex:1;">
        <span>or</span>
        <input type="file" id="ccBgFile" accept="image/*" onchange="previewBackground()" style="width:180px;">
    </div>
    <small style="color:#888;display:block;margin-top:4px;">
        URL or upload ‚Äî stored locally. Leave blank for default.
    </small>
    <div id="bgPreview" style="margin-top:8px;text-align:center;color:#666;font-size:0.85em;">
        No background selected
        </div>
</div>
    <!-- Text Color Customization -->
<div class="form-group" style="margin-top:20px; padding-top:12px; border-top:1px solid var(--border);">
    <label>TEXT COLORS ‚Äî Customize Each Stat</label>
    <small style="color:#888; display:block; margin-bottom:10px;">
        Change colors so text is visible on your background
    </small>

    <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-bottom:16px;">
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">Name</label>
            <input type="color" id="ccColorName" value="#ffffff" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">HP</label>
            <input type="color" id="ccColorHP" value="#5cb85c" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">Ammo</label>
            <input type="color" id="ccColorAmmo" value="#d9a34a" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">Move</label>
            <input type="color" id="ccColorMove" value="#5bc0de" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">Fire</label>
            <input type="color" id="ccColorFire" value="#c9302c" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">Supp</label>
            <input type="color" id="ccColorSupp" value="#9b6bcc" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">Dodge</label>
            <input type="color" id="ccColorDodge" value="#3dbdbd" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">Acc</label>
            <input type="color" id="ccColorAcc" value="#facc15" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
        <div>
            <label style="font-size:0.75em; color:#aaa; display:block; margin-bottom:2px;">State</label>
            <input type="color" id="ccColorState" value="#4ade80" oninput="updatePreview()" style="width:100%; height:32px;">
        </div>
    </div>
</div>
<!-- Live Preview Card -->
<div id="cardPreview" style="
    margin-top:16px; 
    padding:8px; 
    background: linear-gradient(180deg,#1a1215 0%,#0f0a0c 100%);
    border:2px solid var(--gold); 
    border-radius:8px; 
    min-height:250px; 
    width:180px; 
    float:right;
    position:sticky;
    top:20px;
    margin-left:auto;
    margin-right:auto;
    overflow:hidden; 
    background-size: cover; 
    background-position: center; 
    background-repeat: no-repeat;
">
    <div style="position:absolute; inset:0; background: linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0.7) 100%); z-index:1;"></div>
    
    <div style="position:relative; z-index:2; color:#fff; text-shadow: 1px 1px 3px #000;">
        <div id="previewName" style="font-weight:700; text-align:center; font-size:10px; margin-bottom:6px; padding-bottom:6px; border-bottom:1px solid rgba(255,255,255,0.2); color:#ffffff; text-transform:uppercase; letter-spacing:0.5px;">
            WILD BILL
        </div>
        
        <div id="previewPortrait" style="text-align:center; font-size:26px; margin-bottom:6px;">
        </div>
        
        <div style="padding:6px; line-height:1.5; font-size:8px;">
            <span id="previewHP" style="color:#5cb85c; display:block;">HP: 10/10</span>
            <span id="previewAmmo" style="color:#d9a34a; display:block;">Ammo: 6/6</span>
            <span id="previewMove" style="color:#5bc0de; display:block;">Move: 2</span>
            <span id="previewFire" style="color:#c9302c; display:block;">Fire: 3</span>
            <span id="previewSupp" style="color:#9b6bcc; display:block;">Supp: 2</span>
            <span id="previewDodge" style="color:#3dbdbd; display:block;">Dodge: 15%</span>
            <span id="previewAcc" style="color:#facc15; display:block;">Acc: 100%</span>
            <span id="previewState" style="color:#4ade80; display:block;">State: 100/100</span>
        </div>
        
        <small style="display:block; text-align:center; margin-top:8px; color:rgba(255,255,255,0.6); font-size:7px;">
            LIVE PREVIEW
        </small>
    </div>
</div>
        <div class="form-group" style="clear:both;">
            <label>Special Abilities (up to 3)</label>
            <select id="ccAbility1">
                <option value="">None</option>
            </select>
            <select id="ccAbility2" style="margin-top:4px">
                <option value="">None</option>
            </select>
            <select id="ccAbility3" style="margin-top:4px">
                <option value="">None</option>
            </select>
        </div>
        <div style="text-align:center;margin-top:16px">
            <button class="btn btn-gold" onclick="saveCard()">üíæ Save Card</button>
            <button class="btn btn-red" onclick="closeModal('cardCreator')">Cancel</button>
        </div>
    </div>
</div>    
    
<!-- Event Creator Modal -->
<div id="eventCreator" class="modal hidden">
    <div class="modal-content">
        <h2>üé≤ CREATE RANDOM EVENT</h2>
        <div class="form-group">
            <label>Event Name</label>
            <input type="text" id="evName" placeholder="Dust Storm">
        </div>
        <div class="form-group">
            <label>Description</label>
            <textarea id="evDesc" rows="2" placeholder="A thick dust storm rolls in..."></textarea>
        </div>
        <div class="form-group">
            <label>Effect Type</label>
            <select id="evType" onchange="updateEventOptions()">
                <option value="damage_all">Damage All Cards</option>
                <option value="heal_all">Heal All Cards</option>
                <option value="damage_faction">Damage One Faction</option>
                <option value="heal_faction">Heal One Faction</option>
                <option value="damage_lowest_hp">Damage Lowest HP Card</option>
                <option value="damage_highest_hp">Damage Highest HP Card</option>
                <option value="heal_lowest_hp">Heal Lowest HP Card</option>
                <option value="full_heal_one">Full Heal Random Card</option>
                <option value="execute_wounded">Execute Wounded (Kill if HP ‚â§ value)</option>
                <option value="stat_mod">Modify Stats (Fire/Move)</option>
                <option value="dodge_mod">Modify Dodge</option>
                <option value="ammo">Ammo Change</option>
                <option value="drain_ammo">Drain Ammo From Faction</option>
                <option value="max_ammo">Fill All Ammo to Max</option>
                <option value="disarm">Disarm (Set Ammo to 0)</option>
                <option value="suppress_all">Suppress All Cards</option>
                <option value="suppress_faction">Suppress One Faction</option>
                <option value="clear_suppress">Clear Suppression</option>
                <option value="restore_actions">Restore Actions</option>
                <option value="time_warp">Time Warp (Reset All Actions)</option>
                <option value="random_kill">Random Kill</option>
                <option value="swap_stats">Swap Stats Between Factions</option>
                <option value="equalizer">Equalizer (Average HP)</option>
                <option value="shuffle_hp">Shuffle HP Values</option>
                <option value="buff_random">Random Buff One Card</option>
                <option value="steal_hp">Steal HP (Enemy‚ÜíAlly)</option>
                <option value="glass_cannon">Glass Cannon (+Fire, -HP)</option>
                <option value="fortify">Fortify (-Fire, +HP)</option>
                <option value="shield_all">Shield All (Grant Defending)</option>
                <option value="sudden_death">Sudden Death (All HP ‚Üí 1)</option>
                <option value="coin_flip">Coin Flip (50/50 Heal/Damage)</option>
                <option value="last_stand">Last Stand (Low HP = +Fire)</option>
                <option value="momentum_shift">Momentum Shift (Help Losing Team)</option>
                <option value="vampire_wave">Vampire Wave (Damage All, Heal One)</option>
                <option value="sacrifice">Sacrifice (Kill One, Buff Rest)</option>
                <option value="mirror_match">Mirror Match (Equalize Stats)</option>
                <option value="chain_lightning">Chain Lightning (Decreasing Damage)</option>
                <option value="poison_cloud">Poison Cloud (Damage Over Time)</option>
                <option value="gutshot">Gutshot (Cause Bleeding)</option>
                <option value="fortified">Fortified Position (Building Cover)</option>
                <option value="spawn_card">Reinforcements Arrive!</option>
                <option value="grant_vest">Grant Bulletproof Vests</option>
                <option value="ammo_explosion">Ammo Explosion (Damage = Ammo)</option>
                <option value="bar">BAR - Browning Automatic Rifle</option>
                <option value="marksman">Marksman - Elite Sniper</option>
                <option value="supply_crate">Ammunition Crate</option>
                <option value="molotov">Fire events</option>
                
                
               
            </select>
        </div>
        <div class="form-group" id="evStatGroup" style="display:none">
            <label>Stat to Modify</label>
            <select id="evStat">
                <option value="fire">Fire</option>
                <option value="move">Move</option>
                <option value="dodge">Dodge</option>
                <option value="supp">Suppression</option>
            </select>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Target Faction</label>
                <select id="evFaction">
                    <option value="both">Both Factions</option>
                    <option value="outlaw">Outlaw Only</option>
                    <option value="law">Law Only</option>
                </select>
            </div>
            <div class="form-group">
                <label>Target Count</label>
                <select id="evTargetCount">
                    <option value="all">All Cards</option>
                    <option value="random_one">Random 1 Card</option>
                    <option value="random_two">Random 2 Cards</option>
                    <option value="random_three">Random 3 Cards</option>
                    <option value="lowest_hp">Lowest HP Card</option>
                    <option value="highest_hp">Highest HP Card</option>
                    <option value="lowest_ammo">Lowest Ammo Card</option>
                    <option value="highest_ammo">Highest Ammo Card</option>
                </select>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Value (+/-)</label>
                <input type="number" id="evValue" value="2" min="-10" max="10">
            </div>
        </div>
        <div class="form-group">
            <label>Duration (turns, 0=instant)</label>
            <input type="number" id="evDuration" value="0" min="0" max="5">
        </div>
        <div style="text-align:center;margin-top:16px">
            <button class="btn btn-gold" onclick="saveEvent()">üíæ Save Event</button>
            <button class="btn btn-red" onclick="closeModal('eventCreator')">Cancel</button>
        </div>
    </div>
</div>

<!-- Ability Creator Modal -->
<div id="abilityCreator" class="modal hidden">
    <div class="modal-content" style="max-width:550px">
        <h2>‚ö° CREATE ABILITY</h2>
        <div class="form-group">
            <label>Ability Name</label>
            <input type="text" id="abName" placeholder="Sharpshooter" maxlength="20">
        </div>
        <div class="form-group">
            <label>Icon (emoji)</label>
            <input type="text" id="abIcon" value="‚ö°" maxlength="2">
        </div>
        <div class="form-group">
            <label>Trigger Type</label>
            <select id="abTrigger" onchange="updateAbilityEffectOptions()">
                <option value="on_attack">On Attack - Activates when this card attacks</option>
                <option value="on_defend">On Defend - Activates when this card is attacked</option>
                <option value="on_turn_end">On Turn End - Activates at end of your turn</option>
                <option value="aura">Aura - Affects all allies while on field</option>
            </select>
        </div>
        <div class="form-group">
            <label>Effect</label>
            <select id="abEffect">
                <optgroup label="Attack Effects">
                    <option value="fire_bonus">Add Fire Damage</option>
                    <option value="double_damage">Chance for Double Damage (%)</option>
                    <option value="lifesteal">Lifesteal (% of damage healed)</option>
                    <option value="execute">Execute (kill if target below X% HP)</option>
                    <option value="bonus_vs_undefended">Bonus vs Non-Defending</option>
                    <option value="attack_suppress">Attack Also Suppresses</option>
                    <option value="gutshot">Gutshot - Cause Bleeding</option>
                     <option value="fortify">Fortify - 50% Chance to Entrench</option>
                </optgroup>
                <optgroup label="Defense Effects">
                    <option value="damage_reduction">Reduce Incoming Damage %</option>
                    <option value="reflect">Reflect Damage Back %</option>
                    <option value="dodge_bonus">Bonus Dodge %</option>
                    <option value="revenge">Revenge Damage on Death</option>
                    <option value="survive_lethal">Chance to Survive Lethal %</option>
                </optgroup>
                <optgroup label="Turn End Effects">
                    <option value="heal_self">Heal Self</option>
                    <option value="heal_ally">Heal Random Ally</option>
                    <option value="ammo_regen">Recover Ammo</option>
                    <option value="reduce_ally_suppress">Remove Ally Suppression</option>
                    <option value="expose_enemy">Reduce Enemy Dodge</option>
                </optgroup>
                <optgroup label="Aura Effects">
                    <option value="ally_fire">Allies Get Fire Bonus</option>
                    <option value="ally_dodge">Allies Get Dodge Bonus</option>
                    <option value="ally_move">Allies Get Move Bonus</option>
                    <option value="rally_bonus">Rally Chance Bonus</option>
                    <option value="enemy_fire_reduce">Reduce Enemy Fire</option>
                </optgroup>
            </select>
        </div>
        <div class="form-group">
            <label>Effect Value</label>
            <input type="number" id="abValue" value="2" min="1" max="50">
            <div style="font-size:.75em;color:#888;margin-top:4px" id="abValueHint">Amount of bonus fire damage</div>
        </div>
        <div class="form-group">
            <label>Description (shown in rules)</label>
            <input type="text" id="abDesc" placeholder="Deals +2 fire damage on attacks">
        </div>
        <div style="background:#0d0d12;border:1px solid var(--border);padding:12px;margin:16px 0">
            <div style="color:var(--gold);font-weight:600;margin-bottom:8px">PREVIEW</div>
            <div id="abilityPreview" style="font-size:.9em">
                <span id="abPreviewIcon">‚ö°</span> <strong id="abPreviewName">Sharpshooter</strong><br>
                <span style="color:#888" id="abPreviewDesc">Deals +2 fire damage on attacks</span>
            </div>
        </div>
        <div style="text-align:center;margin-top:16px">
            <button class="btn btn-gold" onclick="saveAbility()">üíæ Save Ability</button>
            <button class="btn btn-blue" onclick="showAbilityList()">üìã View All</button>
            <button class="btn btn-red" onclick="closeModal('abilityCreator')">Cancel</button>
        </div>
    </div>
</div>

<!-- Ability List Modal -->
<div id="abilityList" class="modal hidden">
    <div class="modal-content" style="max-width:500px">
        <h2>üìã CUSTOM ABILITIES</h2>
        <div id="abilityListContent" style="max-height:400px;overflow-y:auto"></div>
        <div style="text-align:center;margin-top:16px">
            <button class="btn btn-gold" onclick="closeModal('abilityList');showAbilityCreator()">+ Create New</button>
            <button class="btn btn-blue" onclick="closeModal('abilityList')">Close</button>
        </div>
    </div>
</div>

<!-- Deck Builder -->
<div id="deckBuilder" class="modal hidden">
    <div class="modal-content" style="max-width:800px">
        <h2>üì¶ DECK BUILDER</h2>
        <div class="faction-tabs">
            <div class="faction-tab active" onclick="switchDeckFaction('outlaw')">üî´ Outlaw Deck</div>
            <div class="faction-tab" onclick="switchDeckFaction('law')">üöî Law Deck</div>
        </div>
        <div class="deck-builder-grid">
            <div>
                <h3 style="color:var(--gold);margin-bottom:8px">Available Cards</h3>
                <div class="card-pool" id="cardPool"></div>
            </div>
            <div class="current-deck">
                <h3 style="color:var(--gold);margin-bottom:8px">Current Deck (<span id="deckCount">0</span>/20)</h3>
                <div class="deck-list" id="deckList"></div>
                <div style="margin-top:12px;text-align:center">
                    <button class="btn btn-gold" onclick="saveDeck()">üíæ Save Deck</button>
                    <button class="btn btn-red" onclick="clearDeck()">üóëÔ∏è Clear</button>
                </div>
            </div>
        </div>
        <div style="text-align:center;margin-top:16px;display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
            <button class="btn btn-green" onclick="exportDecks()">üì§ Export All</button>
            <button class="btn btn-green" onclick="importDecks()">üì• Import</button>
            <button class="btn btn-blue" onclick="closeModal('deckBuilder')">Close</button>
        </div>
    </div>
</div>

<!-- Combat Results Panel -->
<div id="combatPanel" class="combat-panel hidden">
    <div class="combat-header" id="combatHeader">‚öîÔ∏è COMBAT ‚öîÔ∏è</div>
    <div class="combat-body">
        <div class="combat-card attacker" id="combatAttacker">
            <div class="combat-portrait" id="attackerPortrait">ü§†</div>
            <div class="combat-name" id="attackerName">Attacker</div>
            <div class="combat-hp">
                <span id="attackerHP">10/10 HP</span>
                <div class="combat-hp-bar"><div class="combat-hp-fill healthy" id="attackerHPBar" style="width:100%"></div></div>
            </div>
            <div style="margin-top:8px;font-size:.8em">
                <span class="stat-ammo" id="attackerAmmo">Ammo: 6</span>
            </div>
        </div>
        <div class="combat-vs" id="combatVs">‚öîÔ∏è</div>
        <div class="combat-card defender" id="combatDefender">
            <div class="combat-portrait" id="defenderPortrait">üëÆ</div>
            <div class="combat-name" id="defenderName">Defender</div>
            <div class="combat-hp">
                <span id="defenderHP">10/10 HP</span>
                <div class="combat-hp-bar"><div class="combat-hp-fill healthy" id="defenderHPBar" style="width:100%"></div></div>
            </div>
            <div style="margin-top:8px;font-size:.8em" id="defenderStatus"></div>
        </div>
    </div>
    <div class="combat-result">
        <div class="combat-damage" id="combatDamage">-5 HP</div>
        <div class="combat-effects" id="combatEffects"></div>
        <div class="combat-breakdown" id="combatBreakdown"></div>
        <button class="btn btn-gold" onclick="closeCombat()">Continue</button>
    </div>
</div>

<!-- Event Results Panel -->
<div id="eventPanel" class="event-panel hidden">
    <div class="event-header" id="eventPanelHeader">üé≤ RANDOM EVENT üé≤</div>
    <div class="event-body">
        <div class="event-description" id="eventPanelDesc">Something happened!</div>
        <div class="event-affects">
            <h4>AFFECTED UNITS:</h4>
            <div id="eventAffectedList"></div>
        </div>
    </div>
    <div class="event-footer">
        <button class="btn btn-gold" onclick="closeEventPanel()">Continue</button>
    </div>
</div>

<!-- Rally Panel -->
<div id="rallyPanel" class="rally-panel hidden">
    <div class="rally-header">üî• RALLY ATTEMPT üî•</div>
    <div class="rally-body">
        <div id="rallyCard"></div>
        <div class="rally-chance" id="rallyChance">75%</div>
        <div class="rally-meter"><div class="rally-fill" id="rallyFill" style="width:0%"></div></div>
        <div class="rally-result hidden" id="rallyResult">SUCCESS!</div>
        <div id="rallyDetails" style="font-size:.85em;color:#aaa;margin:12px 0"></div>
        <button class="btn btn-gold" id="rallyBtn" onclick="executeRally()">Roll for Rally!</button>
        <button class="btn btn-blue" id="rallyCancelBtn" onclick="closeRally()">Cancel</button>
        <button class="btn btn-gold hidden" id="rallyContinueBtn" onclick="closeRally()">Continue</button>
    </div>
</div>

<!-- Scavenge Panel -->
<div id="scavengePanel" class="scavenge-panel hidden">
    <div class="scavenge-header" id="scavengeHeader">üîç SCAVENGE üîç</div>
    <div class="scavenge-body">
        <div id="scavengeCard"></div>
        <div class="scavenge-result" id="scavengeResult">SEARCHING...</div>
        <div class="scavenge-ammo" id="scavengeAmmo"></div>
        <div id="scavengeDetails" style="font-size:.85em;color:#aaa;margin:12px 0"></div>
        <div id="scavengeBreakdown" style="background:#0d0d12;border:1px solid var(--border);padding:12px;margin:12px 0;text-align:left;font-size:.85em"></div>
        <button class="btn btn-blue" onclick="closeScavenge()">Continue</button>
    </div>
</div>

<!-- Event Banner -->
<div id="eventBanner" class="event-banner hidden">
    <h2 id="eventTitle">üé≤ RANDOM EVENT</h2>
    <p id="eventDesc">Something happened!</p>
    <button class="btn btn-gold" onclick="dismissEvent()">Continue</button>
</div>

<!-- Victory Screen -->
<div id="victoryScreen" class="victory-screen hidden">
    <h1 id="victoryTitle">VICTORY!</h1>
    <div class="victory-stats">
        <p id="victoryStats"></p>
    </div>
    <button class="btn btn-gold menu-btn" onclick="returnToMenu()">Return to Menu</button>
</div>

<!-- Event Trigger Modal -->
<div id="eventTriggerModal" class="modal hidden">
    <div class="modal-content" style="max-width:700px">
        <h2>üé≤ TRIGGER EVENT</h2>
        <p style="color:#888;font-size:.85em;margin-bottom:12px;text-align:center">Select an event to trigger manually (once per turn, both players share this limit)</p>
        <div id="eventTriggerList" style="max-height:450px;overflow-y:auto;border:1px solid var(--border);padding:8px;background:#0d0d12"></div>
        <div style="text-align:center;margin-top:16px">
            <button class="btn btn-blue" onclick="closeModal('eventTriggerModal')">Cancel</button>
        </div>
    </div>
</div>

<!-- Rules Modal -->
<div id="rulesModal" class="modal hidden">
    <div class="modal-content" style="max-width:750px">
        <h2>üìú HOW TO PLAY</h2>
        <div style="font-size:.85em;line-height:1.7;max-height:70vh;overflow-y:auto;padding-right:10px">
           
            <p><strong style="color:var(--gold);font-size:1.1em">‚≠ê OBJECTIVE</strong></p>
            <p>Choose your side: the infamous <strong style="color:#f87171">Outlaw Gang</strong> or <strong style="color:#60a5fa">The Law</strong>. Victory is achieved by either eliminating all enemy cards (deck, hand, and field) OR reaching <strong>10 victory points</strong> first. You earn 1 point each time you eliminate an enemy card.</p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">üéÆ GAME SETUP</strong></p>
            <p>Each player starts with a deck of cards. At game start, both players draw <strong>4 cards</strong> into their hand. The Outlaw faction always goes first. You can play against the <strong>AI opponent</strong> (Easy/Medium/Hard difficulty) or play hot-seat with a friend.</p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">üîÑ TURN STRUCTURE</strong></p>
            <p>On your turn, you may perform actions in any order:</p>
            <p>1. <strong>Deploy</strong> - Play cards from your hand onto the battlefield (max 6 cards on field).</p>
            <p>2. <strong>Take Actions</strong> - Each card has <span class="stat-move">Move</span> points for actions: Attack, Suppress, Defend, Scavenge, Share Ammo, or Rally.</p>
            <p>3. <strong>End Turn</strong> - Click "End Turn" when finished. Turn-end abilities trigger, then control passes to opponent.</p>
            <p>At the start of each new round (after both players go), there's an <strong>85% chance of a Random Event</strong>!</p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">üìä CARD STATS</strong></p>
            <p><span class="stat-hp">‚ô• HP</span> - Health Points. At 0, the card is eliminated. Some abilities can save you at 1 HP!</p>
            <p><span class="stat-ammo">üî∏ Ammo</span> - Required for attacks (1) and suppression (50% of current). Scavenge to recover.</p>
            <p><span class="stat-move">‚ö° Move</span> - Actions per turn. Event modifiers and auras can increase/decrease this.</p>
            <p><span class="stat-fire">üî• Fire</span> - Base damage. Modified by abilities, auras, and events. Shown in green/red when buffed/debuffed.</p>
            <p><span class="stat-supp">üíú Supp</span> - Suppression value applied to enemies, reducing their next turn's actions.</p>
            <p><span class="stat-dodge">üåÄ Dodge</span> - % chance to avoid attacks entirely. Capped at 95%.</p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">‚öîÔ∏è ACTIONS</strong></p>
           
            <p><strong style="color:#f87171">üî´ ATTACK</strong> (1 Move, 1 Ammo)</p>
            <p>Select card ‚Üí Attack ‚Üí Click enemy. Dodge is checked first. Damage = Fire + ability bonuses + aura bonuses + event mods - defense reductions. Multiple abilities can trigger: Execute, Lifesteal, Double Tap, Suppressor, etc.</p>
           
            <p><strong style="color:#6b5b95">ü´• HIDE</strong> (2 Move)</p>
            <p>Retreat card back to hand. <strong>Team-wide +2 suppression penalty</strong> ‚Äî high-risk escape!</p>
           
            <p style="margin-top:12px"><strong style="color:#60a5fa">üíú SUPPRESS</strong> (1 Move, 50% Ammo)</p>
            <p>Laying covering fire. Your Supp value reduces enemy's Move next turn. Stacks from multiple sources!</p>
           
            <p style="margin-top:12px"><strong style="color:#40916c">üõ°Ô∏è DEFEND</strong> (All Move)</p>
            <p>50% damage reduction until your next turn. Uses ALL remaining actions.</p>
           
            <p style="margin-top:12px"><strong style="color:#2d5a4a">ü™® TAKE COVER</strong> (2 Move, 2 Turns)</p>
            <p>Hunker down for maximum protection. Costs 2 actions. +2 HP instantly, +50% Defend, <strong>+75% Cover reduction</strong>, -10% Dodge. Fire/Supp halved while in cover. AI avoids shooting covered targets!</p>
           
            <p style="margin-top:12px"><strong style="color:#1a4a5e">üîç SCAVENGE</strong> (1 Move)</p>
            <p>Search for ammo. Base 50% success, +5% per missing ammo. Finds 1-3 rounds on success.</p>
           
            <p style="margin-top:12px"><strong style="color:#5a4a1a">üì¶ SHARE AMMO</strong> (Half Move, +1 Suppression)</p>
            <p>Give 1-3 ammo to an ally. Leaves you exposed with suppression penalty.</p>
           
            <p style="margin-top:12px"><strong style="color:#d97706">üî• RALLY</strong> (Free, 1/turn)</p>
            <p>For exhausted or suppressed cards. Chance = 15% base + HP% bonus + Ammo% bonus + aura bonuses - suppression penalty. <strong>Team Rally</strong> clears ALL ally suppression. <strong>Self Rally</strong> restores 1-2 actions.</p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">‚ú® ABILITIES (20 Types)</strong></p>
            <p>Cards can have <strong>up to 3 abilities</strong>. Hover over ability icons to see descriptions.</p>
           
            <p style="margin-top:8px"><strong style="color:#f87171">Combat Abilities (on attack):</strong></p>
            <p style="margin-left:12px">
                <span style="color:#facc15">‚ö° Quickdraw</span> +1 Fire |
                <span style="color:#facc15">üéØ Sniper</span> +2 Fire |
                <span style="color:#facc15">üéØ Double Tap</span> 25% double damage |
                <span style="color:#facc15">ü©∏ Bloodthirsty</span> 50% lifesteal |
                <span style="color:#facc15">üíÄ Executioner</span> Kills below 25% HP |
                <span style="color:#facc15">üî¥ Hollow Point</span> +3 vs undefended |
                <span style="color:#facc15">üîá Suppressor</span> Attacks suppress
            </p>
           
            <p style="margin-top:8px"><strong style="color:#60a5fa">Defensive Abilities (when attacked):</strong></p>
            <p style="margin-left:12px">
                <span style="color:#facc15">üõ°Ô∏è Tough</span> 50% damage reduction |
                <span style="color:#facc15">ü¶∫ Bulletproof</span> 30% reduction |
                <span style="color:#facc15">üí® Slippery</span> +15% dodge |
                <span style="color:#facc15">‚Ü©Ô∏è Counter Shot</span> Reflects 50% damage |
                <span style="color:#facc15">üíî Last Breath</span> Deals 4 damage on death |
                <span style="color:#facc15">üîí Iron Will</span> 33% survive at 1 HP
            </p>
           
            <p style="margin-top:8px"><strong style="color:#40916c">Turn End Abilities:</strong></p>
            <p style="margin-left:12px">
                <span style="color:#facc15">üíä Medic</span> Heals ally 2 HP |
                <span style="color:#facc15">üè• Field Medic</span> Heals self 1 HP |
                <span style="color:#facc15">üîç Scavenger</span> +1 ammo |
                <span style="color:#facc15">üìã Tactician</span> Removes ally suppression |
                <span style="color:#facc15">üëÅÔ∏è Informant</span> Reduces enemy dodge
            </p>
           
            <p style="margin-top:8px"><strong style="color:#9b6bcc">Aura Abilities (passive, affects team):</strong></p>
            <p style="margin-left:12px">
                <span style="color:#facc15">‚≠ê Leader</span> +1 Fire to allies |
                <span style="color:#facc15">üì£ Sergeant</span> +15% Rally chance |
                <span style="color:#facc15">üò† Intimidating</span> Enemies deal -1 Fire |
                <span style="color:#facc15">üéñÔ∏è Inspiring</span> +5% dodge to allies |
                <span style="color:#facc15">üì° Coordinator</span> +1 Move to allies
            </p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">üé≤ RANDOM EVENTS (115+ Events)</strong></p>
            <p>Events trigger at round start (85% chance). Categories include:</p>
            <p style="margin-left:12px">
                <strong>Damage</strong> - Direct damage, execute wounded, target highest/lowest HP<br>
                <strong>Healing</strong> - Heal all, heal faction, full heal one, triage wounded<br>
                <strong>Ammo</strong> - Supply drops, shortages, ammo drain, max ammo<br>
                <strong>Stat Mods</strong> - Temporary Fire/Move/Dodge changes (shown green/red on cards)<br>
                <strong>Suppression</strong> - Mass suppression, crossfire, clear suppression<br>
                <strong>Chaos</strong> - HP shuffle, stat swap, equalizer, sudden death (all to 1 HP!)<br>
                <strong>Special</strong> - Coin flip (heal or damage), chain lightning, vampire wave, sacrifice, poison cloud (damage over time), ammo explosion
            </p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">ü§ñ AI OPPONENT</strong></p>
            <p>Play against the computer on Easy, Medium, or Hard difficulty. The AI deploys cards, attacks intelligently, uses suppression, and even attempts rallies. AI actions are shown in combat panels - click Continue to proceed. If the game hangs, use the <strong style="color:#f87171">‚ö†Ô∏è Force</strong> button to skip to the next turn.</p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">üèóÔ∏è CUSTOMIZATION</strong></p>
            <p><strong>Card Creator</strong> - Design custom cards with up to 3 abilities each.</p>
            <p><strong>Ability Creator</strong> - Create new abilities with 21 different effect types.</p>
            <p><strong>Event Creator</strong> - Design custom random events with 30+ effect types.</p>
            <p><strong>Deck Builder</strong> - Build 20-card decks, max 3 copies per card. Export/Import as JSON.</p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">üìä NERD STATS</strong></p>
            <p>Track detailed statistics in the side panels: Damage Dealt/Taken, Shots Fired/Hit, Accuracy %, Cards Eliminated, Ammo Used, Rallies Attempted/Successful.</p>
           
            <p style="margin-top:16px"><strong style="color:var(--gold);font-size:1.1em">üí° STRATEGY TIPS</strong></p>
            <p>‚Ä¢ <strong>Multi-Ability Cards</strong> - Cards like Frank Hamer (Sniper+Executioner+Intimidating) are high-value targets.</p>
            <p>‚Ä¢ <strong>Coordinator Aura</strong> - +1 Move to all allies is extremely powerful. Protect them!</p>
            <p>‚Ä¢ <strong>Counter Builds</strong> - Use Intimidating to reduce enemy Fire, Iron Will to survive bursts.</p>
            <p>‚Ä¢ <strong>Suppression Chains</strong> - Stack suppression to completely lock down threats.</p>
            <p>‚Ä¢ <strong>Watch for Events</strong> - Sudden Death sets everyone to 1 HP. Poison ticks each round.</p>
            <p>‚Ä¢ <strong>Scavenge Early</strong> - Don't wait until you're empty to recover ammo.</p>
            <p>‚Ä¢ <strong>Last Breath Deterrent</strong> - Enemies may avoid killing your Last Breath cards.</p>
           
        </div>
        <div style="text-align:center;margin-top:16px">
            <button class="btn btn-gold" onclick="closeModal('rulesModal')">Got It!</button>
        </div>
    </div>
</div>

<script>
// Force CSS animations to be ready
let cssAnimationsReady = false;
setTimeout(() => { cssAnimationsReady = true; }, 200);

// ============ GAME STATE ============
const G = {
    turn: 'outlaw',
    phase: 'deploy',
    round: 1,
    bankRobberyMode: false,
    scores: { outlaw: 0, law: 0 },
    field: { outlaw: [], law: [] },
    hands: { outlaw: [], law: [] },
    decks: { outlaw: [], law: [] },
    selected: null,
    actionMode: null,
    events: [],
    activeEvents: [],
    activeDynamite: null,
    abilities: {},
    rallyUsedThisTurn: false,
    manualEventUsed: false,
    // AI Settings
    aiEnabled: false,
    aiFaction: 'law', // Which faction the AI controls
    aiDifficulty: 'medium', // easy, medium, hard
    aiThinking: false, // Prevents UI interaction during AI turn
    aiWaitingResolve: null, // Promise resolver for panel dismissal
    aiWaitingPanel: null, // Which panel AI is waiting for
    // Nerd Stats
    stats: {
        outlaw: { dmgDealt: 0, dmgTaken: 0, shotsFired: 0, shotsHit: 0, kills: 0, ammoUsed: 0, rallies: 0, rallySuccess: 0 },
        law: { dmgDealt: 0, dmgTaken: 0, shotsFired: 0, shotsHit: 0, kills: 0, ammoUsed: 0, rallies: 0, rallySuccess: 0 }
    }
};

// ============ SOUND SYSTEM ============
const SOUNDS = {
    // Arrays allow multiple sounds per action (plays random one)
    attack: [
        // Add GitHub raw URLs here, e.g.:
        'https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/f4821bbe845332f46f3784a9a28e414ea2e2efab/Heavy%20Machine%20Gun%20Fire%20Sound%20Effect.mp3'
    ],
    suppress: [
     'https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/506e988ae46e8378841aeb142df90e8b28477642/Suppress.mp3', 'https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/2e12994ceee8e2adc04b2a5e40979829505af0bd/Suppress3.mp3'
    ],
    endTurn: [
        // 'https://raw.githubusercontent.com/USERNAME/REPO/main/sounds/endturn1.mp3',
    ],
    signal_charge: ['https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/565fa13381310865d2f74632b914052285c7ddc3/SigCharge.mp3'], 
    hit: [],
    miss: [],
    dynamite_fuse: ['https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/257a9aaeaef546eac977618c99adb575f82c6561/Fuse.mp3'],
    dynamite_explode: ['https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/257a9aaeaef546eac977618c99adb575f82c6561/Dynamite.mp3'],
    kill: ['https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/c60b132a653cb7f031a101a0ae7fe8945601d45a/Kill(1).mp3'],
    grenade: ['https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/e6e6856916182f4e934758624df586128bc7931c/Grenade.mp3'],
    arrest: ['https://raw.githubusercontent.com/YOUR_REPO/YOUR_BRANCH/handcuffs.mp3'],
    defend: [],
    cover: [],
    scavenge: [],
    rally: [],
    roadblock: ['https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/3d10d04e770c72bdbcdb3b38b2f060a3f146031c/Car%20brake%20and%20crash%20Sound%20Effect%20-%20Audio%20Vampire.mp3'],
    molotov: ['https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/1004a482adb4cc1cf18d8cd1907382b6ce556209/The%20sound%20of%20a%20falling%20Molotov%20cocktail%20%20Sound%20effect%20(HD).mp3'],
    marksman: ['https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/068b310273afb33fdfdd423cc925ea5790b9fe2a/KaySniper.mp3'],
    event: [],
    deploy: [],
    victory: [],
    defeat: [],
};

// RADIO - plays random songs from your list, picks new one when current ends
let radioEnabled = false;
let currentRadioTrack = null;

const RADIO_SONGS = [
    'https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/477c7767686ab8932f88da4359706ab1dd475815/Cab%20Calloway%20-%20Minnie%20the%20Moocher%20(%20Remastered%20720p%20).mp3',
    'https://raw.githubusercontent.com/ourdidjourney-maker/KatysRealmV2/477c7767686ab8932f88da4359706ab1dd475815/Radio3.mp3'
    // ‚Üê Add more URLs here anytime ‚Äî it will randomly cycle through all of them
];

function toggleRadio() {
    radioEnabled = !radioEnabled;
    const status = document.getElementById('radioStatus');
    if (status) status.textContent = radioEnabled ? '(ON)' : '(OFF)';

    if (radioEnabled) {
        // Stop anything playing
        if (currentRadioTrack) {
            currentRadioTrack.pause();
            currentRadioTrack = null;
        }
        playNextRadioTrack(); // Start fresh random track
    } else {
        if (currentRadioTrack) {
            currentRadioTrack.pause();
            currentRadioTrack = null;
        }
    }
}

function playNextRadioTrack() {
    if (!radioEnabled) return;

    // Pick a NEW random song every time
    const url = RADIO_SONGS[Math.floor(Math.random() * RADIO_SONGS.length)];

    currentRadioTrack = new Audio(url);
    currentRadioTrack.loop = false;          // ‚Üê Changed: no infinite loop on one track
    currentRadioTrack.volume = 0.90;
    
    currentRadioTrack.play().catch(e => {
    });

    // When THIS track naturally ends, play a new random one (cycle!)
    currentRadioTrack.onended = () => {
        if (radioEnabled) {
            playNextRadioTrack();
        }
    };
}

let soundEnabled = true;
let soundVolume = 0.5;

function playSound(category) {
    if (!soundEnabled) return;
    const sounds = SOUNDS[category];
    if (!sounds || sounds.length === 0) return;
   
    // Pick random sound from category
    const url = sounds[Math.floor(Math.random() * sounds.length)];
    try {
        const audio = new Audio(url);
        audio.volume = soundVolume;
        audio.play().catch(e => console.log('Sound play failed:', e));
    } catch (e) {
    }
}

function toggleSound() {
    soundEnabled = !soundEnabled;
    $('btnSound').textContent = soundEnabled ? 'üîä' : 'üîá';
    log(soundEnabled ? 'üîä Sound ON' : 'üîá Sound OFF', G.turn);
}

// ============ DEFAULT CARDS ============
const DEFAULT_CARDS = {
    outlaw: [
{ id: 'bonnie', name: 'Bonnie Parker', portrait: 'üë©', hp: 12, maxHp: 12, ammo: 6, maxAmmo: 6, move: 3, fire: 4, supp: 2, dodge: 20, cost: 4, abilities: ['quickdraw', 'slippery'], accuracy: 100, faction: 'outlaw' },
        { id: 'clyde', name: 'Clyde Barrow', portrait: 'ü§µ', hp: 14, maxHp: 14, ammo: 8, maxAmmo: 8, move: 2, fire: 5, supp: 3, dodge: 15, cost: 5, abilities: ['leader', 'doubletap'], faction: 'outlaw' },
        { id: 'buck', name: 'Buck Barrow', portrait: 'üßî', hp: 10, maxHp: 10, ammo: 6, maxAmmo: 6, move: 2, fire: 3, supp: 2, dodge: 10, cost: 3, abilities: ['tough', 'lastbreath'], faction: 'outlaw' },
        { id: 'blanche', name: 'Blanche Barrow', portrait: 'üë±‚Äç‚ôÄÔ∏è', hp: 8, maxHp: 8, ammo: 4, maxAmmo: 4, move: 3, fire: 2, supp: 1, dodge: 25, cost: 2, abilities: ['medic'], faction: 'outlaw' },
        { id: 'jones', name: 'W.D. Jones', portrait: 'ü§†', hp: 9, maxHp: 9, ammo: 5, maxAmmo: 5, move: 3, fire: 3, supp: 2, dodge: 15, cost: 3, abilities: ['scavenger'], faction: 'outlaw' },
        { id: 'hamilton', name: 'Ray Hamilton', portrait: 'üòé', hp: 11, maxHp: 11, ammo: 7, maxAmmo: 7, move: 2, fire: 4, supp: 2, dodge: 12, cost: 4, abilities: ['sniper', 'executioner'], faction: 'outlaw' },
        { id: 'methvin', name: 'Henry Methvin', portrait: 'üß¢', hp: 8, maxHp: 8, ammo: 5, maxAmmo: 5, move: 4, fire: 2, supp: 1, dodge: 30, cost: 2, abilities: ['informant'], faction: 'outlaw' },
        { id: 'thug1', name: 'Gang Member', portrait: 'üíÄ', hp: 6, maxHp: 6, ammo: 4, maxAmmo: 4, move: 2, fire: 2, supp: 1, dodge: 10, cost: 1, abilities: [], faction: 'outlaw' },
         { id: 'v8car', name: 'V8 Ford', portrait: 'üöó', hp: 20, maxHp: 20, ammo: 15, maxAmmo: 15, move: 4, fire: 0, supp: 0, dodge: 85, cost: 6, abilities: ['ram'], faction: 'outlaw', isVehicle: true, passengers: [], maxPassengers: 3 },{ id: 'forest', name: 'Dense Forest', portrait: 'üå≤', hp: 999, maxHp: 999, ammo: 0, maxAmmo: 0, move: 0, fire: 0, supp: 0, dodge: 0, cost: 3, abilities: [], faction: 'outlaw', isEnvironment: true },
    ],
    law: [
        { id: 'hamer', name: 'Frank Hamer', portrait: 'ü§†', hp: 15, maxHp: 15, ammo: 8, maxAmmo: 8, move: 2, fire: 5, supp: 3, dodge: 10, cost: 5, abilities: ['sniper', 'executioner', 'intimidate'], faction: 'law' },
        { id: 'gault', name: 'Manius Gault', portrait: 'üëÆ', hp: 12, maxHp: 12, ammo: 6, maxAmmo: 6, move: 2, fire: 4, supp: 2, dodge: 12, cost: 4, abilities: ['tough', 'bulletproof'], faction: 'law' },
        { id: 'alcorn', name: 'Bob Alcorn', portrait: 'üïµÔ∏è', hp: 10, maxHp: 10, ammo: 6, maxAmmo: 6, move: 3, fire: 3, supp: 2, dodge: 18, cost: 3, abilities: ['slippery'], faction: 'law' },
        { id: 'jordan', name: 'Henderson Jordan', portrait: '‚≠ê', hp: 11, maxHp: 11, ammo: 5, maxAmmo: 5, move: 2, fire: 4, supp: 3, dodge: 12, cost: 4, abilities: ['leader', 'sergeant'], faction: 'law' },
        { id: 'oakley', name: 'Prentiss Oakley', portrait: 'üéØ', hp: 9, maxHp: 9, ammo: 7, maxAmmo: 7, move: 2, fire: 4, supp: 1, dodge: 15, cost: 3, abilities: ['quickdraw', 'hollowpoint'], faction: 'law' },
        { id: 'hinton', name: 'Ted Hinton', portrait: 'üì∏', hp: 10, maxHp: 10, ammo: 6, maxAmmo: 6, move: 3, fire: 3, supp: 2, dodge: 15, cost: 3, abilities: ['tactician'], faction: 'law' },
        { id: 'deputy1', name: 'Deputy', portrait: 'üëÆ‚Äç‚ôÇÔ∏è', hp: 7, maxHp: 7, ammo: 4, maxAmmo: 4, move: 2, fire: 2, supp: 2, dodge: 10, cost: 2, abilities: [], faction: 'law' },
        { id: 'deputy2', name: 'State Trooper', portrait: 'üöî', hp: 8, maxHp: 8, ammo: 5, maxAmmo: 5, move: 3, fire: 3, supp: 1, dodge: 12, cost: 2, abilities: ['fieldmedic'], faction: 'law' },
        { id: 'v8car', name: 'V8 Ford', portrait: 'üöó', hp: 20, maxHp: 20, ammo: 15, maxAmmo: 15, move: 4, fire: 0, supp: 0, dodge: 85, cost: 6, abilities: ['ram'], faction: 'law', isVehicle: true, passengers: [], maxPassengers: 3 },
         { id: 'forest', name: 'Dense Forest', portrait: 'üå≤', hp: 999, maxHp: 999, ammo: 0, maxAmmo: 0, move: 0, fire: 0, supp: 0, dodge: 0, cost: 3, abilities: [], faction: 'law', isEnvironment: true }
    ]
};

// ============ DEFAULT EVENTS ============
const DEFAULT_EVENTS = [
    // === DAMAGE EVENTS ===
    { name: 'Ambush!', desc: 'Gunfire erupts from the treeline!', type: 'damage_all', faction: 'both', value: 2, duration: 0 },
    { name: 'Dynamite!', desc: 'An explosion rocks the battlefield!', type: 'damage_all', faction: 'both', value: 3, duration: 0 },
    { name: 'Ricochets', desc: 'Bullets bounce off the walls!', type: 'damage_all', faction: 'both', value: 1, duration: 0 },
    { name: 'Sniper Shot!', desc: 'A hidden sniper takes out a random target!', type: 'random_kill', faction: 'both', value: 0, duration: 0 },
    { name: 'Collateral Damage', desc: 'Stray bullets hit everyone!', type: 'damage_all', faction: 'both', value: 1, duration: 0 },
    { name: 'Execute the Weak', desc: 'Finish off the wounded!', type: 'execute_wounded', faction: 'both', value: 3, duration: 0 },
    { name: 'Take Down the Leader', desc: 'Attack the strongest!', type: 'damage_highest_hp', faction: 'both', value: 3, duration: 0 },
   
    // === FACTION-SPECIFIC DAMAGE ===
    { name: 'Police Raid!', desc: 'Law enforcement strikes hard!', type: 'damage_faction', faction: 'outlaw', value: 3, duration: 0 },
    { name: 'Gang Retaliation', desc: 'The outlaws strike back!', type: 'damage_faction', faction: 'law', value: 3, duration: 0 },
    { name: 'FBI Assault', desc: 'Federal agents attack!', type: 'damage_faction', faction: 'outlaw', value: 4, duration: 0 },
    { name: 'Outlaw Vengeance', desc: 'The gang shows no mercy!', type: 'damage_faction', faction: 'law', value: 4, duration: 0 },
   
    // === HEALING EVENTS ===
    { name: 'Doc Arrives', desc: 'A traveling doctor patches wounds.', type: 'heal_all', faction: 'both', value: 3, duration: 0 },
    { name: 'Field Medicine', desc: 'Everyone patches up!', type: 'heal_all', faction: 'both', value: 2, duration: 0 },
    { name: 'Miracle Recovery', desc: 'Someone makes a full recovery!', type: 'full_heal_one', faction: 'both', value: 0, duration: 0 },
    { name: 'Triage', desc: 'Help the most wounded!', type: 'heal_lowest_hp', faction: 'both', value: 5, duration: 0 },
    { name: 'Combat Medic', desc: 'Quick medical attention for all!', type: 'heal_all', faction: 'both', value: 1, duration: 0 },
    { name: 'Police Backup', desc: 'Reinforcements boost law morale!', type: 'heal_faction', faction: 'law', value: 4, duration: 0 },
    { name: 'Gang Hideout', desc: 'The outlaws find a safe house!', type: 'heal_faction', faction: 'outlaw', value: 4, duration: 0 },
    { name: 'Law Infirmary', desc: 'Officers get medical treatment!', type: 'heal_faction', faction: 'law', value: 3, duration: 0 },
    { name: 'Outlaw Camp', desc: 'The gang rests and recovers!', type: 'heal_faction', faction: 'outlaw', value: 3, duration: 0 },
   
    // === AMMO EVENTS ===
    { name: 'Supply Drop', desc: 'Fresh ammunition arrives!', type: 'ammo', faction: 'both', value: 3, duration: 0 },
    { name: 'Ammo Cache', desc: 'A hidden stash is found!', type: 'ammo', faction: 'both', value: 4, duration: 0 },
    { name: 'Ammo Shortage', desc: 'Supplies are running low!', type: 'ammo', faction: 'both', value: -2, duration: 0 },
    { name: 'Damp Powder', desc: 'Rain ruins some ammunition!', type: 'ammo', faction: 'both', value: -1, duration: 0 },
    { name: 'Gun Runner', desc: 'A smuggler sells ammo!', type: 'ammo', faction: 'both', value: 2, duration: 0 },
    { name: 'Evidence Seized', desc: 'Law confiscates outlaw ammo!', type: 'drain_ammo', faction: 'outlaw', value: 2, duration: 0 },
    { name: 'Armory Raid', desc: 'Outlaws steal police ammo!', type: 'drain_ammo', faction: 'law', value: 2, duration: 0 },
    { name: 'Arms Dealer', desc: 'Black market weapons!', type: 'ammo', faction: 'outlaw', value: 3, duration: 0 },
    { name: 'Military Surplus', desc: 'Government supplies arrive!', type: 'ammo', faction: 'law', value: 3, duration: 0 },
   
     // === EQUIPMENT EVENTS ===
    { name: 'Bulletproof Vests', desc: 'Body armor located!!', type: 'grant_vest', faction: 'both', value: 0, duration: 0 },
   
    // === STAT MODIFIER EVENTS ===
    { name: 'Dust Storm', desc: 'A blinding dust storm reduces accuracy!', type: 'stat_mod', stat: 'fire', faction: 'both', value: -1, duration: 2 },
    { name: 'Clear Skies', desc: 'Perfect conditions for shooting!', type: 'stat_mod', stat: 'fire', faction: 'both', value: 1, duration: 2 },
    { name: 'Adrenaline Rush', desc: 'Everyone moves faster!', type: 'stat_mod', stat: 'move', faction: 'both', value: 1, duration: 2 },
    { name: 'Exhaustion', desc: 'Fatigue slows everyone down!', type: 'stat_mod', stat: 'move', faction: 'both', value: -1, duration: 2 },
    { name: 'Thick Fog', desc: 'Dense fog makes everyone harder to hit.', type: 'stat_mod', stat: 'dodge', faction: 'both', value: 15, duration: 2 },
    { name: 'Moonless Night', desc: 'Darkness provides cover!', type: 'stat_mod', stat: 'dodge', faction: 'both', value: 10, duration: 2 },
    { name: 'Bright Daylight', desc: 'No place to hide!', type: 'stat_mod', stat: 'dodge', faction: 'both', value: -10, duration: 2 },
    { name: 'Rage!', desc: 'Fury increases firepower!', type: 'stat_mod', stat: 'fire', faction: 'both', value: 2, duration: 1 },
    { name: 'Shaky Hands', desc: 'Nerves affect accuracy!', type: 'stat_mod', stat: 'fire', faction: 'both', value: -2, duration: 1 },
        { name: 'Shaky Hands', desc: 'Miscreants light up a marlboro - Steady hands!', type: 'stat_mod', stat: 'fire', faction: 'outlaw', value: 2, duration: 3 },
   
   
    // === FACTION STAT MODS ===
    { name: 'Flat Tire', desc: 'The getaway car has a flat!', type: 'stat_mod', stat: 'move', faction: 'outlaw', value: -1, duration: 1 },
    { name: 'Roadblock', desc: 'Police set up a roadblock!', type: 'stat_mod', stat: 'move', faction: 'law', value: -1, duration: 1 },
    { name: 'Outlaw Fury', desc: 'The gang is enraged!', type: 'stat_mod', stat: 'fire', faction: 'outlaw', value: 2, duration: 2 },
    { name: 'Police Training', desc: 'Officers aim true!', type: 'stat_mod', stat: 'fire', faction: 'law', value: 2, duration: 2 },
    { name: 'Wanted Posters', desc: 'Outlaws are recognized!', type: 'stat_mod', stat: 'dodge', faction: 'outlaw', value: -10, duration: 2 },
    { name: 'Civilian Clothes', desc: 'Officers blend in!', type: 'stat_mod', stat: 'dodge', faction: 'law', value: 10, duration: 2 },
    { name: 'Liquid Courage', desc: 'Outlaws are feeling bold!', type: 'stat_mod', stat: 'dodge', faction: 'outlaw', value: -5, duration: 1 },
    { name: 'Tactical Formation', desc: 'Police coordinate!', type: 'stat_mod', stat: 'fire', faction: 'law', value: 1, duration: 3 },
   
    // === SUPPRESSION EVENTS ===
    { name: 'Suppressing Fire!', desc: 'Bullets fly everywhere, pinning everyone down!', type: 'suppress_all', faction: 'both', value: 1, duration: 0 },
    { name: 'Heavy Gunfire', desc: 'Intense fire pins everyone!', type: 'suppress_all', faction: 'both', value: 2, duration: 0 },
    { name: 'Smoke Grenades', desc: 'Smoke covers the battlefield, breaking suppression!', type: 'clear_suppress', faction: 'both', value: 0, duration: 0 },
    { name: 'Rally Cry', desc: 'A shout breaks the spell of fear!', type: 'clear_suppress', faction: 'both', value: 0, duration: 0 },
    { name: 'Outlaw Pinned!', desc: 'The law opens up with covering fire!', type: 'suppress_faction', faction: 'outlaw', value: 2, duration: 0 },
    { name: 'Police Pinned!', desc: 'The gang returns fire, pinning officers down!', type: 'suppress_faction', faction: 'law', value: 2, duration: 0 },
    { name: 'Crossfire', desc: 'Everyone is caught in the crossfire!', type: 'suppress_all', faction: 'both', value: 1, duration: 0 },
    { name: 'Machine Gun Burst', desc: 'Automatic fire pins down the outlaws!', type: 'suppress_faction', faction: 'outlaw', value: 3, duration: 0 },
    { name: 'Tommy Gun Terror', desc: 'The Thompson roars!', type: 'suppress_faction', faction: 'law', value: 3, duration: 0 },
   
    // === ACTION EVENTS ===
    { name: 'Second Wind', desc: 'Adrenaline kicks in! Everyone finds new energy.', type: 'restore_actions', faction: 'both', value: 1, duration: 0 },
    { name: 'Surge of Energy', desc: 'A burst of determination!', type: 'restore_actions', faction: 'both', value: 2, duration: 0 },
    { name: 'Brief Respite', desc: 'A moment to catch breath!', type: 'restore_actions', faction: 'both', value: 1, duration: 0 },
    { name: 'Outlaw Desperation', desc: 'Fight or die!', type: 'restore_actions', faction: 'outlaw', value: 2, duration: 0 },
    { name: 'Police Determination', desc: 'Justice must be served!', type: 'restore_actions', faction: 'law', value: 2, duration: 0 },
   
    // === SPECIAL/CHAOS EVENTS ===
    { name: 'Equalizer', desc: 'The battlefield levels out!', type: 'equalizer', faction: 'both', value: 0, duration: 0 },
    { name: 'Switcheroo', desc: 'Dodge values get swapped!', type: 'swap_stats', stat: 'dodge', faction: 'both', value: 0, duration: 0 },
    { name: 'Random Blessing', desc: 'Fortune smiles on someone!', type: 'buff_random', faction: 'both', value: 0, duration: 0 },
    { name: 'Lucky Break', desc: 'Someone gets a lucky break!', type: 'buff_random', faction: 'both', value: 0, duration: 0 },
    { name: 'Divine Intervention', desc: 'A miraculous save!', type: 'heal_lowest_hp', faction: 'both', value: 8, duration: 0 },
    { name: 'Grim Reaper', desc: 'Death claims the wounded!', type: 'execute_wounded', faction: 'both', value: 4, duration: 0 },
   
    // === WEATHER EVENTS ===
    { name: 'Thunderstorm', desc: 'Lightning illuminates the battlefield!', type: 'stat_mod', stat: 'dodge', faction: 'both', value: -5, duration: 2 },
    { name: 'Heat Wave', desc: 'Scorching heat saps energy!', type: 'stat_mod', stat: 'move', faction: 'both', value: -1, duration: 2 },
    { name: 'Cool Breeze', desc: 'A refreshing wind!', type: 'heal_all', faction: 'both', value: 1, duration: 0 },
    { name: 'Sandstorm', desc: 'Sand gets in everything!', type: 'stat_mod', stat: 'fire', faction: 'both', value: -2, duration: 1 },
    { name: 'Heavy Rain', desc: 'Rain soaks the battlefield!', type: 'ammo', faction: 'both', value: -1, duration: 0 },
   
    // === NARRATIVE EVENTS ===
    { name: 'Newspaper Headlines', desc: 'Publicity changes the game!', type: 'stat_mod', stat: 'fire', faction: 'outlaw', value: 1, duration: 2 },
    { name: 'Wanted: Dead or Alive', desc: 'Bounty hunters join the hunt!', type: 'damage_faction', faction: 'outlaw', value: 2, duration: 0 },
    { name: 'Corrupt Official', desc: 'Someone takes a bribe!', type: 'heal_faction', faction: 'outlaw', value: 2, duration: 0 },
    { name: 'Internal Affairs', desc: 'Investigation hampers the law!', type: 'stat_mod', stat: 'move', faction: 'law', value: -1, duration: 2 },
    { name: 'Public Support', desc: 'Citizens back the law!', type: 'heal_faction', faction: 'law', value: 2, duration: 0 },
    { name: 'Robin Hood Effect', desc: 'Outlaws gain folk hero status!', type: 'stat_mod', stat: 'dodge', faction: 'outlaw', value: 5, duration: 2 },
   
    // === NEW CHAOS EVENTS ===
    { name: 'Soul Drain', desc: 'Life force transfers between enemies!', type: 'steal_hp', faction: 'both', value: 4, duration: 0 },
    { name: 'Glass Cannon Protocol', desc: 'Maximum firepower, minimum protection!', type: 'glass_cannon', faction: 'both', value: 0, duration: 0 },
    { name: 'Fortify Positions', desc: 'Dig in and hold the line!', type: 'fortify', faction: 'both', value: 0, duration: 0 },
    { name: 'Shield Wall', desc: 'Everyone takes cover!', type: 'shield_all', faction: 'both', value: 0, duration: 0 },
    { name: 'Armory Opened', desc: 'Unlimited ammunition for all!', type: 'max_ammo', faction: 'both', value: 0, duration: 0 },
    { name: 'Time Warp', desc: 'Time rewinds! Everyone gets a fresh start!', type: 'time_warp', faction: 'both', value: 0, duration: 0 },
    { name: 'Sudden Death Mode', desc: 'One shot, one kill! All HP set to 1!', type: 'sudden_death', faction: 'both', value: 0, duration: 0 },
    { name: 'Desperate Times', desc: 'The wounded fight harder!', type: 'last_stand', faction: 'both', value: 0, duration: 0 },
    { name: 'Underdog Boost', desc: 'The losing side gets help!', type: 'momentum_shift', faction: 'both', value: 0, duration: 0 },
    { name: 'Blood Ritual', desc: 'One feeds on the suffering of all!', type: 'vampire_wave', faction: 'both', value: 2, duration: 0 },
    { name: 'Noble Sacrifice', desc: 'One falls so others may rise!', type: 'sacrifice', faction: 'outlaw', value: 0, duration: 0 },
    { name: 'Officer Down', desc: 'A fallen officer inspires the rest!', type: 'sacrifice', faction: 'law', value: 0, duration: 0 },
    { name: 'Mustard Gas', desc: 'Poisonous gas spreads across the battlefield!', type: 'poison_cloud', faction: 'both', value: 2, duration: 0 },
    { name: 'Ammunition Malfunction', desc: 'Bullets explode in the chamber!', type: 'ammo_explosion', faction: 'both', value: 0, duration: 0 },
   
    // === MORE FACTION-SPECIFIC NEW EVENTS ===
    { name: 'Outlaw Glass Cannon', desc: 'The gang goes all-in!', type: 'glass_cannon', faction: 'outlaw', value: 0, duration: 0 },
    { name: 'Police Fortification', desc: 'Officers dig in!', type: 'fortify', faction: 'law', value: 0, duration: 0 },
    { name: 'Gang Rearm', desc: 'Outlaws reload!', type: 'max_ammo', faction: 'outlaw', value: 0, duration: 0 },
    { name: 'Police Rearm', desc: 'Officers reload!', type: 'max_ammo', faction: 'law', value: 0, duration: 0 },
    { name: 'Police Refresh', desc: 'Officers get reinforced!', type: 'time_warp', faction: 'law', value: 0, duration: 0 },
    { name: 'Outlaw Gambit', desc: 'All or nothing for the gang!', type: 'coin_flip', faction: 'outlaw', value: 6, duration: 0 },
    { name: 'Police Gambit', desc: 'All or nothing for the law!', type: 'coin_flip', faction: 'law', value: 6, duration: 0 },
    { name: 'Outlaw Last Stand', desc: 'Cornered outlaws fight back!', type: 'last_stand', faction: 'outlaw', value: 0, duration: 0 },
    { name: 'Police Last Stand', desc: 'Officers make their stand!', type: 'last_stand', faction: 'law', value: 0, duration: 0 },
    { name: 'Tear Gas', desc: 'Police deploy tear gas on outlaws!', type: 'poison_cloud', faction: 'outlaw', value: 1, duration: 0 },
    { name: 'Outlaw Smoke Bomb', desc: 'Outlaws throw poison smoke!', type: 'poison_cloud', faction: 'law', value: 1, duration: 0 },
   
    // === EXTREME EVENTS ===
    { name: 'Armageddon', desc: 'Total destruction! Massive damage to all!', type: 'damage_all', faction: 'both', value: 6, duration: 0 },
    { name: 'Divine Shield', desc: 'Everyone is protected!', type: 'shield_all', faction: 'both', value: 0, duration: 0 },
    { name: 'Mass Resurrection', desc: 'The fallen are healed!', type: 'heal_all', faction: 'both', value: 8, duration: 0 },
    { name: 'Judgement Day', desc: 'All are judged! Wounded are executed!', type: 'execute_wounded', faction: 'both', value: 5, duration: 0 },
   
    // === SINGLE TARGET EVENTS ===
    { name: 'Weapon Jam!', desc: 'A gun misfires!', type: 'ammo', faction: 'both', value: -3, duration: 0, targetCount: 'random_one' },
    { name: 'Sniper\'s Mark', desc: 'A shooter takes careful aim...', type: 'damage_all', faction: 'both', value: 5, duration: 0, targetCount: 'random_one' },
    { name: 'Lucky Find', desc: 'Someone finds extra ammunition!', type: 'ammo', faction: 'both', value: 4, duration: 0, targetCount: 'random_one' },
    { name: 'Ricocheted Shot', desc: 'A bullet finds an unexpected target!', type: 'damage_all', faction: 'both', value: 3, duration: 0, targetCount: 'random_one' },
    { name: 'Divine Intervention', desc: 'Someone receives miraculous healing!', type: 'heal_all', faction: 'both', value: 6, duration: 0, targetCount: 'random_one' },
    { name: 'Adrenaline Surge', desc: 'A combatant gets a sudden burst of energy!', type: 'stat_mod', stat: 'move', faction: 'both', value: 2, duration: 2, targetCount: 'random_one' },
    { name: 'Shell Shock', desc: 'An explosion stuns someone!', type: 'suppress_all', faction: 'both', value: 2, duration: 0, targetCount: 'random_one' },
    { name: 'Sharpshooting', desc: 'Someone finds their mark!', type: 'stat_mod', stat: 'fire', faction: 'both', value: 3, duration: 2, targetCount: 'random_one' },
    { name: 'Graze Wound', desc: 'A bullet grazes someone!', type: 'damage_all', faction: 'both', value: 2, duration: 0, targetCount: 'random_two' },
    { name: 'Spooked!', desc: 'Nerves get the better of two fighters!', type: 'stat_mod', stat: 'dodge', faction: 'both', value: -10, duration: 2, targetCount: 'random_two' },
    { name: 'Second Wind', desc: 'Two fighters catch their breath!', type: 'heal_all', faction: 'both', value: 3, duration: 0, targetCount: 'random_two' },
    { name: 'Outlaw Singled Out', desc: 'An outlaw is targeted!', type: 'damage_all', faction: 'outlaw', value: 4, duration: 0, targetCount: 'random_one' },
    { name: 'Officer Targeted', desc: 'A lawman is in the crosshairs!', type: 'damage_all', faction: 'law', value: 4, duration: 0, targetCount: 'random_one' },
    { name: 'Empty Chamber!', desc: 'Someone\'s gun clicks empty!', type: 'drain_ammo', faction: 'both', value: 99, duration: 0, targetCount: 'random_one' },
    { name: 'Quick Reload', desc: 'Lightning fast ammunition swap!', type: 'max_ammo', faction: 'both', value: 0, duration: 0, targetCount: 'random_one' },
    { name: 'Marked for Death', desc: 'The healthiest target draws attention!', type: 'damage_all', faction: 'both', value: 4, duration: 0, targetCount: 'highest_hp' },
    { name: 'Mercy Shot', desc: 'Someone puts a wounded fighter out of misery!', type: 'damage_all', faction: 'both', value: 99, duration: 0, targetCount: 'lowest_hp' },
    { name: 'Ammo Thief', desc: 'Someone steals from the most loaded!', type: 'drain_ammo', faction: 'both', value: 3, duration: 0, targetCount: 'highest_ammo' },
    { name: 'Charity', desc: 'Ammo shared with the neediest!', type: 'ammo', faction: 'both', value: 4, duration: 0, targetCount: 'lowest_ammo' }
];

// ============ DEFAULT ABILITIES ============ //Custom Abilties
const DEFAULT_ABILITIES = {
    // Original 5
    quickdraw: { id: 'quickdraw', name: 'Quickdraw', icon: '‚ö°', trigger: 'on_attack', effect: 'fire_bonus', value: 1, desc: '+1 Fire, attacks with priority' },
    tough: { id: 'tough', name: 'Tough', icon: 'üõ°Ô∏è', trigger: 'on_defend', effect: 'damage_reduction', value: 50, desc: '50% damage reduction' },
    sniper: { id: 'sniper', name: 'Sniper', icon: 'üéØ', trigger: 'on_attack', effect: 'fire_bonus', value: 2, desc: '+2 Fire damage' },
    medic: { id: 'medic', name: 'Medic', icon: 'üíä', trigger: 'on_turn_end', effect: 'heal_ally', value: 2, desc: 'Heals ally 2HP at turn end' },
    leader: { id: 'leader', name: 'Leader', icon: '‚≠ê', trigger: 'aura', effect: 'ally_fire', value: 1, desc: '+1 Fire to allies' },anti_vehicle: { 
    id: 'anti_vehicle', 
    name: 'Armor-Piercing', 
    icon: 'üî©', 
    trigger: 'on_attack', 
    effect: 'anti_vehicle', 
    value: { hitBonus: 30, dmgBonus: 5 },  // 30% extra hit chance, +5 dmg vs vehicles
    desc: '+30% hit chance and +5 damage vs vehicles' 
},supply_crate: {
    id: 'supply_crate',
    name: 'Ammo Crate',
    icon: 'üì¶',
    trigger: 'on_turn_end',
    effect: 'supply_crate_spawn',
    value: {
        successChance: 30,           // 30% chance per turn
        minWeapons: 1,
        maxWeapons: 3,
        pool: ['bar', 'marksman', 'molotov', 'grenadier', 'hollowpoint', 'ammo', 'anti_vehicle', 'suppressor', 'bulletproof']
    },
    desc: 'Every turn end: 30% chance to spawn 1-3 random weapons and ammo.'
},ram: { 
    id: 'ram', 
    name: 'RAM!', 
    icon: 'üöóüí•', 
    trigger: 'manual', 
    effect: 'ram', 
    value: { minKills: 1, maxKills: 3 }, 
    desc: 'Suicide ram: Kill 1-3 random enemies (ignores defenses). Vehicle crippled after: x4 suppress, -10 move, 10% dodge.' 
},high_velocity: { 
    id: 'high_velocity', 
    name: 'Police High Velocity Ammunition', 
    icon: 'ü©∏', 
    trigger: 'on_attack', 
    effect: 'high_velocity', 
    value: { stacksNeeded: 1 }, 
    desc: 'Hits build stacks. 1 stacks = permanent cripple: Dodge halved, MP /2, no heals/rally, HP floor 2, +1 supp/turn' 
},folkhero: { 
    id: 'folkhero', 
    name: 'Folk Hero', 
    icon: 'üé≠', 
    trigger: 'on_attack', 
    effect: 'folk_hero_convert', 
    value: 65,  // 65% chance on hit
    desc: '65% chance on hit: Target joins YOUR team! (One use)' 
},signal_charge: { 
    id: 'signal_charge', 
    name: 'Signal Charge Model 3', 
    icon: 'üí•', 
    trigger: 'on_attack', 
    effect: 'signal_charge', 
    value: { accDrop: 75, stateDrop: 75, turns: 2, minTargets: 1, maxTargets: 3 },  // ‚Üê NEW: random 1‚Äì3 targets
    desc: 'One-use: -75% ACC and -75 State for 2 turns on 1‚Äì3 random enemies (proto-flashbang)' 
},lewisgun: {
    id: 'lewisgun',
    name: 'Lewis Gun',
    icon: 'üéØ',
    trigger: 'on_attack',
    effect: 'lewis_suppression',
    value: { 
        moraleHit: 15,      // Devastating morale damage
        suppBonus: 2,        // Extra suppression
        jamChancePerShot: 15,        // 15% jam chance per shot
    },
    desc: 'Air-cooled pan-fed LMG. Devastating morale (-15). +2 suppression. 15% jam: locks weapon current turn'
},
   
    // NEW - Combat Abilities (on_attack)
    executioner: { id: 'executioner', name: 'Executioner', icon: 'üíÄ', trigger: 'on_attack', effect: 'execute', value: 25, desc: 'Kills target instantly if below 25% HP' },
    hollowpoint: { id: 'hollowpoint', name: 'Hollow Point', icon: 'üî¥', trigger: 'on_attack', effect: 'bonus_vs_undefended', value: 3, desc: '+3 Fire vs non-defending targets' },
    suppressor: { id: 'suppressor', name: 'Suppressor', icon: 'üîá', trigger: 'on_attack', effect: 'attack_suppress', value: 1, desc: 'Attacks also apply 1 suppression' },
    doubletap: { id: 'doubletap', name: 'Double Tap', icon: 'üéØ', trigger: 'on_attack', effect: 'double_damage', value: 25, desc: '25% chance to deal double damage' },
    vampire: { id: 'vampire', name: 'Bloodthirsty', icon: 'ü©∏', trigger: 'on_attack', effect: 'lifesteal', value: 50, desc: 'Heals 50% of damage dealt' },
    gutshot: { id: 'gutshot', name: 'Gutshot', icon: 'üíâ', trigger: 'on_attack', effect: 'gutshot', value: 15, desc: '15% chance to cause bleeding (1 HP/turn until death)' },
    bar: { id: 'bar', name: 'BAR', icon: 'üî´', trigger: 'on_attack', effect: 'bar_suppress', value: 2, desc: '90% chance to apply massive suppression (2x Fire stat)' },
    marksman: { id: 'marksman', name: 'Marksman', icon: 'üéØ', trigger: 'passive', effect: 'marksman', value: 25, desc: '+25% dodge, immune to suppression, suppresses all enemies on attack' },overpressure: { 
    id: 'overpressure', 
    name: 'Overpressure Rounds', 
    icon: 'üî•', 
    trigger: 'on_attack', 
    effect: 'overpressure', 
    value: { suppressBonus: 4 },  // +4 suppression (tune if needed)
    desc: 'On hit: Destroys bulletproof vest + massive suppression (+4)' 
},coordinator: { id: 'coordinator', name: 'Coordinator', icon: 'üì°', trigger: 'aura', effect: 'ally_move', value: 1, desc: '+1 Move to all allies' },arrestwarrant: {
    id: 'arrestwarrant',
    name: 'Arrest Warrant',
    icon: 'üîí',
    trigger: 'on_attack',
    effect: 'arrest',
    value: 20,  // 20% release chance
    desc: 'Locks target! Cannot act. 20% release after 2+ turns min. Released: 0 ammo/MP, abilities stripped'
},        timed_dynamite: {
            id: 'timed_dynamite',
            name: 'Timed Dynamite',
            icon: 'üß®',
            trigger: 'on_attack',
            effect: 'dynamite_throw',
            value: {
                throwChance: 100,
                timerRange: [3, 6],
                targetsRange: [1, 5],
                damageRange: [8, 12],
                accPenaltyRange: [-60, -40],
                statePenaltyRange: [-80, -50]
            },
            desc: 'ONE USE: 60% chance to throw dynamite on attack. Detonates in 0-3 turns. Hits 1-3 enemies with massive damage and debuffs.'
        },
   
    // NEW - Defensive Abilities (on_defend)
    bulletproof: { id: 'bulletproof', name: 'Bulletproof Vest', icon: 'ü¶∫', trigger: 'on_defend', effect: 'damage_reduction', value: 50, desc: '50% damage reduction always' },
    countershot: { id: 'countershot', name: 'Counter Shot', icon: '‚Ü©Ô∏è', trigger: 'on_defend', effect: 'reflect', value: 50, desc: 'Reflects 50% damage back to attacker' },
    slippery: { id: 'slippery', name: 'Slippery', icon: 'üí®', trigger: 'on_defend', effect: 'dodge_bonus', value: 15, desc: '+15% dodge chance when attacked' },
    lastbreath: { id: 'lastbreath', name: 'Last Breath', icon: 'üíî', trigger: 'on_defend', effect: 'revenge', value: 4, desc: 'If killed, deals 4 damage to attacker' },
    ironwill: { id: 'ironwill', name: 'Iron Will', icon: 'üîí', trigger: 'on_defend', effect: 'survive_lethal', value: 33, desc: '33% chance to survive lethal hit at 1HP' },
   
    // NEW - Turn End Abilities (on_turn_end)
    scavenger: { id: 'scavenger', name: 'Scavenger', icon: 'üîç', trigger: 'on_turn_end', effect: 'ammo_regen', value: 1, desc: 'Recovers 1 ammo at turn end' },
    fieldmedic: { id: 'fieldmedic', name: 'Field Medic', icon: 'üè•', trigger: 'on_turn_end', effect: 'heal_self', value: 1, desc: 'Heals 1HP at turn end' },
    tactician: { id: 'tactician', name: 'Tactician', icon: 'üìã', trigger: 'on_turn_end', effect: 'reduce_ally_suppress', value: 1, desc: 'Removes 1 suppression from random ally' },
    informant: { id: 'informant', name: 'Informant', icon: 'üëÅÔ∏è', trigger: 'on_turn_end', effect: 'expose_enemy', value: 10, desc: 'Random enemy loses 10% dodge next turn' },
   
    // NEW - Aura Abilities (aura)
    sergeant: { id: 'sergeant', name: 'Sergeant', icon: 'üì£', trigger: 'aura', effect: 'rally_bonus', value: 15, desc: '+15% Rally chance for team' },
    intimidate: { id: 'intimidate', name: 'Intimidating', icon: 'üò†', trigger: 'aura', effect: 'enemy_fire_reduce', value: 2, desc: 'All enemies deal -2 Fire damage' },
    inspiring: { id: 'inspiring', name: 'Inspiring', icon: 'üéñÔ∏è', trigger: 'aura', effect: 'ally_dodge', value: 5, desc: '+5% dodge to all allies' },
    coordinator: { id: 'coordinator', name: 'Coordinator', icon: 'üì°', trigger: 'aura', effect: 'ally_move', value: 1, desc: '+1 Move to all allies' },
grenadier: { id: 'grenadier', name: 'Grenadier', icon: 'üí£', trigger: 'on_attack', effect: 'grenade_throw', value: 45, desc: '45% chance to throw grenade (2-4 targets, 2-5 dmg each)' },
molotov: { id: 'molotov', name: 'Molotov', icon: 'üî•', trigger: 'on_attack', effect: 'molotov_throw', value: 40, desc: '40% chance to throw molotov (causes burning: 1 HP/turn for 2 turns + suppression)' },
roadblock: { id: 'roadblock', name: 'Roadblock', icon: 'üöß', trigger: 'on_turn_start', effect: 'immobilize_vehicle', value: 40, desc: '40% chance per turn to immobilize enemy vehicle (dodge ‚Üí 5%)' }
};


// ============ STORAGE ============
function loadData() {
    const custom = JSON.parse(localStorage.getItem('bc_custom_cards') || '{"outlaw":[],"law":[]}');
    G.allCards = {
        outlaw: [...DEFAULT_CARDS.outlaw, ...custom.outlaw],
        law: [...DEFAULT_CARDS.law, ...custom.law]
    };
    G.events = [...DEFAULT_EVENTS, ...JSON.parse(localStorage.getItem('bc_custom_events') || '[]')];
    G.savedDecks = JSON.parse(localStorage.getItem('bc_decks') || '{"outlaw":null,"law":null}');
   
    // Load custom abilities
    const customAbilities = JSON.parse(localStorage.getItem('bc_custom_abilities') || '{}');
    G.abilities = {...DEFAULT_ABILITIES, ...customAbilities};
}

function saveCustomCard(card) {
    const custom = JSON.parse(localStorage.getItem('bc_custom_cards') || '{"outlaw":[],"law":[]}');
    card.id = 'custom_' + Date.now();
    custom[card.faction].push(card);
    localStorage.setItem('bc_custom_cards', JSON.stringify(custom));
    loadData();
}

function saveCustomEvent(event) {
    const events = JSON.parse(localStorage.getItem('bc_custom_events') || '[]');
    events.push(event);
    localStorage.setItem('bc_custom_events', JSON.stringify(events));
    loadData();
}

function saveCurrentDeck(faction, deck) {
    G.savedDecks[faction] = deck;
    localStorage.setItem('bc_decks', JSON.stringify(G.savedDecks));
}

// ============ UI HELPERS ============
function $(id) { return document.getElementById(id); }
function show(id) { $(id).classList.remove('hidden'); }
function hide(id) { $(id).classList.add('hidden'); }
function closeModal(id) { hide(id); }

function log(msg, type = '') {
}

function addToFeed(faction, icon, message, detail = '', type = 'default') {
    const feed = $(faction + 'Feed');
    if (!feed) return;
   
    const time = `R${G.round}`;
    const entry = document.createElement('div');
    entry.className = `feed-entry ${type}`;
    entry.innerHTML = `
        <span class="feed-icon">${icon}</span>
        ${message}
        <span class="feed-time">${time}</span>
        ${detail ? `<div class="feed-detail">${detail}</div>` : ''}
    `;
   
    feed.insertBefore(entry, feed.firstChild);
   
    // Keep only last 50 entries
    while (feed.children.length > 50) {
        feed.removeChild(feed.lastChild);
    }
   
    // Smooth scroll to top
    feed.scrollTop = 0;
}

function addEventToFeeds(message, detail = '') {
    addToFeed('outlaw', 'üé≤', message, detail, 'event');
    addToFeed('law', 'üé≤', message, detail, 'event');
    showEventTicker(message);
}

function addMissToCombatFeed(faction, attacker, target, hitChance, attackerAccuracy) {
    const feed = $(faction + 'CombatFeed');
    if (!feed) return;
    
    const time = `R${G.round}`;
    const entry = document.createElement('div');
    entry.className = 'feed-entry attack';
    entry.dataset.missBreakdown = JSON.stringify({ attacker, target, hitChance, attackerAccuracy });
    entry.onmouseenter = (e) => showMissBreakdownTooltip(e.currentTarget);
    entry.onmouseleave = () => clearCombatPrediction();
    
    entry.innerHTML = `
        <span class="feed-icon">üí®</span>
        <strong>${attacker.portrait} ${attacker.name}</strong> ‚Üí ${target.portrait} ${target.name}
        <span class="feed-time">${time}</span>
        <div class="feed-detail" style="margin-top:4px">
            <div style="display:flex;justify-content:space-between;align-items:center">
                <span style="color:#4ade80;font-weight:700;font-size:1.1em">MISS</span>
                <span style="font-size:.85em;color:#666">${hitChance.toFixed(0)}% hit</span>
            </div>
            <div style="font-size:.75em;color:#555;margin-top:4px;border-top:1px solid #333;padding-top:3px">
                Acc: ${attackerAccuracy}% | Target dodge: ${getEffectiveDodge(target)}%
            </div>
        </div>
    `;
    
    feed.insertBefore(entry, feed.firstChild);
    
    while (feed.children.length > 30) {
        feed.removeChild(feed.lastChild);
    }
    
    feed.scrollTop = 0;
}

function addToCombatFeed(faction, attacker, target, damage, effects, breakdownData, eliminated) {
    const feed = $(faction + 'CombatFeed');
    if (!feed) return;
    
    const time = `R${G.round}`;
    const entry = document.createElement('div');
    entry.className = 'feed-entry attack';
    entry.dataset.breakdown = JSON.stringify({ attacker, target, damage, effects, breakdownData, eliminated });
    entry.onmouseenter = (e) => showCombatBreakdownTooltip(e.currentTarget);
    entry.onmouseleave = () => clearCombatPrediction();
    
    // Build effects display
    const effectsHTML = effects && effects.length > 0 
        ? `<div style="font-size:.85em;margin-top:3px">${effects.map(e => `<span style="margin-right:4px;color:${e.type === 'buff' ? '#4ade80' : e.type === 'debuff' ? '#f87171' : '#d9a34a'}">${e.text}</span>`).join('')}</div>`
        : '';
    
    entry.innerHTML = `
        <span class="feed-icon">${damage > 0 ? 'üî´' : 'üí®'}</span>
        <strong>${attacker.portrait} ${attacker.name}</strong> ‚Üí ${target.portrait} ${target.name}
        <span class="feed-time">${time}</span>
        <div class="feed-detail" style="margin-top:4px">
            <div style="display:flex;justify-content:space-between;align-items:center">
                <span style="color:${eliminated ? '#ff0000' : damage > 0 ? '#c9302c' : '#4ade80'};font-weight:700;font-size:1.1em">
                    ${eliminated ? 'üíÄ KILL' : damage > 0 ? `-${damage} HP` : 'DODGED'}
                </span>
                <span style="font-size:.85em;color:#666">
                    ${(breakdownData.hitChance || breakdownData.effectiveHitChance || 0).toFixed(0)}% hit
                </span>
            </div>
            ${effectsHTML}
            <div style="font-size:.75em;color:#555;margin-top:4px;border-top:1px solid #333;padding-top:3px">
                Acc: ${breakdownData.attackerAccuracy || 0}% | Dodge: ${target ? getEffectiveDodge(target) : 0}% | Dmg: ${breakdownData.grossDmg || damage}‚Üí${damage}
            </div>
        </div>
    `;
    
    feed.insertBefore(entry, feed.firstChild);
    
    // Keep only last 30 entries
    while (feed.children.length > 30) {
        feed.removeChild(feed.lastChild);
    }
    
    feed.scrollTop = 0;
}

function showEventTicker(message) {
    const ticker = $('eventTicker');
    if (!ticker) return;
   
    ticker.textContent = 'üé≤ ' + message;
    ticker.classList.add('show');
   
    setTimeout(() => {
        ticker.classList.remove('show');
    }, 3000);
}

// Helper function to get card's abilities array (handles both old and new format)
function getCardAbilities(card) {
    if (!card) return [];
    // New format: abilities array
    if (Array.isArray(card.abilities)) {
        return card.abilities.filter(a => a && G.abilities[a]);
    }
    // Old format: single ability string (backwards compatibility)
    if (card.ability && G.abilities[card.ability]) {
        return [card.ability];
    }
    return [];
}

// Check if card has a specific ability
function hasAbility(card, abilityId) {
    return getCardAbilities(card).includes(abilityId);
}

// Get all abilities of a card with specific trigger
function getAbilitiesByTrigger(card, trigger) {
    return getCardAbilities(card)
        .map(id => G.abilities[id])
        .filter(ab => ab && ab.trigger === trigger);
}

// Get all abilities of a card with specific trigger and effect
function getAbilitiesByEffect(card, trigger, effect) {
    return getCardAbilities(card)
        .map(id => G.abilities[id])
        .filter(ab => ab && ab.trigger === trigger && ab.effect === effect);
}

// ============ STATE SYSTEM ============
function applyStatePenalty(card, value, type) {
    if (!card.state && card.state !== 0) card.state = 100;
    

// Apply Signal state drop (like ACC)
if (card.signalChargeEffects) {
    card.signalChargeEffects.forEach(e => {
        if (e.type === 'state') {
            card.state = Math.max(0, card.state + e.value);  // negative drop
        }
    });
}
    
    // Apply global active event state drops
    G.activeEvents.forEach(e => {
        if (e.stat === 'state' && (e.faction === 'both' || e.faction === card.faction)) {
            card.state = Math.max(0, (card.state || 100) + e.value);  // value is negative for drops
        }
    });
    
    if (card.state <= 20) {
        if (type === 'accuracy' || type === 'dodge') return Math.floor(value * 0.4);
        if (type === 'move') return Math.max(0, value - 3);
    } else if (card.state <= 50) {
        if (type === 'accuracy' || type === 'dodge') return Math.floor(value * 0.8);
        if (type === 'move') return Math.max(0, value - 1);
    }
    
    return value;
}

function getEffectiveMove(card) {
    if (card.arrested) return 0;  // Arrested = 0 move (cannot act)
    
    let move = card.move;
   
    // Vehicle passenger penalty (movement halved)
    if (card.inVehicle) {
        move = Math.ceil(move / 2);
    }
   
        // Fortified penalty
    if (card.fortified && card.fortified > 0) {
        move -= 1;  // -1 movement when fortified
    }
   
    // Event modifiers
    G.activeEvents.forEach(e => {
        if (e.stat === 'move' && (e.faction === 'both' || e.faction === card.faction)) {
            move += e.value;
        }
    });
   
    // Ally aura bonuses (ally_move)
    G.field[card.faction].forEach(ally => {
        if (ally.id !== card.id) {
            getAbilitiesByEffect(ally, 'aura', 'ally_move').forEach(ab => {
                move += ab.value;
            });
        }
    });
   
    // Forest move modifier
    move += card.forestMove || 0;
   
    move = Math.max(1, move);
    return applyStatePenalty(card, move, 'move');
}

function getEffectiveDodge(card) {
    let dodge = card.dodge || 10;
   
    // Marksman bonus (elite sniper training)
    const hasMarksman = card.abilities && card.abilities.includes('marksman');
    if (hasMarksman) {
        dodge += 25;
    }
   
    // Cover penalty (can't dodge when hunkered down)
    if (card.coverTurns && card.coverTurns > 0) {
        dodge -= 10;
    }
   
// Suppression chips away at dodge (-5% per suppression level)
    const marksmanImmune = card.abilities && card.abilities.includes('marksman');
    if (card.suppressed && card.suppressed > 0 && !marksmanImmune) {
        dodge -= (card.suppressed * 5);
    }
   
    // Fortified position bonus
    if (card.fortified && card.fortified > 0) {
        dodge += 40;  // +40% dodge when fortified
    }
   
    // Event modifiers
    G.activeEvents.forEach(e => {
        if (e.stat === 'dodge' && (e.faction === 'both' || e.faction === card.faction)) {
            dodge += e.value;
        }
    });
   
    // Ally aura bonuses (ally_dodge)
    G.field[card.faction].forEach(ally => {
        if (ally.id !== card.id) {
            getAbilitiesByEffect(ally, 'aura', 'ally_dodge').forEach(ab => {
                dodge += ab.value;
            });
        }
    });
   
    // Roadblock effect - vehicle immobilized
    if (card.roadblocked && card.isVehicle) {
        dodge = 5; // Roadblocked vehicles have only 5% dodge
    }
    
    // Forest environmental modifier
    if (card.forestDodge !== undefined) {
        dodge += card.forestDodge;
    }
   
    dodge = Math.max(0, Math.min(95, dodge));
return applyStatePenalty(card, dodge, 'dodge');
}

function getEffectiveFire(card) {
    let fire = card.fire;
   
    // Cover penalty (halved) - but not for marksman (snipers don't lose firepower)
    if (card.coverTurns && card.coverTurns > 0 && !hasAbility(card, 'marksman')) {
        fire = Math.ceil(fire / 2);
    }
   
    // Event modifiers
    G.activeEvents.forEach(e => {
        if (e.stat === 'fire' && (e.faction === 'both' || e.faction === card.faction)) {
            fire += e.value;
        }
    });
    
    // Forest environmental modifier
    if (card.forestFire !== undefined) {
        fire += card.forestFire;
    }
    
    return Math.max(0, fire);
}

function getEffectiveSupp(card) {
    let supp = card.supp;
   
    // Cover penalty (halved) - but not for marksman (snipers maintain full suppression)
    if (card.coverTurns && card.coverTurns > 0 && !hasAbility(card, 'marksman')) {
        supp = Math.ceil(supp / 2);
    }
   
    // Event modifiers (if any for supp)
    G.activeEvents.forEach(e => {
        if (e.stat === 'supp' && (e.faction === 'both' || e.faction === card.faction)) {
            supp += e.value;
        }
    });
   
    return Math.max(0, supp);
}

function getEffectiveAccuracy(card) {
    let accuracy = card.accuracy || 100;  // Default 100%
    
    // Suppression penalty (every point of suppression = -5% accuracy)
    if (card.suppressed && card.suppressed > 0) {
        accuracy -= (card.suppressed * 5);
    }
    
    // Dynamite (IED) Accuracy penalty
    if (card.dynamiteAccPenalty) {
        accuracy += card.dynamiteAccPenalty;
    }
    
    // Card-specific Signal Charge effects (targeted debuffs)
    if (card.signalChargeEffects) {
        card.signalChargeEffects.forEach(e => {
            if (e.type === 'accuracy') {
                accuracy += e.value;  // value is negative (-75)
            }
        });
    }
    
    // Event modifiers (smoke, flashbangs, etc.)
    G.activeEvents.forEach(e => {
        if (e.stat === 'accuracy' && (e.faction === 'both' || e.faction === card.faction)) {
            accuracy += e.value;
        }
    });
    
    // Forest environmental modifier
    if (card.forestAccuracy !== undefined) {
        accuracy += card.forestAccuracy;
    }
    
    accuracy = Math.max(10, Math.min(100, accuracy));
return applyStatePenalty(card, accuracy, 'accuracy');
}

function renderCard(card, inHand = false) {
    const effectiveMove = getEffectiveMove(card);
    const selected = G.selected && G.selected.id === card.id ? 'selected' : '';
    const defending = card.defending ? 'defending' : '';
    const suppressed = (card.suppressed && card.suppressed > 0) ? 'suppressed' : '';
    const inCover = (card.coverTurns && card.coverTurns > 0) ? 'in-cover' : '';
    const hoverEvents = inHand ? '' : `onmouseenter="showCombatPrediction('${card.id}')" onmouseleave="clearCombatPrediction()"`;
    const rattledShake = (card.state ?? 100) <= 40 ? 'rattled-shake' : '';
    const pulse = (card.state ?? 100) <= 60 && (card.state ?? 100) > 40 ? 'pulse' : '';
    
    

   
    // Calculate effective stats for display
    const effFire = getEffectiveFire(card);
    const effDodge = getEffectiveDodge(card);
    const effSupp = getEffectiveSupp(card);
    
// Forest modifier texts (only show if value exists)
const forestFireText  = card.forestFire  !== undefined ? ` (üå≤${card.forestFire  >= 0 ? '+' : ''}${card.forestFire})`  : '';
const forestDodgeText = card.forestDodge !== undefined ? ` (üå≤+${card.forestDodge}%)` : '';
const forestMoveText  = card.forestMove  !== undefined ? ` (üå≤${card.forestMove  >= 0 ? '+' : ''}${card.forestMove})`  : '';

// Fire display (with color tint if modified)
const fireDisplay = effFire !== card.fire
    ? `<span style="color:${effFire > card.fire ? '#4ade80' : '#f87171'}">${effFire}${forestFireText}</span>`
    : card.fire + forestFireText;

// Dodge display (with suppression note + color)
const dodgeDisplay = effDodge !== (card.dodge || 10)
    ? `<span style="color:${effDodge > (card.dodge || 10) ? '#4ade80' : '#f87171'}">${effDodge}%${card.suppressed > 0 ? ' (supp)' : ''}${forestDodgeText}</span>`
    : `${card.dodge || 10}%${forestDodgeText}`;

// Move display (NEW forest move support + color)
const moveDisplay = effectiveMove !== card.move
    ? `<span style="color:${effectiveMove > card.move ? '#4ade80' : '#f87171'}">${effectiveMove - (card.actionsUsed || 0)}${forestMoveText}</span>`
    : `${effectiveMove - (card.actionsUsed || 0)}${forestMoveText}`;

// Suppression display (color if modified)
const suppDisplay = effSupp !== card.supp
    ? `<span style="color:${effSupp > card.supp ? '#4ade80' : '#f87171'}">${effSupp}</span>`
    : card.supp;
   
    // Get abilities display
    const cardAbilities = getCardAbilities(card);
    const abilitiesDisplay = cardAbilities.length > 0
        ? cardAbilities.map(ab => {
            const ability = G.abilities[ab];
            return ability ? `<span style="color:var(--gold)" title="${ability.desc}">${ability.icon}</span>` : '';
        }).join(' ')
        : '';
   

return `
<div class="card ${card.faction} ${selected} ${suppressed} ${inCover} ${rattledShake}"
     style="--card-bg: ${card.background ? `url('${card.background}')` : ''};
            background-image: var(--card-bg);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;"
     onclick="${inHand ? `selectFromHand('${card.id}')` : `selectCard('${card.id}')`}"
     ${hoverEvents}
     data-id="${card.id}">

            ${card.suppressed ? `<div class="suppression-badge">-${card.suppressed}</div>` : ''}
            ${card.defending && !inCover ? `<div class="defend-badge">DEF</div>` : ''}
            ${card.coverTurns ? `<div class="cover-badge">COV${card.coverTurns}</div>` : ''}
            ${card.bleeding ? `<div class="bleeding-indicator">ü©∏ BLEEDING</div>` : ''}
            ${card.fortified ? `<div class="bleeding-indicator" style="background:#3d4f5f">üè∞ FORTIFIED x${card.fortified}</div>` : ''}
            ${card.burning ? `<div class="bleeding-indicator" style="background:#c9302c">üî• BURNING x${card.burning}</div>` : ''}
            ${card.shattered ? `<div class="bleeding-indicator" style="background:#8b0000">ü©∏ HV SHATTERED</div>` : ''}
            ${card.inVehicle ? `<div class="vehicle-badge">IN VEHICLE</div>` : ''}
            ${card.roadblocked && card.isVehicle ? `<div class="roadblock-badge">üöß ROADBLOCKED</div>` : ''}
            ${card.arrested ? `<div class="arrested-indicator">üîí ARRESTED</div>` : ''}
${card.forestDodge !== undefined ? `<div class="forest-badge">üå≤</div>` : ''}
            <div class="card-name">${card.name}</div>
            <div class="card-portrait">${card.portrait}</div>
            <div class="card-stats">
                <span class="stat-hp">HP: ${card.hp}/${card.maxHp}</span>
                <span class="stat-ammo">Ammo: ${card.ammo}/${card.maxAmmo}</span>
                ${card.grenades !== undefined ? `<span class="stat-ammo">üí£ ${card.grenades}</span>` : ''}
                ${card.molotovs !== undefined ? `<span class="stat-ammo">üî• ${card.molotovs}</span>` : ''}
                ${card.isVehicle ? `<span class="stat-ammo">üöó Passengers: ${card.passengers ? card.passengers.length : 0}/${card.maxPassengers}</span>` : ''}
                <span class="stat-move">Move: ${moveDisplay}</span>
                <span class="stat-fire">Fire: ${fireDisplay}</span>
                <span class="stat-supp">Supp: ${suppDisplay}</span>
                <span class="stat-dodge">Dodge: ${dodgeDisplay}</span>
${(() => {
    const baseAcc = card.accuracy || 100;
    const effAcc = getEffectiveAccuracy(card);
    const forestAccText = card.forestAccuracy !== undefined ? ` (üå≤${card.forestAccuracy >= 0 ? '+' : ''}${card.forestAccuracy}%)` : '';
    
    if (effAcc !== baseAcc) {
        return `<span style="color:${effAcc > baseAcc ? '#4ade80' : '#f87171'}">Acc: ${effAcc}%${forestAccText}</span>`;
    }
    return `<span style="color:#facc15">Acc: ${effAcc}%${forestAccText}</span>`;
})()}
                <span style="color:${card.state <= 20 ? '#f87171' : card.state <= 50 ? '#fbbf24' : '#4ade80'}">${card.state <= 20 ? 'üíÄ Rattled' : card.state <= 50 ? 'üò∞ Frightened' : 'üòä Ready'}: ${card.state}/100</span>
                ${card.abilities && card.abilities.length > 0 ? `<span style="color:#c9a227;font-size:7px;margin-top:2px;display:block;text-align:center">${card.abilities.map(ab => {
    const ability = G.abilities[ab];
    if (ab === 'bulletproof' && card.vestDurability !== undefined) {
        return `${ability?.name || ab} (${card.vestDurability}/3)`;
    }
    return ability?.name || ab;
}).join(', ')}</span>` : ''}
            </div>
            ${/*abilitiesDisplay ? `<div class="card-abilities">${abilitiesDisplay}</div>` : */''}
        </div>
    `;
}

function updateUI() {
    // Render battlefield cards
    $('outlawZone').innerHTML = G.field.outlaw.map(c => renderCard(c)).join('');
    $('lawZone').innerHTML = G.field.law.map(c => renderCard(c)).join('');

    // Update scores & counts
    $('outlawScore').textContent = G.scores.outlaw;
    $('lawScore').textContent = G.scores.law;
    $('outlawDeckCount').textContent = G.decks.outlaw.length;
    $('lawDeckCount').textContent = G.decks.law.length;
    $('outlawHandCount').textContent = G.hands.outlaw.length;
    $('lawHandCount').textContent = G.hands.law.length;

// Update End Turn button to show current turn
let turnText = G.turn.toUpperCase() + ' TURN';
if (G.aiEnabled && G.turn === G.aiFaction) {
    turnText = 'ü§ñ AI ' + turnText;
    $('btnEndTurn').textContent = 'AI Playing...';
    $('btnEndTurn').style.background = G.turn === 'law' ? 'var(--steel)' : 'var(--crimson)';
} else {
    $('btnEndTurn').textContent = 'End Turn (' + turnText + ')';
    $('btnEndTurn').style.background = 'var(--gold)';
}
    $('phaseText').textContent = G.phase.toUpperCase() + ' PHASE';

    // FORCE ALL BUTTONS VISIBLE ALWAYS - NO DYNAMIC HIDING
    $('btnHide').classList.remove('hidden');
    $('btnBoard').classList.remove('hidden');
    $('btnDisembark').classList.remove('hidden');
    $('btnRam').classList.remove('hidden');
}


function getAbilityDesc(ab) {
    if (!ab) return '';
    const ability = G.abilities[ab];
    if (ability) {
        return `${ability.icon} ${ability.name}`;
    }
    return ab; // Fallback to raw ability name
}

// ============ COMBAT PREDICTOR ============
let predictorMouseX = 0;
let predictorMouseY = 0;

// Track mouse position for tooltip
document.addEventListener('mousemove', (e) => {
    predictorMouseX = e.clientX;
    predictorMouseY = e.clientY;
   
    // Update tooltip position if visible
    const tooltip = $('combatPredictor');
    if (tooltip && !tooltip.classList.contains('hidden')) {
        positionPredictorTooltip();
    }
});

function positionPredictorTooltip() {
    const tooltip = $('combatPredictor');
    const padding = 15;
    const tooltipWidth = tooltip.offsetWidth || 300;
    const tooltipHeight = tooltip.offsetHeight || 400;
   
    let left = predictorMouseX + padding;
    let top = predictorMouseY + padding;
   
    // Keep tooltip on screen
    if (left + tooltipWidth > window.innerWidth) {
        left = predictorMouseX - tooltipWidth - padding;
    }
    if (top + tooltipHeight > window.innerHeight) {
        top = window.innerHeight - tooltipHeight - padding;
    }
    if (top < 10) top = 10;
    if (left < 10) left = 10;
   
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
}

function showCombatPrediction(targetId) {
    const faction = G.turn;
    const enemy = faction === 'outlaw' ? 'law' : 'outlaw';
   
    // Find the target card
    const target = G.field[enemy].find(c => c.id === targetId);
    const friendlyCard = G.field[faction].find(c => c.id === targetId);
   
    // If hovering over friendly card, show its defensive stats
    if (friendlyCard) {
        showDefensivePrediction(friendlyCard);
        return;
    }
   
    // If hovering over enemy card but no attacker selected, show enemy defensive stats
    if (!G.selected && target) {
        showDefensivePrediction(target);
        return;
    }
   
    // If no target found at all, exit
    if (!target) {
        return;
    }
   
    // Calculate attack prediction
    const prediction = calculateAttackPrediction(G.selected, target);
   
    // Get attacker's abilities for display
    const attackerAbilities = getCardAbilities(G.selected).map(id => G.abilities[id]).filter(a => a);
    const targetAbilities = getCardAbilities(target).map(id => G.abilities[id]).filter(a => a);
   
    const tooltip = $('combatPredictor');
    tooltip.innerHTML = `
        <div class="predictor-header">
            <div class="predictor-header-portrait">${G.selected.portrait}</div>
            <div class="predictor-header-info">
                <div class="predictor-header-name">${G.selected.name}</div>
                <div class="predictor-header-status">‚öîÔ∏è Attacking ${target.name}</div>
            </div>
            <div style="font-size:2em">${target.portrait}</div>
        </div>
       
${G.selected.grenades !== undefined ? `
        <div class="predictor-section" style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">
            <div class="predictor-row">
                <span class="predictor-label">üí£ Grenades</span>
                <span class="predictor-value ${G.selected.grenades > 0 ? 'good' : 'bad'}">${G.selected.grenades} / 4</span>
            </div>
            ${G.selected.grenades > 0 ? `<div style="color:#888;font-size:.85em;margin-top:4px">45% chance to throw on attack</div>` : `<div style="color:#f87171;font-size:.85em;margin-top:4px">No grenades remaining!</div>`}
        </div>
        ` : ''}

${G.selected.molotovs !== undefined ? `
        <div class="predictor-section" style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">
            <div class="predictor-row">
                <span class="predictor-label">üî• Molotovs</span>
                <span class="predictor-value ${G.selected.molotovs > 0 ? 'good' : 'bad'}">${G.selected.molotovs} / 2</span>
            </div>
            ${G.selected.molotovs > 0 ? `<div style="color:#888;font-size:.85em;margin-top:4px">40% chance to throw on attack (hit or miss)</div>` : `<div style="color:#f87171;font-size:.85em;margin-top:4px">No molotovs remaining!</div>`}
        </div>
        ` : ''}
       
        ${prediction.targetInCover ? '<div class="predictor-warning">ü™® TARGET IN COVER - Damage reduced by ~87.5%!</div>' : ''}
        ${target.defending && !prediction.targetInCover ? '<div class="predictor-info">üõ°Ô∏è Target is defending (-50% damage)</div>' : ''}
       
        <div class="predictor-section">
            <div class="predictor-section-title">üìä COMBAT ODDS</div>
            <div class="predictor-row">
                <span class="predictor-label">Attacker Accuracy</span>
                <span class="predictor-value ${prediction.attackerAccuracy >= 90 ? 'good' : prediction.attackerAccuracy >= 70 ? 'neutral' : 'bad'}">${prediction.attackerAccuracy.toFixed(0)}%</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Final Hit Chance</span>
                <span class="predictor-value ${prediction.hitChance >= 70 ? 'good' : prediction.hitChance >= 40 ? 'neutral' : 'bad'}">${prediction.hitChance.toFixed(1)}%</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Expected Damage</span>
                <span class="predictor-value">${prediction.expectedDmg.toFixed(1)}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Damage Range</span>
                <span class="predictor-value">${prediction.minDmg} - ${prediction.maxDmg}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Kill Chance</span>
                <span class="predictor-value ${prediction.killChance >= 50 ? 'good' : prediction.killChance > 0 ? 'neutral' : 'bad'}">${prediction.killChance}%</span>
            </div>
        </div>
       
        <div class="predictor-section">
            <div class="predictor-section-title">üí• DAMAGE CALCULATION</div>
            <div class="predictor-line">
                <span>Base Fire (${G.selected.name})</span>
                <span>${G.selected.fire}</span>
            </div>
            ${prediction.sniperBonus ? `<div class="predictor-line add"><span>Attack Abilities</span><span>+${prediction.grossDmg - G.selected.fire - (prediction.leaderBonus ? 1 : 0) - prediction.eventMod}</span></div>` : ''}
            ${prediction.leaderBonus ? `<div class="predictor-line add"><span>Leader/Aura Bonus</span><span>+1</span></div>` : ''}
            ${prediction.eventMod !== 0 ? `<div class="predictor-line ${prediction.eventMod > 0 ? 'add' : 'sub'}"><span>Active Events</span><span>${prediction.eventMod > 0 ? '+' : ''}${prediction.eventMod}</span></div>` : ''}
            <div class="predictor-line result">
                <span>Gross Damage</span>
                <span>${prediction.grossDmg}</span>
            </div>
            ${prediction.coverReduction ? `<div class="predictor-line sub"><span>ü™® Cover Reduction (-75%)</span><span>-${prediction.coverReduction}</span></div>` : ''}
            ${prediction.defendReduction ? `<div class="predictor-line sub"><span>üõ°Ô∏è Defend Reduction (-50%)</span><span>-${prediction.defendReduction}</span></div>` : ''}
${target.vestHitsRemaining > 0 ? `
<div class="predictor-line sub">
    <span>ü¶∫ Bulletproof Vest (-30%)</span>
    <span>-${prediction.vestReduction}</span>
</div>
` : ''}
            ${prediction.toughReduction ? `<div class="predictor-line sub"><span>Ability Reduction (Tough etc)</span><span>-${prediction.toughReduction}</span></div>` : ''}
            <div class="predictor-line result">
                <span>Net Damage (if hit)</span>
                <span style="color:${prediction.netDmg === 0 ? '#4ade80' : '#f87171'}">${prediction.netDmg}</span>
            </div>
        </div>
       
        <div class="predictor-section">
            <div class="predictor-section-title">‚ù§Ô∏è TARGET STATUS</div>
            <div class="predictor-row">
                <span class="predictor-label">Current HP</span>
                <span class="predictor-value">${target.hp} / ${target.maxHp}</span>
            </div>
                    ${target.suppressed && target.suppressed > 0 ? `
            <div class="predictor-row">
                <span class="predictor-label">üíú Suppression</span>
                <span class="predictor-value bad">${target.suppressed.toFixed(1)} (-${(target.suppressed * 5).toFixed(0)}% dodge)</span>
            </div>
            ` : ''}
                        <div class="predictor-row">
                <span class="predictor-label">${target.state <= 20 ? 'üíÄ Target' : target.state <= 50 ? 'üò∞ Target' : 'üòä Target'} Morale</span>
                <span class="predictor-value ${target.state <= 20 ? 'bad' : target.state <= 50 ? 'neutral' : 'good'}">${target.state}/100 ${target.state <= 20 ? '(-60% dodge/acc)' : target.state <= 50 ? '(-20% dodge/acc)' : '(no penalty)'}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">${G.selected.state <= 20 ? 'üíÄ Your' : G.selected.state <= 50 ? 'üò∞ Your' : 'üòä Your'} Morale</span>
                <span class="predictor-value ${G.selected.state <= 20 ? 'bad' : G.selected.state <= 50 ? 'neutral' : 'good'}">${G.selected.state}/100 ${G.selected.state <= 20 ? '(-60% acc)' : G.selected.state <= 50 ? '(-20% acc)' : '(no penalty)'}</span>
            </div>
            ${G.selected.state <= 50 ? `
            <div class="predictor-row">
                <span class="predictor-label">${G.selected.state <= 20 ? 'üíÄ' : 'üò∞'} Your Morale</span>
                <span class="predictor-value bad">${G.selected.state} (${G.selected.state <= 20 ? '-60%' : '-20%'} acc)</span>
            </div>
            ` : ''}
            <div class="predictor-row">
                <span class="predictor-label">HP After Hit</span>
                <span class="predictor-value ${prediction.hpAfter <= 0 ? 'good' : prediction.hpAfter <= target.maxHp * 0.25 ? 'neutral' : 'bad'}">${Math.max(0, prediction.hpAfter)} / ${target.maxHp}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Dodge Chance</span>
                <span class="predictor-value">${100 - prediction.hitChance}%</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Ammo</span>
                <span class="predictor-value">${target.ammo} / ${target.maxAmmo}</span>
            </div>
        </div>
       
        ${targetAbilities.length > 0 ? `
        <div class="predictor-section">
            <div class="predictor-section-title">‚ö° TARGET ABILITIES</div>
            ${targetAbilities.map(ab => `<div class="predictor-line"><span>${ab.icon} ${ab.name}</span><span style="color:#888;font-size:.85em">${ab.desc}</span></div>`).join('')}
        </div>
        ` : ''}
    `;
   
    tooltip.classList.remove('hidden');
    positionPredictorTooltip();
}

function showDefensivePrediction(card) {
    const enemy = G.turn === 'outlaw' ? 'law' : 'outlaw';
    const enemies = G.field[enemy];
   
    // Calculate threat from each enemy
    let totalThreat = 0;
    let maxThreat = 0;
    let maxThreatEnemy = null;
    const threatList = [];
   
    enemies.forEach(e => {
        if (e.ammo > 0 && e.actionsUsed < e.move) {
            const pred = calculateAttackPrediction(e, card);
            totalThreat += pred.expectedDmg;
            threatList.push({ enemy: e, damage: pred.expectedDmg, hitChance: pred.hitChance });
            if (pred.expectedDmg > maxThreat) {
                maxThreat = pred.expectedDmg;
                maxThreatEnemy = e;
            }
        }
    });
   
    const survivalChance = totalThreat >= card.hp ? 0 : Math.round((1 - totalThreat / card.hp) * 100);
    const cardAbilities = getCardAbilities(card).map(id => G.abilities[id]).filter(a => a);
    const inCover = card.coverTurns && card.coverTurns > 0;
   
    const tooltip = $('combatPredictor');
    tooltip.innerHTML = `
        <div class="predictor-header">
            <div class="predictor-header-portrait">${card.portrait}</div>
            <div class="predictor-header-info">
                <div class="predictor-header-name">${card.name}</div>
                <div class="predictor-header-status" style="color:#60a5fa">üõ°Ô∏è Defensive Analysis</div>
            </div>
        </div>
       
        ${inCover ? '<div class="predictor-info">ü™® IN COVER - 87.5% damage reduction active!</div>' : ''}
        ${card.defending && !inCover ? '<div class="predictor-info">üõ°Ô∏è DEFENDING - 50% damage reduction active</div>' : ''}
       
        <div class="predictor-section">
            <div class="predictor-section-title">‚ù§Ô∏è CURRENT STATUS</div>
            <div class="predictor-row">
                <span class="predictor-label">HP</span>
                <span class="predictor-value">${card.hp} / ${card.maxHp}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Ammo</span>
                <span class="predictor-value">${card.ammo} / ${card.maxAmmo}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Dodge</span>
                <span class="predictor-value">${getEffectiveDodge(card)}%</span>
            </div>
            ${card.suppressed && card.suppressed > 0 ? `
            <div class="predictor-line sub">
                <span style="color:#888;font-size:.85em">‚îî Suppressed (x${card.suppressed})</span>
                <span>-${card.suppressed * 5}%</span>
            </div>
            ` : ''}
            <div class="predictor-row">
                <span class="predictor-label">Actions Left</span>
                <span class="predictor-value">${getEffectiveMove(card) - (card.actionsUsed || 0)}</span>
            </div>
            ${card.kills && card.kills > 0 ? `
            <div class="predictor-row">
                <span class="predictor-label">üíÄ Kills</span>
                <span class="predictor-value good">${card.kills}</span>
            </div>
            ` : ''}
        </div>
       
        <div class="predictor-section">
            <div class="predictor-section-title">‚ö†Ô∏è THREAT ASSESSMENT</div>
            <div class="predictor-row">
                <span class="predictor-label">Total Expected Damage</span>
                <span class="predictor-value ${totalThreat >= card.hp ? 'bad' : totalThreat >= card.hp * 0.5 ? 'neutral' : 'good'}">${totalThreat.toFixed(1)}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Survival Odds</span>
                <span class="predictor-value ${survivalChance >= 70 ? 'good' : survivalChance >= 30 ? 'neutral' : 'bad'}">${survivalChance}%</span>
            </div>
            ${maxThreatEnemy ? `
            <div class="predictor-row">
                <span class="predictor-label">Biggest Threat</span>
                <span class="predictor-value bad">${maxThreatEnemy.portrait} ${maxThreatEnemy.name} (${maxThreat.toFixed(1)} dmg)</span>
            </div>
            ` : '<div style="color:#4ade80;padding:4px 0">No active threats!</div>'}
        </div>
       
        ${threatList.length > 0 ? `
        <div class="predictor-section">
            <div class="predictor-section-title">üéØ INCOMING FIRE</div>
            ${threatList.map(t => `
                <div class="predictor-line">
                    <span>${t.enemy.portrait} ${t.enemy.name}</span>
                    <span style="color:#f87171">${t.damage.toFixed(1)} dmg (${t.hitChance}% hit)</span>
                </div>
            `).join('')}
        </div>
        ` : ''}
       
        ${cardAbilities.length > 0 ? `
        <div class="predictor-section">
            <div class="predictor-section-title">‚ö° ABILITIES</div>
            ${cardAbilities.map(ab => `<div class="predictor-line"><span>${ab.icon} ${ab.name}</span><span style="color:#888;font-size:.85em">${ab.desc}</span></div>`).join('')}
        </div>
        ` : ''}
    `;
   
    tooltip.classList.remove('hidden');
    positionPredictorTooltip();
}

function calculateAttackPrediction(attacker, target) {
    // Base damage
    let grossDmg = attacker.fire;
    let sniperBonus = false;
    let leaderBonus = false;
    let eventMod = 0;
    
    // Forest fire modifier (if present)
    if (attacker.forestFire) {
    grossDmg += attacker.forestFire;
    }
    
    // On-attack fire bonus abilities (check all attacker abilities)
    getAbilitiesByEffect(attacker, 'on_attack', 'fire_bonus').forEach(ab => {
        grossDmg += ab.value;
        sniperBonus = true;
    });
   
    // On-attack bonus vs undefended
    if (!target.defending) {
        getAbilitiesByEffect(attacker, 'on_attack', 'bonus_vs_undefended').forEach(ab => {
            grossDmg += ab.value;
            sniperBonus = true;
        });
    }
   
    // Enemy aura debuffs (enemy_fire_reduce) - marksman immune
    if (!hasAbility(attacker, 'marksman')) {
        const enemies = G.field[attacker.faction === 'outlaw' ? 'law' : 'outlaw'];
        if (enemies) {
            enemies.forEach(enemy => {
                getAbilitiesByEffect(enemy, 'aura', 'enemy_fire_reduce').forEach(ab => {
                    grossDmg -= ab.value;
                });
            });
        }
    }
   
    // Aura abilities from allies (ally_fire)
    const allies = G.field[attacker.faction];
    if (allies) {
        allies.forEach(ally => {
            if (ally.id !== attacker.id) {
                getAbilitiesByEffect(ally, 'aura', 'ally_fire').forEach(ab => {
                    grossDmg += ab.value;
                    leaderBonus = true;
                });
            }
        });
    }
   
    // Event modifiers
    G.activeEvents.forEach(e => {
        if (e.stat === 'fire' && (e.faction === 'both' || e.faction === attacker.faction)) {
            eventMod += e.value;
            grossDmg += e.value;
        }
    });
   
    grossDmg = Math.max(0, grossDmg);
   
    // Reductions - Cover FIRST (75%), then Defend (50%), then abilities
    let netDmg = grossDmg;
    let coverReduction = 0;
    let defendReduction = 0;
    let toughReduction = 0;
    let vestReduction = 0;

    const targetInCover = target.coverTurns && target.coverTurns > 0;
   
    // Cover reduction first (75%)
if (targetInCover) {
    coverReduction = Math.round(netDmg * 0.75); // Standard rounding
    netDmg -= coverReduction;
}
   
    // Defend reduction (50% of remaining)
if (target.defending) {
    defendReduction = Math.ceil(netDmg * 0.5); // or Math.round
    netDmg -= defendReduction;
}
   
// On-defend damage reduction abilities (check all target abilities)
getAbilitiesByEffect(target, 'on_defend', 'damage_reduction').forEach(ab => {
    const reduction = Math.floor(netDmg * (ab.value / 100));
    toughReduction += reduction;
    netDmg -= reduction;
});

// Bulletproof vest reduction (30% of remaining damage) ‚Äì only if vest has hits left
if (target.vestHitsRemaining && target.vestHitsRemaining > 0) {
    vestReduction = Math.floor(netDmg * 0.3);
    netDmg -= vestReduction;
}

netDmg = Math.max(0, netDmg);
   
// Hit chance - cover penalizes dodge
let dodgeChance = getEffectiveDodge(target);

// Suppression penalty (each level = -5% dodge)
if (target.suppressionLevel) {
    dodgeChance -= target.suppressionLevel * 5;
}

// Forest dodge bonus (if present)
if (target.forestDodge) {
    dodgeChance += target.forestDodge;
}

// Armor-Piercing: reduce vehicle dodge
if (hasAbility(attacker, 'anti_vehicle') && target.isVehicle) {
    dodgeChance = Math.max(0, dodgeChance - 30);
}

// Now calculate hitChance using the modified dodgeChance
const hitChance = Math.max(5, 100 - dodgeChance);

// Expected damage (accounting for dodge)
const expectedDmg = netDmg * (hitChance / 100);

   
    // Kill chance (only if hit AND damage >= hp)
    const killChance = netDmg >= target.hp ? hitChance : 0;
   
    // HP after hit
    const hpAfter = target.hp - netDmg;
    
    let predictedMP = target.mp;
    if (target.forestMP) predictedMP += target.forestMP;

   
// Calculate accuracy impact
    const attackerAccuracy = getEffectiveAccuracy(attacker);
    const accuracyModifiedHitChance = hitChance * (attackerAccuracy / 100);
    
    return {
        hitChance: accuracyModifiedHitChance,  // ‚Üê Use accuracy-modified hit chance
        attackerAccuracy,  // ‚Üê Add this for display
        grossDmg,
        netDmg,
        minDmg: 0, // miss
        maxDmg: netDmg,
        expectedDmg: netDmg * (accuracyModifiedHitChance / 100),  // ‚Üê Update expected dmg
        killChance: netDmg >= target.hp ? accuracyModifiedHitChance : 0,  // ‚Üê Update kill chance
        hpAfter,
        sniperBonus,
        leaderBonus,
        eventMod,
        coverReduction,
        defendReduction,
        toughReduction,
        targetInCover,
        predictedMP,
        vestReduction,
    };
}

function clearCombatPrediction() {
    const tooltip = $('combatPredictor');
    if (tooltip) {
        tooltip.classList.add('hidden');
        tooltip.innerHTML = ''; // Clear content to prevent flash
    }
}

function showCombatBreakdownTooltip(feedEntry) {
    const data = JSON.parse(feedEntry.dataset.breakdown);
    const { attacker, target, damage, effects, breakdownData, eliminated } = data;
    
    const tooltip = $('combatPredictor');
    tooltip.innerHTML = `
        <div class="predictor-header">
            <div class="predictor-header-portrait">${attacker.portrait}</div>
            <div class="predictor-header-info">
                <div class="predictor-header-name">${attacker.name}</div>
                <div class="predictor-header-status">‚öîÔ∏è vs ${target.name}</div>
            </div>
            <div style="font-size:2em">${target.portrait}</div>
        </div>
        
        <div class="predictor-section">
            <div class="predictor-section-title">üí• COMBAT RESULT</div>
            <div class="predictor-row">
                <span class="predictor-label">Outcome</span>
                <span class="predictor-value ${eliminated ? 'bad' : damage > 0 ? 'neutral' : 'good'}">${eliminated ? 'üíÄ KILL' : damage > 0 ? 'HIT' : 'MISS'}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Damage Dealt</span>
                <span class="predictor-value ${damage > 0 ? 'bad' : 'good'}">${damage}</span>
            </div>
            <div class="predictor-row">
                <span class="predictor-label">Target HP</span>
                <span class="predictor-value">${breakdownData.targetHPBefore || target.hp + damage} ‚Üí ${breakdownData.targetHPAfter || target.hp}</span>
            </div>
        </div>
        
        <div class="predictor-section">
            <div class="predictor-section-title">üéØ HIT CHANCE BREAKDOWN</div>
            <div class="predictor-line">
                <span>Base Dodge</span>
                <span>${target.dodge || 10}%</span>
            </div>
            ${breakdownData.suppressionPenaltyDodge > 0 ? `
            <div class="predictor-line sub">
                <span>- Suppression Penalty</span>
                <span>-${breakdownData.suppressionPenaltyDodge.toFixed(1)}%</span>
            </div>` : ''}
            ${breakdownData.targetForestDodge ? `
            <div class="predictor-line ${breakdownData.targetForestDodge > 0 ? 'add' : 'sub'}">
                <span>üå≤ Forest</span>
                <span>${breakdownData.targetForestDodge > 0 ? '+' : ''}${breakdownData.targetForestDodge}%</span>
            </div>` : ''}
            ${breakdownData.moralePenaltyDodge !== '0%' ? `
            <div class="predictor-line sub">
                <span>- Morale Penalty</span>
                <span>${breakdownData.moralePenaltyDodge}</span>
            </div>` : ''}
            <div class="predictor-line result">
                <span>Effective Dodge</span>
                <span>${breakdownData.dodgeChance.toFixed(1)}%</span>
            </div>
            <div class="predictor-line result">
                <span>Base Hit Chance</span>
                <span>${(breakdownData.baseHitChance || 0).toFixed(1)}%</span>
            </div>
            <div class="predictor-line">
                <span>Attacker Accuracy</span>
                <span>${breakdownData.attackerAccuracy}%</span>
            </div>
            ${breakdownData.suppressionPenaltyAccuracy > 0 ? `
            <div class="predictor-line sub" style="font-size:0.85em;margin-left:12px">
                <span>‚îî Suppression: -${breakdownData.suppressionPenaltyAccuracy.toFixed(1)}%</span>
            </div>` : ''}
            ${breakdownData.moralePenaltyAccuracy !== '0%' ? `
            <div class="predictor-line sub" style="font-size:0.85em;margin-left:12px">
                <span>‚îî Morale: ${breakdownData.moralePenaltyAccuracy}</span>
            </div>` : ''}
            <div class="predictor-line result" style="border-top:2px solid #fbbf24;padding-top:6px;margin-top:4px">
                <span style="font-weight:700">Final Hit Chance</span>
                <span style="font-weight:700;color:#fbbf24">${(breakdownData.effectiveHitChance || 0).toFixed(1)}%</span>
            </div>
        </div>
        
        <div class="predictor-section">
            <div class="predictor-section-title">üß† MORALE STATES</div>
            <div class="predictor-line">
                <span>Target Morale</span>
                <span style="color:${breakdownData.targetMorale >= 85 ? '#4ade80' : breakdownData.targetMorale >= 51 ? '#fbbf24' : '#f87171'}">${breakdownData.targetMorale}/100</span>
            </div>
            <div class="predictor-line" style="font-size:0.85em;margin-left:12px;color:#999">
                <span>Status</span>
                <span>${breakdownData.targetMoraleStatus}</span>
            </div>
            <div class="predictor-line">
                <span>Attacker Morale</span>
                <span style="color:${breakdownData.attackerMorale >= 85 ? '#4ade80' : breakdownData.attackerMorale >= 51 ? '#fbbf24' : '#f87171'}">${breakdownData.attackerMorale}/100</span>
            </div>
            <div class="predictor-line" style="font-size:0.85em;margin-left:12px;color:#999">
                <span>Status</span>
                <span>${breakdownData.attackerMoraleStatus}</span>
            </div>
        </div>
        
        <div class="predictor-section">
            <div class="predictor-section-title">üí• DAMAGE CALCULATION</div>
            <div class="predictor-line">
                <span>Base Fire</span>
                <span>${breakdownData.baseFire}</span>
            </div>
            ${breakdownData.customAttackBonus > 0 ? `<div class="predictor-line add"><span>+ Abilities</span><span>+${breakdownData.customAttackBonus}</span></div>` : ''}
            ${breakdownData.leaderBonus ? `<div class="predictor-line add"><span>+ Aura</span><span>+1</span></div>` : ''}
            ${breakdownData.eventMod !== 0 ? `<div class="predictor-line ${breakdownData.eventMod > 0 ? 'add' : 'sub'}"><span>Events</span><span>${breakdownData.eventMod > 0 ? '+' : ''}${breakdownData.eventMod}</span></div>` : ''}
            <div class="predictor-line result">
                <span>Gross Damage</span>
                <span>${breakdownData.grossDamage}</span>
            </div>
            ${breakdownData.coverReduction ? `<div class="predictor-line sub"><span>- Cover (75%)</span><span>-${breakdownData.coverReduction}</span></div>` : ''}
            ${breakdownData.defendReduction ? `<div class="predictor-line sub"><span>- Defend (50%)</span><span>-${breakdownData.defendReduction}</span></div>` : ''}
            ${breakdownData.abilityReduction ? `<div class="predictor-line sub"><span>- Abilities</span><span>-${breakdownData.abilityReduction}</span></div>` : ''}
            <div class="predictor-line result" style="border-top:2px solid #c9302c;padding-top:6px;margin-top:4px">
                <span style="font-weight:700">Net Damage</span>
                <span style="font-weight:700;color:${damage > 0 ? '#f87171' : '#4ade80'}">${damage}</span>
            </div>
        </div>
        
        ${effects && effects.length > 0 ? `
        <div class="predictor-section">
            <div class="predictor-section-title">‚ú® EFFECTS</div>
            ${effects.map(e => `<div class="predictor-line"><span>${e.text}</span></div>`).join('')}
        </div>
        ` : ''}
        
        ${breakdownData.triggeredAbilities && breakdownData.triggeredAbilities.length > 0 ? `
        <div class="predictor-section">
            <div class="predictor-section-title">‚ö° TRIGGERED ABILITIES</div>
            ${breakdownData.triggeredAbilities.map(t => {
                const color = t.failed ? '#666' : '#4ade80';
                const icon = t.failed ? '‚úó' : '‚úì';
                return `<div class="predictor-line">
                    <span>${t.ability.icon} ${t.ability.name}</span>
                    <span style="color:${color}">${icon} ${t.result}</span>
                </div>`;
            }).join('')}
        </div>
        ` : ''}
    `;
    
    tooltip.classList.remove('hidden');
    positionPredictorTooltip();
}

function showMissBreakdownTooltip(feedEntry) {
    const data = JSON.parse(feedEntry.dataset.missBreakdown);
    const { attacker, target, hitChance, attackerAccuracy } = data;
    
    const targetDodge = target ? getEffectiveDodge(target) : 0;
    
    const tooltip = $('combatPredictor');
    tooltip.innerHTML = `
        <div class="predictor-header">
            <div class="predictor-header-portrait">${attacker.portrait}</div>
            <div class="predictor-header-info">
                <div class="predictor-header-name">${attacker.name}</div>
                <div class="predictor-header-status">üí® MISSED ${target.name}</div>
            </div>
            <div style="font-size:2em">${target.portrait}</div>
        </div>
        
        <div class="predictor-section">
            <div class="predictor-section-title">üí® MISS BREAKDOWN</div>
            <div class="predictor-line">
                <span>Attacker Accuracy</span>
                <span>${attackerAccuracy}%</span>
            </div>
            <div class="predictor-line">
                <span>Target Dodge</span>
                <span>${targetDodge}%</span>
            </div>
            <div class="predictor-line result">
                <span>Hit Chance</span>
                <span style="color:#fbbf24">${hitChance.toFixed(1)}%</span>
            </div>
            <div class="predictor-line result">
                <span>Result</span>
                <span style="color:#4ade80">DODGED!</span>
            </div>
        </div>
    `;
    
    tooltip.classList.remove('hidden');
    positionPredictorTooltip();
}

// Hide tooltip when mouse leaves the game area entirely
document.addEventListener('mouseleave', function() {
    clearCombatPrediction();
});

// Also hide when clicking anywhere outside a card
document.addEventListener('click', function(e) {
    if (!e.target.closest('.card')) {
        clearCombatPrediction();
    }
});

// ============ GAME FLOW ============
function updateGameMode() {
    const mode = document.querySelector('input[name="gameMode"]:checked').value;
    const diffSection = $('aiDifficultySection');
    if (mode === 'pvp') {
        diffSection.style.display = 'none';
    } else {
        diffSection.style.display = 'block';
    }
}

function startBankRobbery() {
    // MUST load data first ‚Äî this builds G.allCards from defaults + customs
    loadData();

    // Shuffle and pick random number of cards (3-15) from each faction
    function getRandomCards(cards, min, max) {
        const count = min + Math.floor(Math.random() * (max - min + 1));
        const shuffled = [...cards].sort(() => Math.random() - 0.5);
        return shuffled.slice(0, Math.min(count, cards.length));
    }

    // Set bank robbery mode
    G.bankRobberyMode = true;

    // Get random cards from available pool (now safe because loadData() ran)
    const outlawCards = getRandomCards(G.allCards.outlaw, 3, 15);
    const lawCards    = getRandomCards(G.allCards.law,    3, 15);

    // Store them temporarily
    G.bankRobberyDecks = {
        outlaw: outlawCards.map(c => ({...c, actionsUsed: 0, bleeding: false, kills: 0, vestDurability: 3, state: 100})),
        law:    lawCards.map(c => ({...c, actionsUsed: 0, bleeding: false, kills: 0, vestDurability: 3, state: 100}))
    };

    // Quick alert
    alert(`üè¶ BANK ROBBERY!\n\nOutlaws: ${outlawCards.length} cards\nLaw: ${lawCards.length} cards\n\nNo two robberies are the same!`);

    // Start the game (this will use bankRobberyDecks in startGame())
    startGame();
}

function startGame() {
    clearCombatPrediction(); // Clear any old tooltips
    loadData();
   
    // Configure AI from menu selection
    const mode = document.querySelector('input[name="gameMode"]:checked').value;
    if (mode === 'pvp') {
        G.aiEnabled = false;
    } else if (mode === 'ai_law') {
        G.aiEnabled = true;
        G.aiFaction = 'law';
    } else if (mode === 'ai_outlaw') {
        G.aiEnabled = true;
        G.aiFaction = 'outlaw';
    }
    G.aiDifficulty = $('aiDifficulty').value;
    G.aiThinking = false;
   
    // Build decks from bank robbery or saved/default
    ['outlaw', 'law'].forEach(faction => {
        // Check if we're in bank robbery mode
        if (G.bankRobberyMode && G.bankRobberyDecks) {
            G.decks[faction] = G.bankRobberyDecks[faction];
        } else {
            const saved = G.savedDecks[faction];
            if (saved && saved.length > 0) {
                G.decks[faction] = saved.map(id => {
                    const baseId = id.replace(/_\d{1,2}$/, '');
                    const card = G.allCards[faction].find(c => c.id === baseId || c.id === id);
return card ? {
    ...card, 
    id: id, 
    actionsUsed: 0, 
    bleeding: false, 
    kills: 0, 
    vestDurability: 3,
    hvAmmo: card.abilities && card.abilities.includes('high_velocity') ? 1 : undefined,
    accuracy: 100
} : null;
                }).filter(Boolean);
            } else {
                // Default: 2 copies of each default card
                G.decks[faction] = [];
                DEFAULT_CARDS[faction].forEach(c => {
G.decks[faction].push({
    ...c, 
    actionsUsed: 0, 
    bleeding: false, 
    kills: 0, 
    vestDurability: 3,
    hvAmmo: c.abilities && c.abilities.includes('high_velocity') ? 1 : undefined,
    accuracy: 100,
    state: 100
});
G.decks[faction].push({
    ...c, 
    id: c.id + '_2', 
    actionsUsed: 0, 
    bleeding: false, 
    kills: 0, 
    vestDurability: 3,
    hvAmmo: c.abilities && c.abilities.includes('high_velocity') ? 1 : undefined,
    accuracy: 100,
    state: 100
});
                });
            }
        }
        shuffle(G.decks[faction]);
        G.hands[faction] = [];
        G.field[faction] = [];
    });
   
      // Reset bank robbery mode after decks are set
    G.bankRobberyMode = false;
    G.bankRobberyDecks = null;
   
    // Reset state
    G.turn = 'outlaw';
    G.phase = 'deploy';
    G.round = 1;
    G.scores = { outlaw: 0, law: 0 };
    G.selected = null;
    G.actionMode = null;
    G.activeEvents = [];
   
    // Reset nerd stats
    G.stats = {
        outlaw: { dmgDealt: 0, dmgTaken: 0, shotsFired: 0, shotsHit: 0, kills: 0, ammoUsed: 0, rallies: 0, rallySuccess: 0 },
        law: { dmgDealt: 0, dmgTaken: 0, shotsFired: 0, shotsHit: 0, kills: 0, ammoUsed: 0, rallies: 0, rallySuccess: 0 }
    };
   
    // Clear action feeds
    $('outlawFeed').innerHTML = '';
    $('lawFeed').innerHTML = '';
    
    // Clear combat feeds
    $('outlawCombatFeed').innerHTML = '';
    $('outlawCombatFeed').innerHTML = '';
    
   
    // Draw ALL cards into hands at game start
    drawCards('outlaw', G.decks.outlaw.length);
    drawCards('law', G.decks.law.length);
   
    hide('menuScreen');
    show('gameScreen');
   
    const modeText = G.aiEnabled ? `You are ${G.aiFaction === 'law' ? 'OUTLAWS' : 'THE LAW'}. AI controls ${G.aiFaction.toUpperCase()}.` : 'Two player mode.';
    addEventToFeeds('Battle Begins!', modeText);
    updateUI();
   
    // If AI goes first (player chose Law), trigger AI turn
    if (G.aiEnabled && G.aiFaction === 'outlaw') {
        setTimeout(() => aiTakeTurn(), 1000);
    }
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function drawCards(faction, n) {
    for (let i = 0; i < n && G.decks[faction].length > 0; i++) {
        G.hands[faction].push(G.decks[faction].pop());
    }
}

function isPlayerTurn() {
    if (G.aiThinking) return false;
    if (G.aiEnabled && G.turn === G.aiFaction) return false;
    return true;
}

function deployCard() {
    if (!isPlayerTurn()) return;
    if (G.hands[G.turn].length === 0) {
        log('No cards in hand!', G.turn);
        return;
    }
    $('handTitle').textContent = G.turn.toUpperCase() + ' HAND - Click to Deploy';
    $('handCards').innerHTML = G.hands[G.turn].map(c => renderCard(c, true)).join('');
    show('handModal');
}

function selectFromHand(id) {
    if (!isPlayerTurn()) return;
    const idx = G.hands[G.turn].findIndex(c => c.id === id);
    if (idx === -1) return;
   
    const card = G.hands[G.turn].splice(idx, 1)[0];
    card.actionsUsed = 0;
    card.state = 100;  // Initialize morale state

// Initialize grenades for Grenadier ability
if (hasAbility(card, 'grenadier')) {
    card.grenades = card.grenades || 1; // Max 1 grenade
}

// Initialize molotovs for Molotov ability
if (hasAbility(card, 'molotov')) {
    card.molotovs = card.molotovs || 2; // Max 2 molotovs
}

// Initialize HV ammo for High Velocity (1 round total per deploy)
if (hasAbility(card, 'high_velocity')) {
    card.hvAmmo = 1;
}

// Initialize Arrest Warrant charges (1 use total per deploy)
if (hasAbility(card, 'arrestwarrant')) {
    card.arrestCharges = 1;
}

if (hasAbility(card, 'timed_dynamite')) {
    card.dynamiteCharges = 1;
}


// Initialize Overpressure ammo (3 rounds total per deploy)
if (hasAbility(card, 'overpressure')) {
    card.overpressureAmmo = 3;
}

// Initialize vehicle properties
if (card.isVehicle) {
    card.passengers = card.passengers || [];
}

// Initialize permanent cover for Marksman (sniper in hiding)
if (hasAbility(card, 'marksman')) {
    card.coverTurns = 999; // Permanent cover
    card.defending = true; // Always defending
}

if (hasAbility(card, 'folkhero')) {
    card.folkHeroUses = 1;  // One use per deploy
}

if (hasAbility(card, 'lewisgun')) {
    card.lewisJammed = false;      // Track jam status
    card.lewisShotsFired = 0;      // Track shots this turn for heat buildup
}

// Initialize forest environmental effects
if (card.isEnvironment && card.name === 'Dense Forest') {
    // Apply initial forest effects to ALL cards on field
    [...G.field.outlaw, ...G.field.law].forEach(c => {
        if (c.isEnvironment) return;
        
        // Random dodge bonus (+5% to +15%)
        const dodgeRoll = 5 + Math.floor(Math.random() * 11);
        c.forestDodge = dodgeRoll;
        
        // Random fire modifier (-3 to +3)
        const fireRoll = Math.floor(Math.random() * 7) - 3;
        c.forestFire = fireRoll;
        
        // Random accuracy modifier (-10% to +10%)
       const accRoll = Math.floor(Math.random() * 21) - 10;
       c.forestAccuracy = accRoll;
       
       // Random move modifier (-2 to +2)
       const moveRoll = Math.floor(Math.random() * 5) - 2;
       c.forestMove = moveRoll;
        
        addToFeed(G.turn, 'üå≤', `${card.name} enters forest cover`, 
    `Dodge: +${dodgeRoll}%, Fire: ${fireRoll >= 0 ? '+' : ''}${fireRoll}, Move: ${moveRoll >= 0 ? '+' : ''}${moveRoll}, Acc: ${accRoll >= 0 ? '+' : ''}${accRoll}%`, 'event');
    });
    
    addEventToFeeds('üå≤ Dense Forest Deployed!', 'Chaotic cover affects everyone');
}

G.field[G.turn].push(card);

// Init Signal Charge charges
if (hasAbility(card, 'signal_charge')) {
    card.signalCharges = 1;  // One use per deploy
}

    // Check if forest is already deployed - apply modifiers to newly deployed card
    const forestDeployed = [...G.field.outlaw, ...G.field.law].some(c => c.isEnvironment && c.name === 'Dense Forest');
    if (forestDeployed && !card.isEnvironment) {
        // Random dodge bonus (+5% to +15%)
        const dodgeRoll = 5 + Math.floor(Math.random() * 11);
        card.forestDodge = dodgeRoll;
        
        // Random fire modifier (-2 to +3)
        const fireRoll = Math.floor(Math.random() * 7) - 3;
        card.forestFire = fireRoll;
        
    // NEW: Random move modifier (-2 to +2)
    const moveRoll = Math.floor(Math.random() * 5) - 2;  // -2, -1, 0, +1, +2
    card.forestMove = moveRoll;
    
    // Random accuracy modifier (-10% to +10%)
    const accRoll = Math.floor(Math.random() * 21) - 10;
    card.forestAccuracy = accRoll;
        
    addToFeed(G.turn, 'üå≤', `${card.name} enters forest cover`, 
    `Dodge: +${dodgeRoll}%, Fire: ${fireRoll >= 0 ? '+' : ''}${fireRoll}, Move: ${moveRoll >= 0 ? '+' : ''}${moveRoll}, Acc: ${accRoll >= 0 ? '+' : ''}${accRoll}%`, 'event');
    }
   
    addToFeed(G.turn, 'üì•', `${card.name} deployed!`, `HP: ${card.hp} | Fire: ${card.fire}`, 'deploy');
    closeHand();
    updateUI();
}

function closeHand() {
    hide('handModal');
}

function selectCard(id) {
    if (!isPlayerTurn()) return;
    
    const faction = G.turn;
    const enemy = faction === 'outlaw' ? 'law' : 'outlaw';
    
    // Arrest Warrant: Block selection of arrested friendly cards
    const card = G.field[faction].find(c => c.id === id);
    if (card && card.arrested) {
        log(`${card.name} is ARRESTED and cannot act!`, faction);
        return;
    }
    
// Check if clicking vehicle while in board mode - MUST CHECK BEFORE ENEMY TARGETING
const vehicleTarget = G.field[faction].find(c => c.id === id);
if (vehicleTarget && vehicleTarget.isVehicle && G.actionMode === 'board') {
    performBoarding(G.selected, vehicleTarget);
    G.actionMode = null;
    updateUI();
    return;
}

// Check if clicking friendly card while in share mode - MUST CHECK BEFORE ENEMY TARGETING
const friendlyTargetEarly = G.field[faction].find(c => c.id === id);
if (friendlyTargetEarly && G.actionMode === 'share') {
    if (friendlyTargetEarly.id === G.selected?.id) {
        log(`Can't share ammo with yourself!`, faction);
        return;
    }
    performShareAmmo(G.selected, friendlyTargetEarly);
    G.actionMode = null;
    updateUI();
    return;
}
    
// Handle action modes (attack / suppress / arrest)
if (G.actionMode && G.selected) {
    const enemy = G.turn === 'outlaw' ? 'law' : 'outlaw';
    const clickedCard = [...G.field[G.turn], ...G.field[enemy]].find(c => c.id === id);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // CASE 1: Clicked an ENEMY ‚Üí try to perform the action
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const target = G.field[enemy].find(c => c.id === id);
    if (target) {
        // Safety checks (same as before)
        if (target.arrested) {
            log(`Cannot target ${target.name} - already ARRESTED!`, G.turn);
            return;
        }
        if (target.inVehicle) {
            log(`${target.name} is in a vehicle and cannot be targeted!`, G.turn);
            return;
        }
        if (target.isEnvironment) {
            log(`${target.name} is an environmental card and cannot be targeted!`, G.turn);
            return;
        }

        // Prevent friendly fire (only matters in attack mode)
        if (G.actionMode === 'attack' && target.faction === G.turn) {
            log(`Can't shoot your own gang, Cap!`, G.turn);
            return;
        }

        // Execute the actual action
        if (G.actionMode === 'attack') {
            performAttack(G.selected, target);
        } else if (G.actionMode === 'suppress') {
            performSuppress(G.selected, target);
        } else if (G.actionMode === 'arrest') {
            performArrest(G.selected, target);
            G.actionMode = null;           // Arrest is one-shot
        }

        updateUI();
        return;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // CASE 2: Clicked ANYTHING ELSE (own card, empty space, etc)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚Üí If in attack or suppress mode ‚Üí CANCEL mode when clicking own side
    if (G.actionMode === 'attack' || G.actionMode === 'suppress') {
        // Optional: only cancel if clicked own selected card (more intuitive)
        if (clickedCard && clickedCard.faction === G.turn && clickedCard.id === G.selected.id) {
            G.actionMode = null;
            log(`Attack mode cancelled ‚Äî back to selecting`, G.turn);
        } else {
            // Or cancel on ANY own-side click (even more forgiving)
            G.actionMode = null;
            log(`Action mode cancelled`, G.turn);
        }
        updateUI();
        return;
    }

    // Arrest mode doesn't cancel on own click (keeps one-shot feel)
}
    
    // Clicked own card while in other action mode - just select it but KEEP action mode
    // so user can still click enemy after
    const ownCard = G.field[faction].find(c => c.id === id);
    if (ownCard) {
        // Safe null check: only compare if G.selected exists
        if (!G.selected || G.selected.id !== ownCard.id) {
            G.selected = ownCard;
            G.actionMode = null; // Reset action mode when switching cards
            log(`Selected ${ownCard.name}`, faction);
        }
        updateUI();
        return;
    }
    
    // Normal selection (no action mode active)
    if (card) {
        if (card.actionsUsed >= getEffectiveMove(card)) {
            log(`${card.name} has no actions remaining!`, faction);
        }
        G.selected = card;
        G.actionMode = null;
        updateUI();
    }
}

function attackMode() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card first!', G.turn);
        return;
    }
    if (G.selected.isVehicle) {
        log(`${G.selected.name} is a vehicle and cannot attack!`, G.turn);
        return;
    }
    if (G.selected.isEnvironment) {
        log(`${G.selected.name} is an environmental card and cannot attack!`, G.turn);
        return;
    }
    const effectiveMove = getEffectiveMove(G.selected);
    if (G.selected.actionsUsed >= effectiveMove) {
        log(`${G.selected.name} has no actions left!`, G.turn);
        return;
    }    
    if (G.actionMode === 'attack') {
        G.actionMode = null;
        log('Attack mode OFF ‚Äî back to selecting allies', G.turn);
    } else {
        G.actionMode = 'attack';
        log('Attack mode ON ‚Äî click enemy targets (click Attack again to cancel)', G.turn);
    }
    if (G.selected.ammo <= 0) {
        log(`${G.selected.name} is out of ammo!`, G.turn);
        return;
    }
    if (G.selected.lewisJammed) {
    log(`${G.selected.name}'s Lewis Gun is JAMMED! (clears next turn)`, G.turn);
    return;
}
    G.actionMode = 'attack';
    log('Select enemy target...', G.turn);
}

function suppressMode() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card first!', G.turn);
        return;
    }
    const effectiveMoveSupp = getEffectiveMove(G.selected);
    if (G.selected.actionsUsed >= effectiveMoveSupp) {
        log(`${G.selected.name} has no actions left!`, G.turn);
        return;
    }
    // Suppression requires at least 1 ammo (will cost half of current ammo)
    if (G.selected.ammo <= 0) {
        log(`${G.selected.name} has no ammo to suppress with!`, G.turn);
        return;
    }
    G.actionMode = 'suppress';
    const ammoCost = Math.ceil(G.selected.ammo / 2);
    log(`Select target to suppress... (will cost ${ammoCost} ammo)`, G.turn);
}

function arrestMode() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card first!', G.turn);
        return;
    }
    const effectiveMove = getEffectiveMove(G.selected);
    if (G.selected.actionsUsed + 2 > effectiveMove) {
        log(`${G.selected.name} needs 2+ actions to ARREST!`, G.turn);
        return;
    }
    G.actionMode = 'arrest';
}

function performAttack(attacker, target) {
    // Calculate effective move (including event mods)
    const effectiveMove = getEffectiveMove(attacker);
   
if (!hasAbility(attacker, 'marksman')) {
    playSound('attack');
} else {
    playSound('marksman');  // ‚Üê Play marksman sound at the START of attack
}
    
if (attacker.ammo <= 0) {
    return;
}
   
    attacker.ammo--;
    attacker.actionsUsed++;
   
    // Track stats
    G.stats[attacker.faction].shotsFired++;
    G.stats[attacker.faction].ammoUsed++;
   
    // Track which abilities triggered for the breakdown
    const triggeredAbilities = [];
   
    // Dodge check - roll vs target's effective dodge stat
    let dodgeChance = getEffectiveDodge(target);
    
    // Armor-Piercing: Reduce dodge vs vehicles (higher hit chance)
const antiVehicleAbs = getAbilitiesByEffect(attacker, 'on_attack', 'anti_vehicle');
antiVehicleAbs.forEach(ab => {
    if (target.isVehicle) {
        dodgeChance = Math.max(0, dodgeChance - ab.value.hitBonus);
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `-${ab.value.hitBonus}% vehicle dodge` });
    } else {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `N/A (not vehicle)`, failed: true });
    }
});
   
    // Check for on_defend dodge_bonus abilities
    getAbilitiesByEffect(target, 'on_defend', 'dodge_bonus').forEach(ab => {
        dodgeChance += ab.value;
        triggeredAbilities.push({ ability: ab, source: 'defender', result: `+${ab.value}% dodge` });
    });
    dodgeChance = Math.min(95, dodgeChance); // Cap at 95%
    
// ACCURACY SYSTEM: Attacker's accuracy affects final hit chance
const attackerAccuracy = getEffectiveAccuracy(attacker);
const baseHitChance = 100 - dodgeChance;
const effectiveHitChance = baseHitChance * (attackerAccuracy / 100);
   
const hitRoll = Math.floor(Math.random() * 100);
const missed = hitRoll >= effectiveHitChance;  // ‚Üê FIX: Use accuracy-modified hit chance
   
if (missed) {
// State changes for near miss
const missFear = Math.max(8, Math.floor(getEffectiveFire(attacker) * 1.6) + 3);
target.state = Math.max(0, (target.state || 100) - missFear);
attacker.state = Math.max(0, (attacker.state || 100) - Math.floor(getEffectiveFire(attacker) * 0.6));
    
    // Add suppression even on miss - being shot at is scary!
    const effectiveSupp = getEffectiveSupp(attacker);
    const missSuppression = 0.3 + (effectiveSupp * 0.1);
    target.suppressed = (target.suppressed || 0) + missSuppression;
   
    // Add to BOTH combat feeds
    addMissToCombatFeed(attacker.faction, attacker, target, effectiveHitChance, attackerAccuracy);
    addMissToCombatFeed(target.faction, attacker, target, effectiveHitChance, attackerAccuracy);
    
    // BLUE PULSE FOR MISS (add this new code)
    setTimeout(() => {
        const targetElement = document.querySelector(`.card[data-id="${target.id}"]`);
        if (targetElement) {
            const originalTransform = targetElement.style.transform;
            const textElements = targetElement.querySelectorAll('.card-name, .card-stats span, .stat-hp, .stat-ammo, .stat-move, .stat-fire, .stat-supp, .stat-dodge');
            const originalColors = Array.from(textElements).map(el => el.style.color || getComputedStyle(el).color);
            
            // PULSE BLUE + SMALLER SCALE (dodge feedback)
            targetElement.style.transform = 'scale(1.05)';
            targetElement.style.transition = 'all 0.1s ease';
            textElements.forEach(el => {
                el.style.color = '#60a5fa'; // Blue for dodge
                el.style.transition = 'color 0.1s ease';
            });
            
            setTimeout(() => {
                targetElement.style.transform = 'scale(1.08)';
                textElements.forEach(el => el.style.color = '#3b82f6');
            }, 80);
            
            setTimeout(() => {
                targetElement.style.transform = originalTransform;
                targetElement.style.transition = 'all 0.15s ease';
                textElements.forEach((el, i) => {
                    el.style.color = originalColors[i];
                    el.style.transition = 'color 0.15s ease';
                });
            }, 250);
        }
    }, 50);
    
    G.selected = attacker;
    updateUI();
    return;
}
   
// Track hit
G.stats[attacker.faction].shotsHit++;

// State changes for successful hit
const hitFear = Math.max(12, Math.floor(getEffectiveFire(attacker) * 3.2) + 4);  // ‚Üê Cranked: Fire 8 = -29‚Äì30, Fire 12 = -42‚Äì43
target.state = Math.max(0, (target.state || 100) - hitFear);
attacker.state = Math.min(100, (attacker.state || 100) + Math.floor(getEffectiveFire(attacker) * 0.9));  // slight confidence bump
target.damagedThisTurn = true;
   
    // Calculate damage with detailed breakdown
    const baseFire = attacker.fire;
    const forestFireMod = attacker.forestFire || 0;
    let grossDamage = baseFire + forestFireMod;
    let customAttackBonus = 0; 
    const effects = [];
    const details = [`Base damage: ${baseFire}`];
   
    // Track bonuses for breakdown
    let leaderBonus = false;
    let eventMod = 0;
   
    // Track which abilities have been applied (for post-damage effects)
    const attackerOnAttackAbilities = getAbilitiesByTrigger(attacker, 'on_attack');
   
    // On-attack abilities (fire_bonus, double_damage, bonus_vs_undefended)
    attackerOnAttackAbilities.forEach(ab => {
        if (ab.effect === 'fire_bonus') {
            grossDamage += ab.value;
            customAttackBonus += ab.value;
            effects.push({ text: `${ab.icon} ${ab.name} +${ab.value}`, type: 'buff' });
            details.push(`${ab.name}: +${ab.value}`);
            triggeredAbilities.push({ ability: ab, source: 'attacker', result: `+${ab.value} damage` });
        } else if (ab.effect === 'double_damage') {
            if (Math.random() * 100 < ab.value) {
                grossDamage *= 2;
                effects.push({ text: `${ab.icon} DOUBLE!`, type: 'buff' });
                details.push('Double damage proc!');
                triggeredAbilities.push({ ability: ab, source: 'attacker', result: `DOUBLED! (${ab.value}% chance)` });
            } else {
                triggeredAbilities.push({ ability: ab, source: 'attacker', result: `No proc (${ab.value}% chance)`, failed: true });
            }
        } else if (ab.effect === 'bonus_vs_undefended') {
            if (!target.defending) {
                grossDamage += ab.value;
                customAttackBonus += ab.value;
                effects.push({ text: `${ab.icon} Exposed +${ab.value}`, type: 'buff' });
                details.push(`${ab.name}: +${ab.value}`);
                triggeredAbilities.push({ ability: ab, source: 'attacker', result: `+${ab.value} (not defending)` });
            } else {
                triggeredAbilities.push({ ability: ab, source: 'attacker', result: `Blocked (defending)`, failed: true });
            }
        }
        // Note: lifesteal, execute, attack_suppress are applied after damage calculation
    });
   
    // Enemy aura debuffs (enemy_fire_reduce) - marksman immune
    if (!hasAbility(attacker, 'marksman')) {
        const enemies = G.field[attacker.faction === 'outlaw' ? 'law' : 'outlaw'];
        enemies.forEach(enemy => {
            getAbilitiesByEffect(enemy, 'aura', 'enemy_fire_reduce').forEach(ab => {
                grossDamage -= ab.value;
                effects.push({ text: `${ab.icon} ${enemy.name} -${ab.value}`, type: 'debuff' });
                details.push(`${ab.name}: -${ab.value}`);
                triggeredAbilities.push({ ability: ab, source: 'enemy aura', result: `-${ab.value} damage`, from: enemy.name });
            });
        });
    }
   
    // Aura abilities from allies (ally_fire)
    const allies = G.field[attacker.faction];
    allies.forEach(ally => {
        if (ally.id !== attacker.id) {
            getAbilitiesByEffect(ally, 'aura', 'ally_fire').forEach(ab => {
                grossDamage += ab.value;
                leaderBonus = true;
                effects.push({ text: `${ab.icon} ${ally.name} +${ab.value}`, type: 'buff' });
                details.push(`${ab.name} bonus: +${ab.value}`);
                triggeredAbilities.push({ ability: ab, source: 'ally aura', result: `+${ab.value} damage`, from: ally.name });
            });
        }
    });
   
    // Apply active event mods
    G.activeEvents.forEach(e => {
        if (e.stat === 'fire' && (e.faction === 'both' || e.faction === attacker.faction)) {
            grossDamage += e.value;
            eventMod += e.value;
            effects.push({ text: `${e.name} ${e.value > 0 ? '+' : ''}${e.value}`, type: e.value > 0 ? 'buff' : 'debuff' });
            details.push(`${e.name}: ${e.value > 0 ? '+' : ''}${e.value}`);
        }
    });
   
    grossDamage = Math.max(0, grossDamage);
    let damage = grossDamage;
    
    
    // Armor-Piercing: Extra damage vs vehicles
antiVehicleAbs.forEach(ab => {
    if (target.isVehicle) {
        damage += ab.value.dmgBonus;
        grossDamage += ab.value.dmgBonus;
        customAttackBonus += ab.value.dmgBonus;
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `+${ab.value.dmgBonus} vs vehicle` });
        details.push(`Anti-Vehicle: +${ab.value.dmgBonus}`);
        effects.push({ text: `${ab.icon} AP +${ab.value.dmgBonus}`, type: 'buff' });
    }
});
   
    // Defense reduction - Apply COVER first (75%), then DEFEND (50%)
    let blocked = 0;
    let coverReduction = 0;
    let defendReduction = 0;
    let abilityReduction = 0;
   
    // Cover provides 75% damage reduction FIRST (biggest reduction)
    if (target.coverTurns && target.coverTurns > 0) {
        coverReduction = Math.floor(damage * 0.75);
        damage = damage - coverReduction;
        effects.push({ text: `ü™® Cover -${coverReduction}`, type: 'debuff' });
        details.push(`Cover blocked: -${coverReduction}`);
        // Always show cover was active in triggered abilities
        triggeredAbilities.push({ ability: { icon: 'ü™®', name: 'Take Cover' }, source: 'defender', result: `-${coverReduction} damage (75%)` });
    }
   
    // Then apply Defend (50% of remaining)
    if (target.defending) {
        defendReduction = Math.floor(damage * 0.5);
        blocked = defendReduction;
        damage = damage - defendReduction;
        effects.push({ text: `üõ°Ô∏è Defend -${defendReduction}`, type: 'debuff' });
        details.push(`Defend blocked: -${defendReduction}`);
       
        // Only consume defend if NOT in cover (cover maintains defend)
        if (!target.coverTurns || target.coverTurns <= 0) {
            target.defending = false;
        }
    }
   
    // Get target's on_defend abilities
    const targetOnDefendAbilities = getAbilitiesByTrigger(target, 'on_defend');
   
        // Fortified damage reduction
    if (target.fortified && target.fortified > 0) {
        damage = Math.floor(damage * 0.7);  // -30% damage
        details.push('Fortified: -30% damage');
    }
   
    // On-defend abilities (damage_reduction, reflect)
    targetOnDefendAbilities.forEach(ab => {
        if (ab.effect === 'damage_reduction') {
            const reduction = Math.round(damage * (ab.value / 100));
            abilityReduction += reduction;
            damage = damage - reduction;
           
if (ab.id === 'bulletproof' && target.vestDurability > 0) {
    target.vestDurability--;
    
}

            details.push(`${ab.name} reduced: -${reduction}`);
            triggeredAbilities.push({ ability: ab, source: 'defender', result: `-${reduction} damage (${ab.value}%)` });
        } else if (ab.effect === 'reflect') {
            const reflectDamage = Math.round(grossDamage * (ab.value / 100));
            if (reflectDamage > 0) {
                attacker.hp -= reflectDamage;
                effects.push({ text: `${ab.icon} Reflect ${reflectDamage}`, type: 'debuff' });
                triggeredAbilities.push({ ability: ab, source: 'defender', result: `${reflectDamage} reflected to attacker` });
            }
        }
    });
   
    damage = Math.max(0, damage);
    const oldHP = target.hp;
target.hp -= damage;
let eliminated = target.hp <= 0;

// Signal Charge Model 3 - one-use flash debuff on 1‚Äì3 random enemies
const signalAbs = getAbilitiesByEffect(attacker, 'on_attack', 'signal_charge');
signalAbs.forEach(ab => {
    if (attacker.signalCharges > 0 && Math.random() < 0.80) {  // 80% proc chance
        attacker.signalCharges--;  // Burn the use
        
        // Get random 1‚Äì3 enemy targets (no duplicates, skips dead/env)
        const enemyFaction = attacker.faction === 'outlaw' ? 'law' : 'outlaw';
        const enemies = G.field[enemyFaction].filter(c => c.hp > 0 && !c.isEnvironment);
        const numTargets = Math.min(enemies.length, ab.value.minTargets + Math.floor(Math.random() * (ab.value.maxTargets - ab.value.minTargets + 1)));
        const shuffled = enemies.sort(() => Math.random() - 0.5);
        const targets = shuffled.slice(0, numTargets);
        
        // Add to triggeredAbilities so it shows in breakdown
triggeredAbilities.push({
    ability: ab,
    source: 'attacker',
    result: `Signal Charge Model 3 deployed! ${numTargets} targets blinded & panicked`
});
        
// Apply debuffs DIRECTLY to each target card (not faction-wide)
targets.forEach(t => {
    // Accuracy debuff (card-specific)
    if (!t.signalChargeEffects) t.signalChargeEffects = [];
    
// Was -75 acc/state ‚Üí now -40 acc (rattled entry), -25 state (frightened)
t.signalChargeEffects.push({type: 'accuracy', value: -40, turnsLeft: ab.value.turns * 2})
t.signalChargeEffects.push({type: 'state', value: -25, turnsLeft: ab.value.turns * 2})
});
        
        playSound('signal_charge');  // Play custom sound
        flashScreen();  // ‚Üê Screen flash on Signal Charge Model 3
        
        // Remove ability when exhausted
        attacker.abilities = attacker.abilities.filter(a => a !== 'signal_charge');
        
        const targetNames = targets.map(t => t.name).join(', ');
        addToFeed(attacker.faction, ab.icon, `${attacker.name} deploys Signal Charge!`, `${numTargets} blinded & panicked: ${targetNames}`, 'attack');
    }
});

// Lewis Gun: Lifetime heat buildup + DEBUG EVERY STEP
const lewisAbs = getAbilitiesByEffect(attacker, 'on_attack', 'lewis_suppression');
lewisAbs.forEach(ab => {
    console.log(`[LEWIS DEBUG] === START === Card: ${attacker.name} | Ability: ${ab.name}`);

    // 1. Shot counter increment
    attacker.lewisShotsFired = (attacker.lewisShotsFired || 0) + 1;
    console.log(`[LEWIS DEBUG] Shots fired this life: ${attacker.lewisShotsFired}`);

    // 2. Current jam status before roll
    console.log(`[LEWIS DEBUG] Currently jammed? ${attacker.lewisJammed ? 'YES' : 'NO'}`);

    // 3. Calculate jam chance
    const jamChance = attacker.lewisShotsFired * ab.value.jamChancePerShot;
    console.log(`[LEWIS DEBUG] Jam chance calc: ${attacker.lewisShotsFired} shots √ó ${ab.value.jamChancePerShot}% = ${jamChance.toFixed(2)}%`);

    // 4. Roll the dice
    const jamRoll = Math.random() * 100;
    console.log(`[LEWIS DEBUG] Roll result: ${jamRoll.toFixed(2)} (needs < ${jamChance.toFixed(2)} to jam)`);

if (jamRoll < jamChance) {
    attacker.lewisJammed = true;
    attacker.actionsUsed = getEffectiveMove(attacker); // Drain all remaining actions
    
    attacker.state = Math.max(0, (attacker.state || 100) - 70);  // ‚Üê ADD THIS LINE!
    
    triggeredAbilities.push({
        ability: ab,
        source: 'attacker',
        result: `‚ö†Ô∏è WEAPON JAMMED! (${jamChance}% chance on shot #${attacker.lewisShotsFired})`,
        failed: true
    });
    
    addToFeed(attacker.faction, '‚ö†Ô∏è', `${attacker.name}'s Lewis Gun OVERHEATS and JAMS!`, 
        `Shot #${attacker.lewisShotsFired} (${jamChance}% jam chance) - Locked rest of turn!`, 'debuff');
    } else {
        console.log(`[LEWIS DEBUG] No jam this shot`);

        triggeredAbilities.push({
            ability: ab,
            source: 'attacker',
            result: `Heat: ${jamChance.toFixed(0)}% risk (shots: ${attacker.lewisShotsFired})`
        });
    }

    console.log(`[LEWIS DEBUG] === END === Jammed now? ${attacker.lewisJammed ? 'YES' : 'NO'}`);
});

// Folk Hero: 65% chance target joins your team (one use per deploy)
const folkHeroAbs = getAbilitiesByEffect(attacker, 'on_attack', 'folk_hero_convert');
folkHeroAbs.forEach(ab => {
    if (attacker.folkHeroUses > 0 && damage > 0 && Math.random() * 100 < ab.value) {
        attacker.folkHeroUses--;  // Burn the use
        
        // SWAP FACTION
        const enemyFaction = target.faction;
        target.faction = attacker.faction;
        
        G.field[enemyFaction] = G.field[enemyFaction].filter(c => c.id !== target.id);
        G.field[attacker.faction].push(target);
        target.arrested = false;
        target.suppressed = 0;
        target.actionsUsed = 0;
        
        // Feedback
        effects.push({ text: `${ab.icon} FOLK HERO! ${target.name} JOINS US!`, type: 'buff' });
        triggeredAbilities.push({ 
            ability: ab, 
            source: 'attacker', 
            result: `${target.name} defects! (${attacker.folkHeroUses} uses left)` 
        });
        
        addToFeed(attacker.faction, 'üé≠', `${target.name} turns Folk Hero!`, 'Joins the gang!', 'rally');
        eliminated = false;
    } else if (attacker.folkHeroUses <= 0) {
        // Optional: quiet fail feedback if already used
        triggeredAbilities.push({ 
            ability: ab, 
            source: 'attacker', 
            result: `Folk Hero exhausted (0 uses left)`, 
            failed: true 
        });
    }
});
   
        // Add light suppression when hit (being shot is scary!)
    if (damage > 0 && !eliminated) {
        const hitSuppression = 2.5; // Base suppression per hit
        target.suppressed = (target.suppressed || 0) + hitSuppression;
    }
    
// NEW: Overpressure (40% chance, 3 rounds total)
const overpressureAbs = getAbilitiesByEffect(attacker, 'on_attack', 'overpressure');
overpressureAbs.forEach(ab => {
    if (damage > 0 && attacker.overpressureAmmo > 0 && Math.random() < 0.40) {
        attacker.overpressureAmmo--;  // Burn 1 round
        
        // Vest shred
        if (target.abilities.includes('bulletproof')) {
            target.vestDurability = 0;
            target.abilities = target.abilities.filter(a => a !== 'bulletproof');
            effects.push({ text: `${ab.icon} OVERPRESSURE SHREDS VEST!`, type: 'buff' });
            triggeredAbilities.push({ ability: ab, source: 'attacker', result: 'Vest destroyed instantly!' });
        }
        
        // +4 supp
        target.suppressed += ab.value.suppressBonus;
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `üî• OP Fired! +${ab.value.suppressBonus} supp (${attacker.overpressureAmmo} left)` });
    } else if (damage > 0 && attacker.overpressureAmmo > 0) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: 'Normal round (OP saved)', failed: true });
    } else if (damage > 0) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: 'Out of OP ammo!', failed: true });
    }
});

// NEW: High Velocity stacks (40% chance, SKIPS VEHICLES)
const hvAbs = getAbilitiesByEffect(attacker, 'on_attack', 'high_velocity');
hvAbs.forEach(ab => {
    if (!target.isVehicle && damage > 0 && attacker.hvAmmo > 0 && Math.random() < 0.40) {  // ‚Üê ADD hvAmmo > 0 CHECK
        attacker.hvAmmo--;  // Burn the round
        
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `ü©∏ HV FIRED! (0/1 left)` });
        
        // Proc shatter on FIRST hit
        if (!target.origDodge) target.origDodge = target.dodge;
        if (!target.origMove) target.origMove = target.move;
        
        target.dodge = Math.floor(target.origDodge / 2);
        target.move = Math.floor(target.origMove / 2);
        target.shattered = true;
        
        effects.push({ text: `${ab.icon} SHATTERED ON HV HIT! Dodge/MP halved FOREVER`, type: 'buff' });
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: 'PERMANENT CRIPPLE procced!' });
    } else if (damage > 0 && target.isVehicle) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: 'HV ineffective vs vehicle!', failed: true });
    } else if (damage > 0 && attacker.hvAmmo > 0) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: 'Normal round (HV saved)', failed: true });
    } else if (damage > 0) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: 'Out of HV ammo!', failed: true });
    }
});
   
// Gutshot ability - check if attacker has gutshot ability
attackerOnAttackAbilities.filter(ab => ab.effect === 'gutshot').forEach(ab => {
    if (damage > 0 && !eliminated && !target.bleeding && Math.random() * 100 < ab.value) {
        //Vehicles cannot be gutshot
        if (target.isVehicle) {
            // Optional: log or visual feedback
            addToFeed(attacker.faction, 'üíâ', `Gutshot attempt on ${target.name} fails!`, 'Vehicle ‚Äî no effect', 'attack');
            return;  // ‚Üê Skip bleed
        }

        target.bleeding = true;
        effects.push({ text: `${ab.icon} GUTSHOT!`, type: 'buff' });
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `Target is now bleeding! (${ab.value}% chance)` });
        addToFeed(attacker.faction, 'üíâ', `${target.name} suffers a GUTSHOT!`, 'Bleeding 1 HP/turn', 'bleeding');
    } else if (damage > 0 && !eliminated) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `No bleed (${ab.value}% chance)`, failed: true });
    }
});

// BAR weapon - massive suppression on attack
const barAbilities = getAbilitiesByEffect(attacker, 'on_attack', 'bar_suppress');
barAbilities.forEach(ab => {
    if (Math.random() < 0.90) {
        const barSuppression = attacker.fire * ab.value;
        target.suppressed = (target.suppressed || 0) + barSuppression;
        effects.push({ text: `${ab.icon} BAR +${barSuppression.toFixed(1)} supp`, type: 'debuff' });
        triggeredAbilities.push({
            ability: ab,
            source: 'attacker',
            result: `+${barSuppression.toFixed(1)} suppression (${attacker.fire} √ó ${ab.value})`
        });
    }
});

// Marksman - suppress all enemies (demoralizing sniper effect)
const hasMarksman = attacker.abilities && attacker.abilities.includes('marksman');
if (hasMarksman) {
    const enemyFaction = attacker.faction === 'outlaw' ? 'law' : 'outlaw';
    G.field[enemyFaction].forEach(enemy => {
        const marksmanSuppress = attacker.fire * 0.3;
        enemy.suppressed = (enemy.suppressed || 0) + marksmanSuppress;
    });
    effects.push({ text: `üéØ Marksman Effect: All enemies suppressed`, type: 'debuff' });
    triggeredAbilities.push({
        ability: { icon: 'üéØ', name: 'Marksman' },
        source: 'attacker',
        result: `All enemies suppressed (+${(attacker.fire * 0.3).toFixed(1)} each)`
    });
}

// Grenadier - throw grenade on attack
const grenadierAbilities = getAbilitiesByEffect(attacker, 'on_attack', 'grenade_throw');
grenadierAbilities.forEach(ab => {
    if (attacker.grenades && attacker.grenades > 0 && Math.random() * 100 < ab.value) {
        // Use one grenade
        attacker.grenades--;
        playSound('grenade'); // Play grenade explosion sound
       
        // Random number of targets (2-4)
        const numTargets = 2 + Math.floor(Math.random() * 3); // 2, 3, or 4
       
        // Get all enemies
        const enemyFaction = attacker.faction === 'outlaw' ? 'law' : 'outlaw';
        const allEnemies = G.field[enemyFaction].filter(e => e.hp > 0);
       
        // Shuffle and take random targets
        const shuffled = allEnemies.sort(() => Math.random() - 0.5);
        const grenadeTargets = shuffled.slice(0, Math.min(numTargets, shuffled.length));
       
        let grenadeLog = [];
        grenadeTargets.forEach(enemy => {
            // Random damage per target (2-5)
                        const grenadeDmg = 2 + Math.floor(Math.random() * 4); // 2, 3, 4, or 5
            enemy.hp -= grenadeDmg;
           
            // Force disembark if vehicle hit
            if (enemy.isVehicle && enemy.passengers && enemy.passengers.length > 0) {
                forceDisembarkAll(enemy);
            }
           
            // Track stats
            G.stats[attacker.faction].dmgDealt += grenadeDmg;
            G.stats[enemyFaction].dmgTaken += grenadeDmg;
           
            grenadeLog.push(`${enemy.name} -${grenadeDmg}HP`);
           
            // Check if enemy died from grenade
            if (enemy.hp <= 0) {
                G.field[enemyFaction] = G.field[enemyFaction].filter(c => c.id !== enemy.id);
                G.scores[attacker.faction]++;
                G.stats[attacker.faction].kills++;
                addToFeed(enemyFaction, 'üí£', `${enemy.name} killed by ${attacker.name}'s grenade!`, '', 'kill');
            }
        });
       
        effects.push({ text: `üí£ GRENADE! (${grenadeTargets.length} targets)`, type: 'buff' });
        triggeredAbilities.push({
            ability: ab,
            source: 'attacker',
            result: `Grenade thrown! ${grenadeLog.join(', ')} [${attacker.grenades} left]`
        });
       
        addToFeed(attacker.faction, 'üí£', `${attacker.name} throws grenade!`, grenadeLog.join(', '), 'attack');
    } else if (attacker.grenades && attacker.grenades > 0) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `No throw (${ab.value}% chance)`, failed: true });
    } else if (attacker.grenades === 0) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `No grenades left!`, failed: true });
    }
});

// Timed Dynamite - ONE USE passive throw on attack
attackerOnAttackAbilities.filter(ab => ab.effect === 'dynamite_throw').forEach(ab => {
    if (!attacker.dynamiteCharges || attacker.dynamiteCharges <= 0) return;
    
    const throwRoll = Math.random() * 100;
    if (throwRoll < ab.value.throwChance) {
        // SUCCESS - Throw dynamite!
        attacker.dynamiteCharges = 0;
        attacker.abilities = attacker.abilities.filter(a => a !== 'timed_dynamite');
        
        // Random timer from ability config
const timer = ab.value.timerRange[0] + Math.floor(Math.random() * (ab.value.timerRange[1] - ab.value.timerRange[0] + 1));
        
        // Set active dynamite
        G.activeDynamite = {
            timer: timer,
            throwerName: attacker.name,
            throwerFaction: attacker.faction,
            targets: ab.value.targetsRange[0] + Math.floor(Math.random() * (ab.value.targetsRange[1] - ab.value.targetsRange[0] + 1)),
            damageRange: ab.value.damageRange,
            accPenaltyRange: ab.value.accPenaltyRange,
            statePenaltyRange: ab.value.statePenaltyRange,
            fuseAudio: null  // ‚Üê optional, just preps the field
        };
        
// START LOOPING FUSE SOUND
const fuse = new Audio(SOUNDS.dynamite_fuse[0]);  // or random index if multiples
fuse.loop = true;
fuse.volume = soundVolume * 0.6;                  // slightly quieter dread
fuse.play().catch(() => {});

// Save reference on the active dynamite object
G.activeDynamite.fuseAudio = fuse;
        
        const backfireWarning = G.activeDynamite.backfired ? ' ‚ö†Ô∏è BACKFIRE!' : '';
addToFeed(attacker.faction, 'üß®', `${attacker.name} throws TIMED DYNAMITE!${backfireWarning}`, `üí£ Fuse is burning!`, 'attack');
addEventToFeeds(`üí£ LIVE DYNAMITE!`, 'üß® Could explode any moment...');
        
                // 15% chance of BACKFIRE
        const backfireRoll = Math.random() * 100;
        if (backfireRoll < 15) {
            G.activeDynamite.backfired = true;
            triggeredAbilities.push({ 
                ability: ab, 
                source: 'attacker', 
                result: `‚ö†Ô∏è BACKFIRE! Dynamite will hit own team!` 
            });
        } else {
            triggeredAbilities.push({ 
                ability: ab, 
                source: 'attacker', 
                result: `Dynamite thrown! Timer: ${timer} turns` 
            });
        }
    }
});

// Molotov - throw molotov on attack (40% chance, works on hit OR miss)
const molotovAbilities = getAbilitiesByEffect(attacker, 'on_attack', 'molotov_throw');
molotovAbilities.forEach(ab => {
    // Check if attacker has molotovs and roll for throw (40% chance)
    if (attacker.molotovs && attacker.molotovs > 0 && Math.random() * 100 < ab.value) {
        // Use one molotov
        attacker.molotovs--;
        playSound('molotov'); // Play attack sound for molotov throw
       
        // Apply burning to target (1 HP/turn for 2 turns)
        if (!target.burning) {
            target.burning = 3; // 3 turns of burning
            target.suppressed = (target.suppressed || 0) + 1; // Add 1 suppression
           
            // Force disembark if vehicle hit
            if (target.isVehicle && target.passengers && target.passengers.length > 0) {
                forceDisembarkAll(target);
            }
           
            effects.push({ text: `üî• MOLOTOV! Target burning`, type: 'buff' });
            triggeredAbilities.push({
                ability: ab,
                source: 'attacker',
                result: `Molotov thrown! ${target.name} is BURNING (1 HP/turn for 3 turns) +1 suppression [${attacker.molotovs} left]`
            });
           
            addToFeed(attacker.faction, 'üî•', `${attacker.name} throws molotov at ${target.name}!`, 'Target is BURNING!', 'attack');
        } else {
            // Target already burning, still use molotov but no additional effect
            effects.push({ text: `üî• Molotov (already burning)`, type: 'buff' });
            triggeredAbilities.push({
                ability: ab,
                source: 'attacker',
                result: `Molotov thrown but ${target.name} already burning [${attacker.molotovs} left]`
            });
        }
    } else if (attacker.molotovs && attacker.molotovs > 0) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `No throw (${ab.value}% chance)`, failed: true });
    } else if (attacker.molotovs === 0) {
        triggeredAbilities.push({ ability: ab, source: 'attacker', result: `No molotovs left!`, failed: true });
    }
});
   
    // Execute ability - instant kill if target below threshold
    attackerOnAttackAbilities.filter(ab => ab.effect === 'execute').forEach(ab => {
        const hpPercent = (target.hp / target.maxHp) * 100;
        if (target.hp > 0 && hpPercent <= ab.value) {
            target.hp = 0;
            eliminated = true;
            effects.push({ text: `${ab.icon} EXECUTED!`, type: 'buff' });
            details.push(`Execute triggered at ${Math.floor(hpPercent)}% HP`);
            triggeredAbilities.push({ ability: ab, source: 'attacker', result: `EXECUTED at ${Math.floor(hpPercent)}% HP!` });
        } else if (target.hp > 0) {
            triggeredAbilities.push({ ability: ab, source: 'attacker', result: `No exec (${Math.floor(hpPercent)}% > ${ab.value}%)`, failed: true });
        } else {
            triggeredAbilities.push({ ability: ab, source: 'attacker', result: `N/A (already dead)`, failed: true });
        }
    });
   
    // Survive lethal ability - chance to survive at 1 HP
    if (eliminated) {
        targetOnDefendAbilities.filter(ab => ab.effect === 'survive_lethal').forEach(ab => {
            if (eliminated && Math.random() * 100 < ab.value) {
                target.hp = 1;
                eliminated = false;
                effects.push({ text: `${ab.icon} SURVIVED!`, type: 'debuff' });
                details.push(`${ab.name} proc - survived at 1 HP!`);
                triggeredAbilities.push({ ability: ab, source: 'defender', result: `SURVIVED at 1 HP! (${ab.value}% chance)` });
            } else if (eliminated) {
                triggeredAbilities.push({ ability: ab, source: 'defender', result: `Failed (${ab.value}% chance)`, failed: true });
            }
        });
    }
   
    // Revenge ability - if killed, deal damage to attacker
    if (eliminated) {
        targetOnDefendAbilities.filter(ab => ab.effect === 'revenge').forEach(ab => {
            attacker.hp -= ab.value;
            effects.push({ text: `${ab.icon} Revenge ${ab.value}!`, type: 'debuff' });
            details.push(`${ab.name}: ${ab.value} damage to attacker`);
            triggeredAbilities.push({ ability: ab, source: 'defender', result: `${ab.value} revenge damage to attacker!` });
        });
    }
   
    // Attack suppress ability - add suppression on hit
    if (!eliminated) {
        attackerOnAttackAbilities.filter(ab => ab.effect === 'attack_suppress').forEach(ab => {
            target.suppressed = (target.suppressed || 0) + ab.value;
            effects.push({ text: `${ab.icon} Suppressed +${ab.value}`, type: 'buff' });
            triggeredAbilities.push({ ability: ab, source: 'attacker', result: `+${ab.value} suppression applied` });
        });
    }
    
// Marksman - suppress ALL enemies on attack (based on Fire stat)
if (hasAbility(attacker, 'marksman')) {
    const enemy = attacker.faction === 'outlaw' ? 'law' : 'outlaw';
    const suppressAmount = attacker.fire || 1; // Use attacker's Fire stat
    let suppressCount = 0;
    
    G.field[enemy].forEach(enemyCard => {
        if (!hasAbility(enemyCard, 'marksman')) { // Marksman immune to suppression
            enemyCard.suppressed = (enemyCard.suppressed || 0) + suppressAmount;
            suppressCount++;
        }
    });
    
    if (suppressCount > 0) {
        effects.push({ text: `üéØ Marksman: ${suppressCount} enemies suppressed`, type: 'buff' });
        triggeredAbilities.push({ 
            ability: G.abilities.marksman, 
            source: 'attacker', 
            result: `Suppressed ${suppressCount} enemies (+${suppressAmount} each, Fire: ${attacker.fire})` 
        });
    }
}
   
    // Track damage stats
    G.stats[attacker.faction].dmgDealt += damage;
    G.stats[target.faction].dmgTaken += damage;
   
    // Lifesteal processing (after damage is dealt)
    if (damage > 0) {
        attackerOnAttackAbilities.filter(ab => ab.effect === 'lifesteal').forEach(ab => {
            const healAmount = Math.floor(damage * (ab.value / 100));
            if (healAmount > 0) {
                attacker.hp = Math.min(attacker.maxHp, attacker.hp + healAmount);
                effects.push({ text: `${ab.icon} Lifesteal +${healAmount}`, type: 'buff' });
                triggeredAbilities.push({ ability: ab, source: 'attacker', result: `+${healAmount} HP healed (${ab.value}%)` });
            }
        });
    }
   
    // Check if attacker died from reflect/revenge
    if (attacker.hp <= 0) {
        const attackerFaction = attacker.faction;
        const defenderFaction = target.faction;
        G.field[attackerFaction] = G.field[attackerFaction].filter(c => c.id !== attacker.id);
        G.scores[defenderFaction]++;
        G.stats[defenderFaction].kills++;
        addToFeed(attackerFaction, '‚ò†Ô∏è', `${attacker.name} killed by reflect/revenge!`, '', 'kill');
    }
    
function getMoraleStatus(morale) {
    if (morale >= 85) return 'No penalties - morale is good!';
    if (morale >= 51) return 'No penalties';
    if (morale >= 21) return 'Shaken (-20% acc/dodge, -1 move)';
    return 'Panicked (-60% acc/dodge, -3 move)';
}

function getMoralePenalty(morale) {
    if (morale >= 51) return '0%';
    if (morale >= 21) return '-20%';
    return '-60%';
}
   
// Build breakdown data for detailed display
const breakdownData = {
    baseFire,
    customAttackBonus,
    leaderBonus,
    eventMod,
    grossDamage,
    grossDmg: grossDamage, 
    defendReduction,
    coverReduction,
    abilityReduction,
    hitRoll,
    dodgeChance,
    hitChance: effectiveHitChance,  
    effectiveHitChance,             
    attackerAccuracy,
    targetInCover: target.coverTurns && target.coverTurns > 0,
    
        // Forest modifiers
        attackerForestFire: attacker.forestFire || 0,
        targetForestDodge: target.forestDodge || 0,
        
         // DEBUG - log forest in breakdown
         
        // Add detailed ability info
        attackerAbilities: getCardAbilities(attacker).map(id => G.abilities[id]).filter(a => a),
        targetAbilities: getCardAbilities(target).map(id => G.abilities[id]).filter(a => a),
        triggeredAbilities: triggeredAbilities,
    
    // Hit chance data (NEW)
    baseHitChance: 100 - dodgeChance,
    
    // Target state (NEW)
    targetDefending: target.defending || false,
    targetFortified: target.fortified || 0,
    targetRoadblocked: target.roadblocked || false,
    targetHPBefore: target.hp + damage,
    targetHPAfter: target.hp,
    targetMaxHP: target.maxHp,
    
    // Suppression (NEW)
    attackerSuppression: attacker.suppressed || 0,
    targetSuppression: target.suppressed || 0,
    suppressionPenaltyAccuracy: (attacker.suppressed || 0) * 5,
    suppressionPenaltyDodge: (target.suppressed || 0) * 5,
    
    // Morale/State (NEW)
    attackerMorale: attacker.state || 100,
    targetMorale: target.state || 100,
    attackerMoraleStatus: getMoraleStatus(attacker.state || 100),
    targetMoraleStatus: getMoraleStatus(target.state || 100),
    moralePenaltyAccuracy: getMoralePenalty(attacker.state || 100),
    moralePenaltyDodge: getMoralePenalty(target.state || 100),
    
    // Environmental (NEW)
    attackerForestAccuracy: attacker.forestAccuracy || 0
};
   
    // Add to BOTH combat feeds instead of modal
    addToCombatFeed(attacker.faction, attacker, target, damage, effects, breakdownData, eliminated);
    addToCombatFeed(target.faction, attacker, target, damage, effects, breakdownData, eliminated);
   
    // Add to feed
    if (eliminated) {
        G.stats[attacker.faction].kills++;
        playSound('kill'); // Play kill sound
        attacker.kills = (attacker.kills || 0) + 1; // Track individual card kills
        attacker.kills = (attacker.kills || 0) + 1;
    attacker.state = Math.min(100, (attacker.state || 100) + 10);  // Killing boosts morale
        addToFeed(attacker.faction, 'üíÄ', `${attacker.name} KILLS ${target.name}!`, `${damage} damage`, 'kill');
        addToFeed(target.faction, '‚ò†Ô∏è', `${target.name} eliminated by ${attacker.name}`, `${damage} damage taken`, 'kill');
    } else {
        addToFeed(attacker.faction, 'üî´', `${attacker.name} ‚Üí ${target.name}`, `${damage} damage dealt`, 'attack');
    }
   
    // Check death
    if (eliminated) {
        const enemy = attacker.faction === 'outlaw' ? 'law' : 'outlaw';
        
        // Clean up passengers if vehicle is destroyed
        if (target.isVehicle && target.passengers && target.passengers.length > 0) {
            const passengerIds = [...target.passengers];
            passengerIds.forEach(passengerId => {
                const passenger = G.field[enemy].find(c => c.id === passengerId);
                if (passenger) {
                    passenger.inVehicle = false;
                    passenger.vehicleId = null;
                }
            });
        }
        
          if (target.isVehicle) {
        forceDisembarkAll(target);
    }
        
        G.field[enemy] = G.field[enemy].filter(c => c.id !== target.id);
        G.scores[attacker.faction]++;
    }
   
    G.selected = attacker;
    updateUI();
    
// Text pulse feedback - make all card text flash red and grow
setTimeout(() => {
    const targetElement = document.querySelector(`.card[data-id="${target.id}"]`);
    if (targetElement) {
        // Save original styles
        const originalTransform = targetElement.style.transform;
        
        // Get all text elements inside the card
        const textElements = targetElement.querySelectorAll('.card-name, .card-stats span, .stat-hp, .stat-ammo, .stat-move, .stat-fire, .stat-supp, .stat-dodge');
        const originalColors = Array.from(textElements).map(el => el.style.color || getComputedStyle(el).color);
        
        // PULSE RED + SCALE UP CARD
        targetElement.style.transform = 'scale(1.1)';
        targetElement.style.transition = 'all 0.1s ease';
        
        // Change text colors to red
        textElements.forEach(el => {
            el.style.color = '#ff0000';
            el.style.transition = 'color 0.1s ease';
        });
        
        setTimeout(() => {
            targetElement.style.transform = 'scale(1.15)';
            textElements.forEach(el => {
                el.style.color = '#ff4444';
            });
        }, 100);
        
        setTimeout(() => {
            targetElement.style.transform = originalTransform;
            targetElement.style.transition = 'all 0.2s ease';
            
            // Restore original text colors
            textElements.forEach((el, i) => {
                el.style.color = originalColors[i];
                el.style.transition = 'color 0.2s ease';
            });
        }, 300);
    }
}, 50);
    
    checkVictory(); // Check immediately since no modal
}

function showCombatPanel(attacker, target, damage, blocked, effects, details, eliminated, oldHP, breakdownData) {
    clearCombatPrediction(); // Clear tooltip immediately
    
    // Header
    $('combatHeader').textContent = eliminated ? 'üíÄ ELIMINATED! üíÄ' : '‚öîÔ∏è COMBAT ‚öîÔ∏è';    
    // Attacker
    $('attackerPortrait').textContent = attacker.portrait;
    $('attackerName').textContent = attacker.name;
    $('attackerHP').textContent = `${attacker.hp}/${attacker.maxHp} HP`;
    $('attackerAmmo').textContent = `Ammo: ${attacker.ammo}`;
    const attackerPct = (attacker.hp / attacker.maxHp) * 100;
    $('attackerHPBar').style.width = attackerPct + '%';
    $('attackerHPBar').className = 'combat-hp-fill ' + getHPClass(attackerPct);
    $('combatAttacker').className = 'combat-card attacker';
   
    // Defender
    $('defenderPortrait').textContent = target.portrait;
    $('defenderName').textContent = target.name;
    const finalHP = Math.max(0, target.hp);
    $('defenderHP').textContent = `${finalHP}/${target.maxHp} HP`;
    $('defenderStatus').innerHTML = eliminated ? '<span style="color:#c9302c">ELIMINATED</span>' : (blocked > 0 ? '<span style="color:#5bc0de">üõ°Ô∏è Defended!</span>' : '');
    const defenderPct = (finalHP / target.maxHp) * 100;
    $('defenderHPBar').style.width = defenderPct + '%';
    $('defenderHPBar').className = 'combat-hp-fill ' + getHPClass(defenderPct);
    $('combatDefender').className = 'combat-card defender' + (eliminated ? '' : '');
   
    // Damage display
    if (damage === 0) {
        $('combatDamage').textContent = 'BLOCKED!';
        $('combatDamage').className = 'combat-damage blocked';
    } else {
        $('combatDamage').textContent = `-${damage} HP`;
        $('combatDamage').className = 'combat-damage hit';
    }
    
    // After damage calculation, if damage was reduced to 0 by cover/defend
if (damage === 0 && !eliminated) {
    // CYAN PULSE FOR BLOCK (existing code continues below)
    setTimeout(() => {
        const targetElement = document.querySelector(`.card[data-id="${target.id}"]`);
        if (targetElement) {
            const originalTransform = targetElement.style.transform;
            const textElements = targetElement.querySelectorAll('.card-name, .card-stats span, .stat-hp, .stat-ammo, .stat-move, .stat-fire, .stat-supp, .stat-dodge');
            const originalColors = Array.from(textElements).map(el => el.style.color || getComputedStyle(el).color);
            
            // PULSE CYAN + MEDIUM SCALE (block feedback)
            targetElement.style.transform = 'scale(1.07)';
            targetElement.style.transition = 'all 0.1s ease';
            textElements.forEach(el => {
                el.style.color = '#22d3ee'; // Cyan for block
                el.style.transition = 'color 0.1s ease';
            });
            
            setTimeout(() => {
                targetElement.style.transform = 'scale(1.1)';
                textElements.forEach(el => el.style.color = '#06b6d4');
            }, 80);
            
            setTimeout(() => {
                targetElement.style.transform = originalTransform;
                targetElement.style.transition = 'all 0.15s ease';
                textElements.forEach((el, i) => {
                    el.style.color = originalColors[i];
                    el.style.transition = 'color 0.15s ease';
                });
            }, 250);
        }
    }, 50);
}
   
    // Effects badges
    $('combatEffects').innerHTML = effects.map(e =>
        `<span class="combat-effect ${e.type}">${e.text}</span>`
    ).join('');
   
    // Show defender
    $('combatDefender').style.display = '';
    $('combatVs').style.display = '';
    
    // Build triggered abilities display
    const triggeredHtml = breakdownData.triggeredAbilities && breakdownData.triggeredAbilities.length > 0
        ? breakdownData.triggeredAbilities.map(t => {
            const color = t.failed ? '#666' : '#4ade80';
            const icon = t.failed ? '‚úó' : '‚úì';
            const fromText = t.from ? ` (${t.from})` : '';
            return `<div style="display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid #222">
                <span>${t.ability.icon} ${t.ability.name}${fromText}</span>
                <span style="color:${color}">${icon} ${t.result}</span>
            </div>`;
        }).join('')
        : '<div style="color:#666">No abilities triggered</div>';
   
    // Detailed breakdown
    if (breakdownData) {
        $('combatBreakdown').innerHTML = `
            <div class="combat-breakdown-section" style="margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid #333">
                <div style="color:var(--gold);font-weight:600;margin-bottom:6px">‚ö° TRIGGERED ABILITIES</div>
                <div style="font-size:.8em">${triggeredHtml}</div>
            </div>
           
            <div class="combat-breakdown-title">Damage Calculation</div>
            <div class="combat-breakdown-row">
                <span>Base Fire</span>
                <span>${breakdownData.baseFire}</span>
            </div>
            ${breakdownData.customAttackBonus ? `<div class="combat-breakdown-row add"><span>+ Ability Bonus</span><span>+${breakdownData.customAttackBonus}</span></div>` : ''}
            ${breakdownData.leaderBonus ? `<div class="combat-breakdown-row add"><span>+ Aura Bonus</span><span>(included)</span></div>` : ''}
            ${breakdownData.eventMod !== 0 ? `<div class="combat-breakdown-row ${breakdownData.eventMod > 0 ? 'add' : 'sub'}"><span>${breakdownData.eventMod > 0 ? '+' : ''} Event Modifier</span><span>${breakdownData.eventMod > 0 ? '+' : ''}${breakdownData.eventMod}</span></div>` : ''}
             ${breakdownData.attackerForestFire !== undefined ? `
            <div class="combat-breakdown-row ${breakdownData.attackerForestFire > 0 ? 'add' : breakdownData.attackerForestFire < 0 ? 'sub' : ''}">
                <span>üå≤ Forest Fire Modifier</span>
                <span>${breakdownData.attackerForestFire > 0 ? '+' : ''}${breakdownData.attackerForestFire}</span>
            </div>` : ''}
                <div class="combat-breakdown-row result">
                <span>Gross Damage</span>
                <span>${breakdownData.grossDamage}</span>
            </div>
           
            ${breakdownData.coverReduction || breakdownData.defendReduction || breakdownData.abilityReduction || breakdownData.targetInCover ? `
            <div class="combat-breakdown-section">
                <div style="color:#888;margin-bottom:6px">Reductions ${breakdownData.targetInCover ? '<span style="color:#2d5a4a;font-weight:600">(ü™® IN COVER)</span>' : ''}</div>
                ${breakdownData.targetInCover ? `<div class="combat-breakdown-row sub"><span>- ü™® Cover (75%)</span><span>-${breakdownData.coverReduction || 0}</span></div>` : ''}
                ${breakdownData.defendReduction ? `<div class="combat-breakdown-row sub"><span>- üõ°Ô∏è Defend (50%)</span><span>-${breakdownData.defendReduction}</span></div>` : ''}
                ${breakdownData.abilityReduction ? `<div class="combat-breakdown-row sub"><span>- Ability Reduction</span><span>-${breakdownData.abilityReduction}</span></div>` : ''}
            </div>
            ` : ''}
           
            <div class="combat-breakdown-row result">
                <span>Final Damage</span>
                <span style="color:${damage > 0 ? '#c9302c' : '#5cb85c'}">${damage}</span>
            </div>
           
            <div class="combat-breakdown-section">
                <div class="combat-breakdown-row">
                    <span>Base Hit Chance</span>
                    <span>${100 - breakdownData.dodgeChance}%</span>
                </div>
                <div class="combat-breakdown-row ${breakdownData.attackerAccuracy < 100 ? 'sub' : ''}">
                    <span>√ó Attacker Accuracy</span>
                    <span>${breakdownData.attackerAccuracy}%</span>
                </div>
                <div class="combat-breakdown-row result">
                    <span>Effective Hit Chance</span>
                    <span style="color:#facc15">${((100 - breakdownData.dodgeChance) * (breakdownData.attackerAccuracy / 100)).toFixed(1)}%</span>
                </div>
                <div class="combat-breakdown-row">
                    <span>Hit Roll</span>
                    <span>${breakdownData.hitRoll}</span>
                </div>
                ${target.suppressed && target.suppressed > 0 ? `
                <div class="combat-breakdown-row sub">
                    <span style="font-size:.85em;color:#888">‚îî Suppressed (x${target.suppressed})</span>
                    <span style="color:#f87171">-${target.suppressed * 5}%</span>
                </div>
                ` : ''}
                ${breakdownData.targetForestDodge > 0 ? `
                <div class="combat-breakdown-row add">
                    <span style="font-size:.85em;color:#90ee90">‚îî üå≤ Forest Cover</span>
                    <span style="color:#90ee90">+${breakdownData.targetForestDodge}%</span>
                </div>
                ` : ''}
                <div class="combat-breakdown-row result">
                    <span>Result</span>
                    <span style="color:#5cb85c">HIT!</span>
                </div>
            </div>
           
${target.suppressed && target.suppressed > 0 ? `
            <div class="combat-breakdown-section">
                <div style="color:#9b6bcc;font-weight:600;margin-bottom:6px">üíú SUPPRESSION MATH</div>
                <div class="combat-breakdown-row">
                    <span>Current Suppression Level</span>
                    <span>${target.suppressed.toFixed(2)}</span>
                </div>
                <div class="combat-breakdown-row">
                    <span>Formula: Level √ó 5% per point</span>
                    <span>${target.suppressed.toFixed(2)} √ó 5 = -${(target.suppressed * 5).toFixed(1)}%</span>
                </div>
                <div class="combat-breakdown-row">
                    <span>Base Dodge</span>
                    <span>${target.dodge || 10}%</span>
                </div>
                <div class="combat-breakdown-row sub">
                    <span>Suppression Penalty</span>
                    <span>-${(target.suppressed * 5).toFixed(1)}%</span>
                </div>
                <div class="combat-breakdown-row result">
                    <span>Effective Dodge</span>
                    <span>${breakdownData.dodgeChance}%</span>
                </div>
            </div>
            ` : console.log('[COMBAT DEBUG] 5. No suppression row added ‚Äî target.suppressed =', target.suppressed || 0)}
            
            ${target.state !== undefined ? `
            <div class="combat-breakdown-section">
                <div style="color:#d97706;font-weight:600;margin-bottom:6px">${target.state <= 20 ? 'üíÄ RATTLED' : target.state <= 50 ? 'üò∞ FRIGHTENED' : 'üòä READY'} - TARGET MORALE</div>
                <div class="combat-breakdown-row">
                    <span>Target Morale State</span>
                    <span>${target.state}/100</span>
                </div>
                ${target.state <= 50 ? `
                <div class="combat-breakdown-row sub">
                    <span>${target.state <= 20 ? 'Rattled' : 'Frightened'} Dodge Penalty</span>
                    <span>${target.state <= 20 ? '√ó0.4 (60% reduction)' : '√ó0.8 (20% reduction)'}</span>
                </div>
                <div class="combat-breakdown-row sub">
                    <span>${target.state <= 20 ? 'Rattled' : 'Frightened'} Accuracy Penalty</span>
                    <span>${target.state <= 20 ? '√ó0.4 (60% reduction)' : '√ó0.8 (20% reduction)'}</span>
                </div>
                ` : `
                <div class="combat-breakdown-row">
                    <span>Status</span>
                    <span style="color:#4ade80">No penalties - morale is good!</span>
                </div>
                `}
            </div>
            ` : ''}
            
            ${attacker.state !== undefined ? `
            <div class="combat-breakdown-section">
                <div style="color:#d97706;font-weight:600;margin-bottom:6px">${attacker.state <= 20 ? 'üíÄ RATTLED' : attacker.state <= 50 ? 'üò∞ FRIGHTENED' : 'üòä READY'} - ATTACKER MORALE</div>
                <div class="combat-breakdown-row">
                    <span>Attacker Morale State</span>
                    <span>${attacker.state}/100</span>
                </div>
                ${attacker.state <= 50 ? `
                <div class="combat-breakdown-row sub">
                    <span>${attacker.state <= 20 ? 'Rattled' : 'Frightened'} Accuracy Penalty</span>
                    <span>${attacker.state <= 20 ? '√ó0.4 (60% reduction)' : '√ó0.8 (20% reduction)'}</span>
                </div>
                <div class="combat-breakdown-row result">
                    <span>Final Attacker Accuracy</span>
                    <span style="color:#facc15">${breakdownData.attackerAccuracy}%</span>
                </div>
                ` : `
                <div class="combat-breakdown-row">
                    <span>Status</span>
                    <span style="color:#4ade80">No penalties - morale is good!</span>
                </div>
                `}
            </div>
            ` : ''}
            
            ${attacker.state <= 50 ? `
            <div class="combat-breakdown-section">
                <div style="color:#d97706;font-weight:600;margin-bottom:6px">${attacker.state <= 20 ? 'üíÄ RATTLED' : 'üò∞ FRIGHTENED'} - ATTACKER MORALE</div>
                <div class="combat-breakdown-row">
                    <span>Attacker Morale State</span>
                    <span>${attacker.state}/100</span>
                </div>
                <div class="combat-breakdown-row sub">
                    <span>${attacker.state <= 20 ? 'Rattled' : 'Frightened'} Accuracy Penalty</span>
                    <span>${attacker.state <= 20 ? '√ó0.4 (60% reduction)' : '√ó0.8 (20% reduction)'}</span>
                </div>
                <div class="combat-breakdown-row result">
                    <span>Final Attacker Accuracy</span>
                    <span style="color:#facc15">${breakdownData.attackerAccuracy}%</span>
                </div>
            </div>
            ` : ''}
           
            <div class="combat-breakdown-section">
                <div class="combat-breakdown-row">
                    <span>Target HP Before</span>
                    <span>${oldHP}</span>
                </div>
                <div class="combat-breakdown-row">
                    <span>Target HP After</span>
                    <span style="color:${finalHP <= 0 ? '#c9302c' : finalHP <= target.maxHp * 0.3 ? '#d9a34a' : '#5cb85c'}">${finalHP}</span>
                </div>
            </div>
        `;
    }
    show('combatPanel');
}

function getHPClass(pct) {
    if (pct > 60) return 'healthy';
    if (pct > 30) return 'wounded';
    return 'critical';
}

function showMissPanel(attacker, target, roll, dodgeChance) {
    clearCombatPrediction(); // Clear tooltip immediately
   
    $('combatHeader').textContent = 'üí® MISSED! üí®';
   
    // Attacker
    $('attackerPortrait').textContent = attacker.portrait;
    $('attackerName').textContent = attacker.name;
    $('attackerHP').textContent = `${attacker.hp}/${attacker.maxHp} HP`;
    $('attackerAmmo').textContent = `Ammo: ${attacker.ammo}`;
    const attackerPct = (attacker.hp / attacker.maxHp) * 100;
    $('attackerHPBar').style.width = attackerPct + '%';
    $('attackerHPBar').className = 'combat-hp-fill ' + getHPClass(attackerPct);
   
    // Defender
    $('defenderPortrait').textContent = target.portrait;
    $('defenderName').textContent = target.name;
    $('defenderHP').textContent = `${target.hp}/${target.maxHp} HP`;
    $('defenderStatus').innerHTML = `<span style="color:#4ade80">üéØ Dodged!</span>`;
    const defenderPct = (target.hp / target.maxHp) * 100;
    $('defenderHPBar').style.width = defenderPct + '%';
    $('defenderHPBar').className = 'combat-hp-fill ' + getHPClass(defenderPct);
   
    // Show defender
    $('combatDefender').style.display = '';
    $('combatVs').style.display = '';
   
    // Miss display
    $('combatDamage').textContent = 'MISS!';
    $('combatDamage').className = 'combat-damage miss';
    $('combatEffects').innerHTML = `<span class="combat-effect neutral">Dodge: ${dodgeChance}%</span>`;
        // Calculate accuracy for display
    const attackerAccuracy = getEffectiveAccuracy(attacker);
    const baseHitChance = 100 - dodgeChance;
    const effectiveHitChance = baseHitChance * (attackerAccuracy / 100);
    
    $('combatBreakdown').innerHTML = `
        <div class="combat-breakdown-title">Miss Calculation</div>
        <div class="combat-breakdown-row">
            <span>Base Hit Chance</span>
            <span>${baseHitChance}%</span>
        </div>
        <div class="combat-breakdown-row ${attackerAccuracy < 100 ? 'sub' : ''}">
            <span>Attacker Accuracy</span>
            <span>${attackerAccuracy}%</span>
        </div>
        <div class="combat-breakdown-row result">
            <span>Effective Hit Chance</span>
            <span>${effectiveHitChance.toFixed(1)}%</span>
        </div>
        <div class="combat-breakdown-row">
            <span>Your Roll</span>
            <span>${roll}</span>
        </div>
        <div class="combat-breakdown-row result">
            <span>Result</span>
            <span style="color:#4ade80">MISSED!</span>
        </div>
    `;
   
    show('combatPanel');
}

function showArrestPanel(attacker, target) {
    $('combatHeader').textContent = 'üîí ARRESTED! üîí';
    $('attackerPortrait').textContent = attacker.portrait;
    $('attackerName').textContent = attacker.name;
    $('attackerHP').textContent = `${attacker.hp}/${attacker.maxHp} HP`;
    $('attackerAmmo').textContent = `Ammo: ${attacker.ammo}`;
    $('attackerHPBar').style.width = ((attacker.hp / attacker.maxHp) * 100) + '%';
    $('attackerHPBar').className = 'combat-hp-fill ' + getHPClass((attacker.hp / attacker.maxHp) * 100);
    
    $('defenderPortrait').textContent = target.portrait;
    $('defenderName').textContent = target.name;
    $('defenderHP').textContent = `${target.hp}/${target.maxHp} HP`;
    $('defenderStatus').innerHTML = '<span style="color:#8b0000">LOCKED UP!</span>';
    $('defenderHPBar').style.width = ((target.hp / target.maxHp) * 100) + '%';
    $('defenderHPBar').className = 'combat-hp-fill ' + getHPClass((target.hp / target.maxHp) * 100);
    
    $('combatDamage').textContent = 'CANNOT ACT';
    $('combatDamage').className = 'combat-damage blocked';
    
    $('combatEffects').innerHTML = `
        <span class="combat-effect debuff">0 Move / Fire</span>
        <span class="combat-effect debuff">20% release after 2 turns</span>
    `;
    
    $('combatBreakdown').innerHTML = `
        <div class="combat-breakdown-title">Arrest Effects</div>
        <div class="combat-breakdown-row sub"><span>Cost to Arrestor</span><span>2 Move +0.5 Supp</span></div>
        <div class="combat-breakdown-row sub"><span>Target Status</span><span>LOCKED UP</span></div>
        <div class="combat-breakdown-row sub"><span>Release Chance</span><span>20% (after 2 turns min)</span></div>
        <div class="combat-breakdown-row result"><span>Result</span><span style="color:#8b0000">HANDCUFFED!</span></div>
    `;
    
    show('combatPanel');
}

function closeCombat() {
    // Reset defender/vs visibility (may have been hidden by scavenge)
    $('combatDefender').style.display = '';
    $('combatVs').style.display = '';
    $('combatVs').textContent = 'VS'; // Reset from potential arrow
    hide('combatPanel');
    checkVictory();
   
    // If AI is waiting for this panel, continue
    if (G.aiWaitingPanel) {
        aiContinue();
    }
}

function flashScreen() {
    const flash = document.getElementById('screenFlash');

    if (flash) {
        // Show flash
        flash.classList.remove('hidden');
        flash.classList.add('flash');
        
        document.body.classList.add('flash-desaturate');

        // Hold the flash for 200ms
        setTimeout(() => {
            flash.classList.remove('flash');
            // Hide flash overlay after fade-out
            setTimeout(() => flash.classList.add('hidden'), 300);
        }, 200);
        
        // KEEP desaturation for 30 seconds, then slowly fade back over 45 seconds
        setTimeout(() => {
            document.body.classList.remove('flash-desaturate');
        }, 30000);
    }
}

function defendAction() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        return;
    }
   
    // Calculate effective move
    const effectiveMove = getEffectiveMove(G.selected);
   
    if (G.selected.actionsUsed >= effectiveMove) {
        return;
    }
    if (G.selected.defending) {
        return;
    }
   
    G.selected.defending = true;
    G.selected.actionsUsed = effectiveMove; // Use ALL remaining actions
   
    addToFeed(G.turn, 'üõ°Ô∏è', `${G.selected.name} defends!`, '50% damage reduction', 'defend');
    updateUI();
}

// ============ TAKE COVER SYSTEM ============
function takeCoverAction() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card first!', G.turn);
        return;
    }
   
    const effectiveMove = getEffectiveMove(G.selected);
   
    // Need at least 2 actions to take cover
    const actionsRemaining = effectiveMove - (G.selected.actionsUsed || 0);
    if (actionsRemaining < 2) {
        log(`${G.selected.name} needs at least 2 actions to take cover!`, G.turn);
        return;
    }
    if (G.selected.coverTurns && G.selected.coverTurns > 0) {
        log(`${G.selected.name} is already in cover!`, G.turn);
        return;
    }
   
    playSound('defend');
   
    // Apply cover: +2 HP, defending status, 2 turn duration
    // Costs 2 actions (not all)
    G.selected.actionsUsed = (G.selected.actionsUsed || 0) + 2;
    G.selected.coverTurns = 2;
    G.selected.defending = true;
    G.selected.hp = Math.min(G.selected.maxHp, G.selected.hp + 2);
   
    addToFeed(G.turn, 'ü™®', `${G.selected.name} takes cover!`, '+2 HP, +DEF, -2 Move for 2 turns', 'defend');
   
    // Show cover panel
    showCoverPanel(G.selected);
    updateUI();
}

function showCoverPanel(card) {
    clearCombatPrediction(); // Clear tooltip immediately
   
    $('combatHeader').textContent = 'ü™® TAKING COVER! ü™®';
    $('attackerPortrait').textContent = card.portrait;
    $('attackerName').textContent = card.name;
    $('attackerHP').textContent = `${card.hp}/${card.maxHp} HP`;
    $('attackerAmmo').textContent = `Ammo: ${card.ammo}`;
    const pct = (card.hp / card.maxHp) * 100;
    $('attackerHPBar').style.width = pct + '%';
    $('attackerHPBar').className = 'combat-hp-fill ' + getHPClass(pct);
   
    $('combatDefender').style.display = 'none';
    $('combatVs').style.display = 'none';
   
    $('combatDamage').textContent = '+2 HP';
    $('combatDamage').className = 'combat-damage blocked';
    $('combatDamage').style.color = '#4ade80';
   
    $('combatEffects').innerHTML = `
        <span class="combat-effect buff">üõ°Ô∏è +50% Defend</span>
        <span class="combat-effect buff">ü™® +75% Cover</span>
        <span class="combat-effect debuff">üîª -10% Dodge</span>
        <span class="combat-effect debuff">üîª Fire/Supp Halved</span>
    `;
   
    $('combatBreakdown').innerHTML = `
        <div class="combat-breakdown-title">Cover Effects (2 Turns)</div>
        <div class="combat-breakdown-row sub"><span>Action Cost</span><span>2 Move</span></div>
        <div class="combat-breakdown-row add"><span>HP Restored</span><span>+2</span></div>
        <div class="combat-breakdown-row add"><span>Defend Reduction</span><span>50%</span></div>
        <div class="combat-breakdown-row add"><span>Cover Reduction</span><span>75%</span></div>
        <div class="combat-breakdown-row sub"><span>Dodge Penalty</span><span>-10%</span></div>
        <div class="combat-breakdown-row sub"><span>Fire Power</span><span>50%</span></div>
        <div class="combat-breakdown-row sub"><span>Suppression</span><span>50%</span></div>
        <div class="combat-breakdown-section">
            <div class="combat-breakdown-row result"><span>Total Damage Reduction</span><span style="color:#4ade80">~87.5%</span></div>
            <div class="combat-breakdown-row"><span>Duration</span><span>2 Turns</span></div>
        </div>
    `;
   
    show('combatPanel');
}

// ============ SCAVENGE SYSTEM ============
function scavengeAmmo() {
    if (!G.selected) {
        return;
    }
    const effectiveMove = getEffectiveMove(G.selected);
    if (G.selected.actionsUsed >= effectiveMove) {
        return;
    }
    if (G.selected.ammo >= G.selected.maxAmmo) {
        return;
    }
   
    G.selected.actionsUsed++;
   
    // Base 40% chance + dodge bonus (higher dodge = better scavenging/awareness)
    const baseChance = 40;
    const dodgeBonus = G.selected.dodge || 10;
    const successChance = Math.min(95, baseChance + dodgeBonus);
    const roll = Math.floor(Math.random() * 100);
    const success = roll < successChance;
   
    if (success) {
        // Random ammo found: 1 to 3, weighted toward lower amounts
        const ammoRoll = Math.random();
        let ammoFound;
        if (ammoRoll < 0.5) ammoFound = 1;       // 50% chance: 1 ammo
        else if (ammoRoll < 0.85) ammoFound = 2; // 35% chance: 2 ammo
        else ammoFound = 3;                       // 15% chance: 3 ammo
       
        const actualAmmo = Math.min(ammoFound, G.selected.maxAmmo - G.selected.ammo);
        G.selected.ammo += actualAmmo;
       
        addToFeed(G.selected.faction, 'üîç', `${G.selected.name} scavenges +${actualAmmo} ammo`, `Roll: ${roll} vs ${successChance}%`, 'scavenge');
        showScavengePanel(G.selected, true, actualAmmo, roll, successChance);
    } else {
        addToFeed(G.selected.faction, '‚ùå', `${G.selected.name} found nothing`, `Roll: ${roll} vs ${successChance}%`, 'scavenge');
        showScavengePanel(G.selected, false, 0, roll, successChance);
    }
   
    updateUI();
}

function showScavengePanel(card, success, ammo, roll, chance) {
    $('scavengeHeader').textContent = success ? 'üîç SCAVENGE SUCCESS! üîç' : 'üîç FOUND NOTHING üîç';
   
    $('scavengeCard').innerHTML = `
        <div style="font-size:2em">${card.portrait}</div>
        <div style="font-weight:bold;color:var(--gold)">${card.name}</div>
        <div style="font-size:.85em;margin-top:8px">
            <span class="stat-hp">HP: ${card.hp}/${card.maxHp}</span> |
            <span class="stat-ammo">Ammo: ${card.ammo}/${card.maxAmmo}</span>
${card.grenades !== undefined ? `<span class="stat-ammo">üí£ ${card.grenades}</span>` : ''}
        </div>
    `;
   
    if (success) {
        $('scavengeResult').textContent = 'FOUND AMMO!';
        $('scavengeResult').className = 'scavenge-result success';
        $('scavengeAmmo').textContent = `+${ammo} üî´`;
        $('scavengeAmmo').style.display = '';
    } else {
        $('scavengeResult').textContent = 'AREA EMPTY';
        $('scavengeResult').className = 'scavenge-result fail';
        $('scavengeAmmo').style.display = 'none';
    }
   
    $('scavengeDetails').innerHTML = `Dodge Bonus: +${card.dodge || 10}%`;
   
    $('scavengeBreakdown').innerHTML = `
        <div style="color:var(--gold);font-weight:600;margin-bottom:8px">SCAVENGE ROLL</div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid #1a1a1f">
            <span>Base Chance</span>
            <span>40%</span>
        </div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid #1a1a1f;color:#3dbdbd">
            <span>+ Dodge Bonus</span>
            <span>+${card.dodge || 10}%</span>
        </div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid #1a1a1f;font-weight:600">
            <span>Success Threshold</span>
            <span>${chance}%</span>
        </div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid #1a1a1f">
            <span>Your Roll</span>
            <span>${roll}</span>
        </div>
        <div style="display:flex;justify-content:space-between;padding:6px 0;margin-top:4px;font-weight:600;border-top:1px solid var(--border)">
            <span>Result</span>
            <span style="color:${success ? '#3dbdbd' : '#c9302c'}">${success ? 'SUCCESS!' : 'FAILED'}</span>
        </div>
        ${success ? `
        <div style="display:flex;justify-content:space-between;padding:3px 0;color:#d9a34a;font-weight:600">
            <span>Ammo Found</span>
            <span>+${ammo}</span>
        </div>
        ` : ''}
    `;
   
    show('scavengePanel');
}

function closeScavenge() {
    hide('scavengePanel');
   
    // If AI is waiting for this panel, continue
    if (G.aiWaitingPanel === 'scavengePanel') {
        aiContinue();
    }
}

function hideMember() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card first!', G.turn);
        return;
    }
    const card = G.selected;
    const effectiveMove = getEffectiveMove(card);
    const actionsLeft = effectiveMove - (card.actionsUsed || 0);
    if (actionsLeft < 2) {
        log(`${card.name} needs 2+ actions to hide!`, G.turn);
        return;
    }

    const faction = G.turn;
    const fieldIdx = G.field[faction].findIndex(c => c.id === card.id);
    if (fieldIdx === -1) return;

    // Retreat: field ‚Üí hand (deployable next turn)
    const hiddenCard = G.field[faction].splice(fieldIdx, 1)[0];
    hiddenCard.actionsUsed = 0; // Reset for redeploy
    G.hands[faction].push(hiddenCard);

    // Cost: Use 2 actions on hider
    card.actionsUsed += 2;

    // Team covers retreat: IMMEDIATE exhaustion this turn +1 supp next
    G.field[faction].forEach(c => {
        const effectiveMove = getEffectiveMove(c);  // Account for auras/events
        c.actionsUsed = effectiveMove;              // Zero remaining actions NOW
        c.suppressed = (c.suppressed || 0) + 1;    // +1 supp carryover
    });

    // Feedback
    playSound('suppress');
    addToFeed(faction, `${hiddenCard.name} hides! (team covers retreat)`,
        'Team exhausted this turn +1 supp next', 'suppress');
    G.selected = null;
    updateUI();
}

function detonateDynamite() {
    if (!G.activeDynamite) return;
    
// 10% chance of DUD (doesn't explode)
    const dudRoll = Math.random() * 100;
    if (dudRoll < 10) {
        // STOP FUSE SOUND
        if (window.currentSound && window.currentSound.soundType === 'dynamite_fuse') {
            window.currentSound.pause();
            window.currentSound = null;
        }
        
        addEventToFeeds('üí£ DUD! Dynamite fizzles out!', 'üß® No explosion - defective charge');
        addToFeed(G.activeDynamite.throwerFaction, 'üß®', 'Dynamite was a DUD!', 'Fuse burned but no explosion!', 'debuff');
        
        G.activeDynamite = null;
        updateUI();
        return;
    }
    
        // Check for backfire - if backfired, hit thrower's OWN team instead!
    const targetFaction = G.activeDynamite.backfired 
        ? G.activeDynamite.throwerFaction 
        : (G.activeDynamite.throwerFaction === 'outlaw' ? 'law' : 'outlaw');
    const enemies = G.field[targetFaction];
    
    if (enemies.length === 0) {
        addEventToFeeds('üí£ Dynamite explodes harmlessly!', 'No targets remaining');
        G.activeDynamite = null;
        return;
    }
    
// STOP FUSE SOUND
if (G.activeDynamite?.fuseAudio) {
    G.activeDynamite.fuseAudio.pause();
    G.activeDynamite.fuseAudio = null;  // optional, clean up reference
}
    
    // PLAY EXPLOSION SOUND
    playSound('dynamite_explode');
    
    // SCREEN SHAKE + BLUR EFFECT
    document.body.classList.add('dynamite-shake');
    document.body.classList.add('dynamite-blur');
    
    // Remove shake after animation completes
    setTimeout(() => {
        document.body.classList.remove('dynamite-shake');
    }, 500);
    
    // Remove blur after dynamite explosion
    setTimeout(() => {
        document.body.classList.remove('dynamite-blur');
    }, 15000);
    
    // Select random targets (1-3)
    const numTargets = Math.min(G.activeDynamite.targets, enemies.length);
    const shuffled = [...enemies].sort(() => Math.random() - 0.5);
    const targets = shuffled.slice(0, numTargets);
    
    let casualties = [];
    let hitDetails = [];
    
    targets.forEach(target => {
        // Random damage per card
        const damage = G.activeDynamite.damageRange[0] + Math.floor(Math.random() * (G.activeDynamite.damageRange[1] - G.activeDynamite.damageRange[0] + 1));
        
        // Random ACC penalty
        const accPenalty = G.activeDynamite.accPenaltyRange[0] + Math.floor(Math.random() * (G.activeDynamite.accPenaltyRange[1] - G.activeDynamite.accPenaltyRange[0] + 1));
        
        // Random State penalty
        const statePenalty = G.activeDynamite.statePenaltyRange[0] + Math.floor(Math.random() * (G.activeDynamite.statePenaltyRange[1] - G.activeDynamite.statePenaltyRange[0] + 1));
        
        target.hp -= damage;
        
        // Apply debuffs to survivors
        if (target.hp > 0) {
            // ACC penalty (permanent until end of match)
            if (!target.dynamiteAccPenalty) {
                target.dynamiteAccPenalty = accPenalty;
            }
            
            // State penalty (immediate)
            target.state = Math.max(0, target.state + statePenalty);
            
            hitDetails.push(`${target.name}: -${damage}HP, ${accPenalty}% ACC, ${statePenalty} State`);
        } else {
            casualties.push(target.name);
        }
    });
    
        // Remove dead cards
    G.field[targetFaction] = G.field[targetFaction].filter(e => e.hp > 0);
    
    // Score handling - if backfired, enemy gets the kills!
    if (G.activeDynamite.backfired) {
        const enemyFaction = G.activeDynamite.throwerFaction === 'outlaw' ? 'law' : 'outlaw';
        G.scores[enemyFaction] += casualties.length;
    } else {
        G.scores[G.activeDynamite.throwerFaction] += casualties.length;
    }
    
    const backfireMsg = G.activeDynamite.backfired ? ' ‚ö†Ô∏è BACKFIRE - HIT OWN TEAM!' : '';
    addEventToFeeds(`üß®üí• DYNAMITE EXPLODES!${backfireMsg}`, `${numTargets} hit! ${casualties.length} killed!`);
    
    hitDetails.forEach(detail => {
        addToFeed(targetFaction, 'üí•', detail, '', 'debuff');
    });
    
    if (casualties.length > 0) {
        const killMsg = G.activeDynamite.backfired ? 'üíÄ‚ö†Ô∏è BACKFIRE KILLS OWN TEAM!' : 'üíÄ Dynamite kills:';
        addToFeed(targetFaction, 'üíÄ', `${killMsg} ${casualties.join(', ')}!`, '', 'kill');
        playSound('kill');
    }
    
    G.activeDynamite = null;
    updateUI();
}

// ============ SHARE AMMO SYSTEM ============
function shareAmmoMode() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card first!', G.turn);
        return;
    }
    if (G.selected.ammo <= 1) {
        log(`${G.selected.name} doesn't have enough ammo to share! (need at least 2)`, G.turn);
        return;
    }
   
    // Check if there are any allies who could use ammo
    const allies = G.field[G.turn].filter(c => c.id !== G.selected.id && c.ammo < c.maxAmmo);
    if (allies.length === 0) {
        log('No allies need ammo!', G.turn);
        return;
    }
   
    G.actionMode = 'share';
    log(`Select a friendly card to share ammo with...`, G.turn);
}

function performShareAmmo(giver, receiver) {
    // Validate
    if (giver.ammo <= 1) {
        return;
    }
    if (receiver.ammo >= receiver.maxAmmo) {
        return;
    }
   
    // Calculate ammo transfer (random 1-3, capped by what giver has - 1 and receiver can hold)
    const ammoRoll = Math.random();
    let ammoToGive;
    if (ammoRoll < 0.5) ammoToGive = 1;        // 50% chance: 1 ammo
    else if (ammoRoll < 0.85) ammoToGive = 2;  // 35% chance: 2 ammo
    else ammoToGive = 3;                        // 15% chance: 3 ammo
   
    // Cap by giver's ammo (must keep at least 1) and receiver's capacity
    const maxGiverCanGive = giver.ammo - 1;
    const maxReceiverCanTake = receiver.maxAmmo - receiver.ammo;
    const actualAmmo = Math.min(ammoToGive, maxGiverCanGive, maxReceiverCanTake);
   
    if (actualAmmo <= 0) {
        return;
    }
   
    // Apply costs to giver:
    // 1. Lose the ammo being shared
    giver.ammo -= actualAmmo;
   
    // 2. Move points halved (rounded up) - increase actionsUsed
    const movePenalty = Math.ceil(giver.move / 2);
    giver.actionsUsed = Math.min(giver.move, (giver.actionsUsed || 0) + movePenalty);
   
    // 3. Giver becomes suppressed (1 point)
    giver.suppressed = (giver.suppressed || 0) + 1;
   
    // Apply benefit to receiver:
    receiver.ammo += actualAmmo;
   
    addToFeed(giver.faction, 'üì¶', `${giver.name} ‚Üí ${receiver.name}`, `+${actualAmmo} ammo shared`, 'share');
   
    // Show the share panel
    showSharePanel(giver, receiver, actualAmmo, movePenalty);
}

function showSharePanel(giver, receiver, ammo, movePenalty) {
    clearCombatPrediction(); // Clear tooltip immediately
   
    $('combatHeader').textContent = 'üì¶ AMMO SHARED! üì¶';
   
    // Giver info
    $('attackerPortrait').textContent = giver.portrait;
    $('attackerName').textContent = giver.name;
    $('attackerHP').textContent = `${giver.hp}/${giver.maxHp} HP`;
    $('attackerAmmo').textContent = `Ammo: ${giver.ammo}/${giver.maxAmmo}`;
    const giverPct = (giver.hp / giver.maxHp) * 100;
    $('attackerHPBar').style.width = giverPct + '%';
    $('attackerHPBar').className = 'combat-hp-fill ' + getHPClass(giverPct);
   
    // Receiver info
    $('defenderPortrait').textContent = receiver.portrait;
    $('defenderName').textContent = receiver.name;
    $('defenderHP').textContent = `${receiver.hp}/${receiver.maxHp} HP`;
    $('defenderStatus').innerHTML = `<span style="color:#d9a34a">+${ammo} AMMO</span>`;
    const receiverPct = (receiver.hp / receiver.maxHp) * 100;
    $('defenderHPBar').style.width = receiverPct + '%';
    $('defenderHPBar').className = 'combat-hp-fill ' + getHPClass(receiverPct);
   
    $('combatDefender').style.display = '';
    $('combatVs').style.display = '';
    $('combatVs').textContent = '‚Üí';
   
    $('combatDamage').textContent = `+${ammo} AMMO`;
    $('combatDamage').className = 'combat-damage';
    $('combatDamage').style.color = '#d9a34a';
   
    $('combatEffects').innerHTML = `
        <span class="combat-effect buff">Receiver: +${ammo} ammo</span>
        <span class="combat-effect debuff">Giver: -${ammo} ammo</span>
    `;
   
    $('combatBreakdown').innerHTML = `
        <div class="combat-breakdown-title">Ammo Transfer</div>
        <div class="combat-breakdown-row" style="color:#4ade80">
            <span>${receiver.name} Received</span>
            <span>+${ammo} ammo</span>
        </div>
        <div class="combat-breakdown-row sub" style="color:#f87171">
            <span>${giver.name} Lost</span>
            <span>-${ammo} ammo</span>
        </div>
        <div class="combat-breakdown-title" style="margin-top:12px">Cost to Giver</div>
        <div class="combat-breakdown-row sub" style="color:#f87171">
            <span>Movement Penalty</span>
            <span>-${movePenalty} actions</span>
        </div>
        <div class="combat-breakdown-row sub" style="color:#9b6bcc">
            <span>Suppression</span>
            <span>+1</span>
        </div>
        <div class="combat-breakdown-row result" style="margin-top:8px">
            <span>Status</span>
            <span style="color:#d9a34a">RESUPPLIED!</span>
        </div>
    `;
   
    show('combatPanel');
}

// ============ RALLY SYSTEM ============
function attemptRally() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card to rally!', G.turn);
        return;
    }
   
    // Check if rally already used this turn
    if (G.rallyUsedThisTurn) {
        log('Rally already used this turn! (1 per turn limit)', G.turn);
        return;
    }
   
    const card = G.selected;
    const isOutOfMoves = card.actionsUsed >= card.move;
    const isSuppressed = card.suppressed && card.suppressed > 0;
   
    if (!isOutOfMoves && !isSuppressed) {
        log(`${card.name} doesn't need to rally - has actions available!`, G.turn);
        return;
    }
   
    // Calculate rally chance based on HP and Ammo
    const hpPercent = (card.hp / card.maxHp) * 100;
    const ammoPercent = (card.ammo / card.maxAmmo) * 100;
    const baseChance = 15; // Base 15% chance
    const hpBonus = (hpPercent / 100) * 45; // Up to +45% from HP (full HP = +45%)
    const ammoBonus = (ammoPercent / 100) * 25; // Up to +25% from Ammo (full ammo = +25%)
   
    // Check for rally bonus from aura abilities
    let auraRallyBonus = 0;
    G.field[G.turn].forEach(ally => {
        getAbilitiesByEffect(ally, 'aura', 'rally_bonus').forEach(ab => {
            auraRallyBonus += ab.value;
        });
    });
   
    // Penalty if heavily suppressed
    const suppressionPenalty = isSuppressed ? Math.min(20, card.suppressed * 5) : 0; // -5% per suppression point, max -20%
   
    G.rallyChance = Math.max(5, Math.min(90, Math.floor(baseChance + hpBonus + ammoBonus + auraRallyBonus - suppressionPenalty)));
    if (card.shattered) {
    log(`${card.name} cannot rally ‚Äî High Velocity shatter!`, G.turn);
    return;
}
    G.rallyCard = card;
    G.rallyType = isSuppressed ? 'team' : 'self'; // Team rally if suppressed, self rally if just exhausted
   
    // Show rally panel
    const rallyTypeText = G.rallyType === 'team' ? '(Team Rally - Clears ALL suppression)' : '(Self Rally - Restores 1-2 actions)';
    $('rallyCard').innerHTML = `
        <div style="font-size:2em">${card.portrait}</div>
        <div style="font-weight:bold;color:var(--gold)">${card.name}</div>
        <div style="font-size:.75em;color:#aaa;margin-top:4px">${rallyTypeText}</div>
        <div style="font-size:.85em;margin-top:8px">
            <span class="stat-hp">HP: ${card.hp}/${card.maxHp}</span> |
            <span class="stat-ammo">Ammo: ${card.ammo}/${card.maxAmmo}</span>
        </div>
    `;
    $('rallyChance').textContent = G.rallyChance + '%';
    $('rallyFill').style.width = G.rallyChance + '%';
   
    let detailsText = `Base: ${baseChance}% + HP: +${Math.floor(hpBonus)}% + Ammo: +${Math.floor(ammoBonus)}%`;
    if (auraRallyBonus > 0) detailsText += ` + Aura: +${auraRallyBonus}%`;
    if (suppressionPenalty) detailsText += ` - Suppression: -${suppressionPenalty}%`;
    $('rallyDetails').innerHTML = detailsText;
   
    // Reset button states for player rally
    $('rallyResult').classList.add('hidden');
    $('rallyBtn').classList.remove('hidden');
    $('rallyCancelBtn').classList.remove('hidden');
    $('rallyContinueBtn').classList.add('hidden');
    show('rallyPanel');
}

function executeRally() {
    const roll = Math.random() * 100;
    const success = roll < G.rallyChance;
   
    // Mark rally as used for this turn (whether success or fail)
    G.rallyUsedThisTurn = true;
   
    // Track rally stats
    G.stats[G.turn].rallies++;
   
    // Hide roll button and cancel, show continue
    $('rallyBtn').classList.add('hidden');
    $('rallyCancelBtn').classList.add('hidden');
    $('rallyContinueBtn').classList.remove('hidden');
   
    if (success) {
        G.stats[G.turn].rallySuccess++;
        $('rallyResult').textContent = 'üî• RALLY SUCCESS! üî•';
        $('rallyResult').className = 'rally-result success';
       
        if (G.rallyType === 'team') {
// Tick down & apply Signal Charge effects - FIXED
['outlaw', 'law'].forEach(faction => {
    G.field[faction].forEach(card => {
        if (card.signalChargeEffects && card.signalChargeEffects.length > 0) {
            console.log(`[SIGNAL DEBUG] ${card.name} (${faction}) - ${card.signalChargeEffects.length} effects`);

            // Single loop: apply active ‚Üí then decrement ‚Üí collect survivors
            const newEffects = [];
            
            card.signalChargeEffects.forEach(e => {
                if (e.turnsLeft > 0) {
                    // Apply only if still active
                    if (e.type === 'state') {
                        card.state = Math.max(0, (card.state || 100) + e.value);
                        console.log(`  ‚Üí Applied state: ${e.value} ‚Üí new state: ${card.state}`);
                    }
                    // ACC is recalculated live, no need to store

                    // Decrement AFTER apply
                    e.turnsLeft--;
                    console.log(`  ‚Üí ${e.type} turnsLeft now: ${e.turnsLeft}`);

                    // Keep if still active next turn
                    if (e.turnsLeft > 0) {
                        newEffects.push(e);
                    } else {
                        console.warn(`  ‚Üí ${e.type} EXPIRED!`);
                    }
                }
            });

            // Replace with only surviving effects
            card.signalChargeEffects = newEffects;

            // Final state snapshot
            console.log(`  ‚Üí Final State: ${card.state || 100}`);
            console.log(`  ‚Üí Final ACC: ${getEffectiveAccuracy(card)}%`);
        }
    });
});
    
    // Count allies for team morale bonus
    const allyCount = G.field[G.turn].length;
    const teamMoraleBonus = Math.min(20, allyCount * 3); // +3 state per ally, max +20
    
    // Team Rally - Clear suppression + state boost to ALL friendly cards
    let totalStateRestored = 0;
    G.field[G.turn].forEach(card => {
        if (card.suppressed) {
            card.actionsUsed = Math.max(0, card.actionsUsed - card.suppressed);
            card.suppressed = 0;
        }
        
        // Calculate state restoration: HP + Dodge + Ammo + Team Morale
        const hpFactor = (card.hp / card.maxHp) * 12; // 0-12 from HP
        const dodgeFactor = (card.dodge / 100) * 10; // 0-10 from dodge
        const ammoFactor = (card.ammo / card.maxAmmo) * 8; // 0-8 from ammo
        const individualBonus = Math.floor(hpFactor + dodgeFactor + ammoFactor); // 0-30
        
        const totalStateGain = Math.max(15, individualBonus + teamMoraleBonus); // min +15
        card.state = Math.min(100, (card.state || 100) + totalStateGain);
        totalStateRestored += totalStateGain;
    });
    
    const avgStateGain = Math.floor(totalStateRestored / allyCount);
    addToFeed(G.turn, 'üî•', `${G.rallyCard.name} RALLIES TEAM!`, `${allyCount} allies +${avgStateGain} avg morale!`, 'rally');
    
} else {
    // Self Rally - Restore 1-2 actions + state boost
    const allyCount = G.field[G.turn].length;
    const teamMoraleBonus = Math.min(20, allyCount * 3); // +3 state per ally, max +20
    
    const hpPercent = G.rallyCard.hp / G.rallyCard.maxHp;
    const actionsRestored = hpPercent >= 0.5 ? 2 : 1; // 2 actions if 50%+ HP, else 1
    G.rallyCard.actionsUsed = Math.max(0, G.rallyCard.actionsUsed - actionsRestored);
    
    // Calculate state restoration: HP + Dodge + Ammo + Team Morale
    const hpFactor = hpPercent * 18; // 0-18 from HP
    const dodgeFactor = (G.rallyCard.dodge / 100) * 14; // 0-14 from dodge
    const ammoFactor = (G.rallyCard.ammo / G.rallyCard.maxAmmo) * 13; // 0-13 from ammo
    const individualBonus = Math.floor(hpFactor + dodgeFactor + ammoFactor); // 0-45
    
    const totalStateGain = Math.max(20, individualBonus + teamMoraleBonus); // min +20
    G.rallyCard.state = Math.min(100, (G.rallyCard.state || 100) + totalStateGain);
    
    addToFeed(G.turn, 'üî•', `${G.rallyCard.name} rallies!`, `+${actionsRestored} action(s) +${totalStateGain} morale (${allyCount} allies)`, 'rally');
}

} else {
    $('rallyResult').textContent = 'üí® RALLY FAILED';
    $('rallyResult').className = 'rally-result fail';
    addToFeed(G.turn, 'üí®', `${G.rallyCard.name} failed to rally`, `Roll: ${Math.floor(roll)} vs ${G.rallyChance}%`, 'rally');
}

$('rallyResult').classList.remove('hidden');
$('rallyDetails').innerHTML = `Rolled: ${Math.floor(roll)} (needed < ${G.rallyChance})`;

updateUI();
}

function performSuppress(attacker, target) {
    const effectiveMove = getEffectiveMove(attacker);
    if (attacker.actionsUsed >= effectiveMove) {
        return;
    }
    if (attacker.ammo <= 0) {
        return;
    }
   
    playSound('suppress');
   
    // Suppression costs half of current ammo (rounded up)
    const ammoCost = Math.ceil(attacker.ammo / 2);
    attacker.ammo -= ammoCost;
    attacker.actionsUsed++;
    
    // BASE SUPPRESSION: Fire √ó 1.5 (instead of flat supp stat)
    const baseSuppression = attacker.fire * 1.5;
    
// Add any ability bonuses (BAR, Lewis Gun, etc.)
let totalSuppression = baseSuppression;
const attackerAbilities = getAbilitiesByTrigger(attacker, 'on_attack');
attackerAbilities.forEach(ab => {
    if (ab.effect === 'lewis_suppression') {
        // Lewis Gun: value is object, use suppBonus property
        const bonus = attacker.fire * (ab.value.suppBonus || 0);
        totalSuppression += bonus;
    } else if (ab.effect && ab.effect.toLowerCase().includes('supp')) {
        // BAR and others: value is a number multiplier
        const bonus = attacker.fire * ab.value;
        totalSuppression += bonus;
    }
});
    
    target.suppressed = (target.suppressed || 0) + totalSuppression;
    
// STATE/MORALE DROP: Scale with suppression applied!
// Base: fire √ó 1.6 + 3
// PLUS: suppression √ó 1.5 (the more bullets, the more fear)
const baseFear = Math.floor(getEffectiveFire(attacker) * 1.6) + 3;
const suppressFear = totalSuppression * 1.5;  // Scale with actual suppression
const totalFear = Math.max(10, baseFear + suppressFear);

target.state = Math.max(0, (target.state || 100) - totalFear);
   
    // Track stats
    G.stats[attacker.faction].ammoUsed += ammoCost;
   
    addToFeed(attacker.faction, 'üíú', `${attacker.name} suppresses ${target.name}`, 
        `${totalSuppression.toFixed(1)} suppression, -${suppressFear} morale, ${ammoCost} ammo used`, 'suppress');
   
    G.selected = attacker;
    updateUI();
}

function performArrest(attacker, target) {
    // One use only ‚Äî burn charge
    if (!attacker.arrestCharges || attacker.arrestCharges <= 0) {
        log(`${attacker.name} has no Arrest Warrants left this deploy!`, attacker.faction);
        return;
    }
    attacker.arrestCharges--;  // Burn 1 use
    
    // Remove ability when exhausted
    if (attacker.arrestCharges === 0) {
        attacker.abilities = attacker.abilities.filter(a => a !== 'arrestwarrant');
        addToFeed(attacker.faction, 'üîí', `${attacker.name}'s Arrest Warrant is exhausted!`, 'Ability removed', 'debuff');
    }
    
    // Cost: 2 Move (exposes self +0.5 supp)
    attacker.actionsUsed += 2;
    
    // 100% ARREST (no roll ‚Äî reliable cuff)
    target.arrested = true;
    target.arrestTurns = 0;
    target.arrestedBy = attacker.faction;
    
    addToFeed(attacker.faction, 'üîí', `${attacker.name} ARRESTS ${target.name}!`, 'Target LOCKED UP!', 'attack');
    
    // Combat panel for feedback
    showArrestPanel(attacker, target);
    G.selected = attacker;
    updateUI();
}

function endTurn(isAI = false) {
    // DEBUG: Signal Charge Tracker - drop this at the VERY TOP of endTurn()
console.groupCollapsed(`[DEBUG] Signal Charge - Turn ${G.turn} (Round ${G.round})`);
    G.field.outlaw.concat(G.field.law).forEach(card => {
        if (card.signalChargeEffects && card.signalChargeEffects.length > 0) {
            console.log(`Card: ${card.name} (${card.faction})`);
            console.table(card.signalChargeEffects.map(e => ({
                type: e.type,
                value: e.value,
                turnsLeft: e.turnsLeft,
                effectActive: e.turnsLeft > 0
            })));
            console.log(`  ‚Üí Current State: ${card.state || 100}`);
            console.log(`  ‚Üí Current ACC: ${getEffectiveAccuracy(card)}%`);
        }
    });
    console.groupEnd();
    // Block if AI is thinking and this is a manual call
    if (!isAI && G.aiThinking) return;
    if (!isAI && G.aiEnabled && G.turn === G.aiFaction) return;
   
    playSound('endTurn');
    
     ['outlaw', 'law'].forEach(faction => {
        G.field[faction].forEach(card => {
            if (card.signalChargeEffects && card.signalChargeEffects.length > 0) {
                console.log(`[TICK] Processing ${card.name} (${faction}) - ${card.signalChargeEffects.length} effects`);

                // Apply active debuffs
                card.signalChargeEffects.forEach(e => {
                    if (e.turnsLeft > 0) {
                        if (e.type === 'state') {
                            const oldState = card.state || 100;
                            card.state = Math.max(0, oldState + e.value);
                            console.log(`  Applied ${e.value} to state ‚Üí ${oldState} ‚Üí ${card.state}`);
                        }
                        // ACC is recalculated live in getEffectiveAccuracy ‚Äî no need to apply here
                    }
                });

                // Decrement ALL effects
                card.signalChargeEffects.forEach(e => {
                    e.turnsLeft--;
                    console.log(`  ${e.type} turnsLeft now: ${e.turnsLeft}`);
                });

                // Remove expired
                const oldCount = card.signalChargeEffects.length;
                card.signalChargeEffects = card.signalChargeEffects.filter(e => e.turnsLeft > 0);
                if (card.signalChargeEffects.length < oldCount) {
                    console.warn(`  ‚Üí ${oldCount - card.signalChargeEffects.length} debuff(s) EXPIRED this turn!`);
                }

                console.log(`[TICK END] ${card.name} - ${card.signalChargeEffects.length} effects remain | State: ${card.state} | ACC: ${getEffectiveAccuracy(card)}%`);
            }
        });
    });
   
        // Process max ammo refills from active events
    G.activeEvents.filter(e => e.stat === 'max_ammo').forEach(e => {
        const faction = e.faction === 'both' ? ['outlaw', 'law'] : [e.faction];
        faction.forEach(f => {
            G.field[f].forEach(card => {
                if (card.ammo < card.maxAmmo) {
                    const oldAmmo = card.ammo;
                    card.ammo = card.maxAmmo;
                    addToFeed(f, 'üì¶', `${card.name} reloads!`, `+${card.ammo - oldAmmo} ammo from ${e.name}`, 'scavenge');
                }
            });
        });
    });
   
        // Tick down fortification
    ['outlaw', 'law'].forEach(faction => {
        G.field[faction].forEach(card => {
            if (card.fortified && card.fortified > 0) {
                card.fortified--;
                if (card.fortified === 0) {
                    addToFeed(faction, 'üèöÔ∏è', `${card.name}'s fortification expires`, '', 'event');
                }
            }
        });
    });
    
// Countdown dynamite timer
if (G.activeDynamite) {
    if (G.activeDynamite.timer > 0) {
        G.activeDynamite.timer--;
        if (G.activeDynamite.timer > 0) {
            addEventToFeeds(`üí£ DYNAMITE STILL ACTIVE!`, 'üß® Fuse burning...');
        }
    }
    
    if (G.activeDynamite.timer === 0) {
        detonateDynamite();
    }
}
   
    // Process bleeding damage at turn end
['outlaw', 'law'].forEach(faction => {
    const deadCards = [];
   
    G.field[faction].forEach(card => {
        if (card.bleeding && card.hp > 0) {
            card.hp -= 1;
            log(`ü©∏ ${card.name} bleeds for 1 HP (${card.hp} HP remaining)`, 'bleeding');
            if (card.hp <= 0) {
                deadCards.push(card);
            }
        }
    });
    
    // High Velocity bleed drain + supp tick
['outlaw', 'law'].forEach(faction => {
    G.field[faction].forEach(card => {
        if (card.shattered && card.hp > 2) {
            // Slow bleed to floor 2 HP
            card.hp = Math.max(2, card.hp - 0.5);
            card.suppressed += 1;  // Constant supp tick
            
            addToFeed(faction, 'ü©∏', `${card.name} bleeds from High Velocity wound`, '-0.5 HP +1 supp', 'debuff');
        }
    });
});
    
    G.activeEvents.forEach(e => {
    if (e.stat === 'drain_ammo' && e.turnsLeft > 0) {
        const targets = e.faction === 'both' ? [...G.field.outlaw, ...G.field.law] : G.field[e.faction];
        targets.forEach(c => {
            const oldAmmo = c.ammo;
            c.ammo = Math.max(0, c.ammo - e.value);
            if (c.ammo < oldAmmo) {
                addToFeed(c.faction, 'üîª', `${c.name} loses ammo`, `-${oldAmmo - c.ammo}`, 'scavenge');
            }
        });
    }
});
   
    // Remove dead cards and update score
    deadCards.forEach(card => {
        G.field[faction] = G.field[faction].filter(c => c.id !== card.id);
        const enemyFaction = faction === 'outlaw' ? 'law' : 'outlaw';
        G.scores[enemyFaction]++;
        G.stats[enemyFaction].kills++;
        addToFeed(faction, 'üíÄ', `${card.name} has bled out!`, '', 'kill');
    });
});

// Process burning damage at turn end (similar to bleeding but with duration countdown)
['outlaw', 'law'].forEach(faction => {
    const burnedCards = [];
   
    G.field[faction].forEach(card => {
        if (card.burning && card.burning > 0 && card.hp > 0) {
            card.hp -= 1;
            card.burning--; // Decrement burning duration
            log(`üî• ${card.name} burns for 1 HP (${card.burning} turn${card.burning !== 1 ? 's' : ''} remaining, ${card.hp} HP left)`, 'burning');
            if (card.hp <= 0) {
                burnedCards.push(card);
            }
        }
    });
   
    // Remove dead cards and update score
    burnedCards.forEach(card => {
         if (card.isVehicle) {
        forceDisembarkAll(card);
    }
        G.field[faction] = G.field[faction].filter(c => c.id !== card.id);
        const enemyFaction = faction === 'outlaw' ? 'law' : 'outlaw';
        G.scores[enemyFaction]++;
        G.stats[enemyFaction].kills++;
        addToFeed(faction, 'üíÄ', `${card.name} has burned to death!`, '', 'kill');
    });
});
   
// Apply on_turn_end abilities (now supports multiple abilities per card)
G.field[G.turn].forEach(card => {
    const turnEndAbilities = getAbilitiesByTrigger(card, 'on_turn_end');
    
    turnEndAbilities.forEach(ability => {
        if (ability.effect === 'fortify') {
            // 50% chance to fortify for 2 turns
            if (Math.random() < 0.5 && !card.fortified) {
                card.fortified = 2;  // 2 turns of fortification
                addToFeed(G.turn, ability.icon || 'üè∞', `${card.name} fortifies position!`, '+40% dodge, -30% damage, -1 move', 'event');
            }
        }
        if (ability.effect === 'heal_ally') {
            const allies = G.field[G.turn].filter(c => c.id !== card.id && c.hp < c.maxHp);
            if (allies.length > 0) {
                const target = allies[Math.floor(Math.random() * allies.length)];
                const healAmount = ability.value;
                if (target.shattered) {
    addToFeed(G.turn, 'ü©∏', `Cannot heal ${target.name} ‚Äî High Velocity shatter!`, '', 'debuff');
    return;
}
                target.hp = Math.min(target.maxHp, target.hp + healAmount);
                addToFeed(G.turn, ability.icon || 'üíä', `${card.name} heals ${target.name}`, `+${healAmount} HP`, 'heal');
            }
        } else if (ability.effect === 'heal_self') {
            if (card.hp < card.maxHp) {
                const healAmount = Math.min(ability.value, card.maxHp - card.hp);
                card.hp += healAmount;
                addToFeed(G.turn, ability.icon || 'üíö', `${card.name} regenerates`, `+${healAmount} HP`, 'heal');
            }
        } else if (ability.effect === 'ammo_regen') {
            if (card.ammo < card.maxAmmo) {
                const regenAmount = Math.min(ability.value, card.maxAmmo - card.ammo);
                card.ammo += regenAmount;
                addToFeed(G.turn, ability.icon || 'üî∏', `${card.name} recovers ammo`, `+${regenAmount}`, 'scavenge');
            }
        } else if (ability.effect === 'reduce_ally_suppress') {
            // Remove suppression from random suppressed ally
            const suppressedAllies = G.field[G.turn].filter(c => c.suppressed && c.suppressed > 0);
            if (suppressedAllies.length > 0) {
                const target = suppressedAllies[Math.floor(Math.random() * suppressedAllies.length)];
                const removeAmt = Math.min(ability.value, target.suppressed);
                target.suppressed -= removeAmt;
                if (target.shattered) {
    addToFeed(G.turn, 'ü©∏', `Cannot clear ${target.name}'s suppression ‚Äî High Velocity!`, '', 'debuff');
    return;
}
                addToFeed(G.turn, ability.icon || 'üìã', `${card.name} coordinates ${target.name}`, `-${removeAmt} suppression`, 'rally');
            }
        } else if (ability.effect === 'expose_enemy') {
            // Add a temporary dodge debuff to a random enemy
            const enemy = G.turn === 'outlaw' ? 'law' : 'outlaw';
            const enemies = G.field[enemy];
            if (enemies.length > 0) {
                const target = enemies[Math.floor(Math.random() * enemies.length)];
                // Add as a temporary active event targeting that specific card
                G.activeEvents.push({
                    name: `${card.name}'s Intel`,
                    stat: 'dodge',
                    value: -ability.value,
                    faction: enemy,
                    turnsLeft: 2
                });
                addToFeed(G.turn, ability.icon || 'üëÅÔ∏è', `${card.name} exposes ${target.name}`, `-${ability.value}% dodge`, 'event');
            }
        }
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // SUPPLY CRATE ABILITY - TEAM AMMO + RANDOM WEAPONS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        else if (ability.effect === 'supply_crate_spawn') {
            // Initialize charges if not set yet
            if (typeof card.supplyCharges === 'undefined') {
                card.supplyCharges = 2;  // Max 2 successful spawns
            }
            
            // If already spent, remove ability (cleanup)
            if (card.supplyCharges <= 0) {
                card.abilities = card.abilities.filter(a => a !== 'supply_crate');
                addToFeed(G.turn, 'üì¶', `${card.name}'s ammo crate is empty!`, 'Ability exhausted', 'scavenge');
                return;
            }
            
            // 30% chance to spawn supplies this turn
            if (Math.random() * 100 < ability.value.successChance) {
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // TEAM-WIDE AMMO DROP: +15 to everyone
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                let teamAmmoGranted = 0;
                G.field[G.turn].forEach(ally => {
                    if (!ally.isEnvironment && ally.hp > 0) {
                        const oldAmmo = ally.ammo;
                        ally.ammo = Math.min(ally.maxAmmo, ally.ammo + 15);
                        if (ally.ammo > oldAmmo) {
                            teamAmmoGranted += (ally.ammo - oldAmmo);
                        }
                    }
                });
                
                if (teamAmmoGranted > 0) {
                    addToFeed(G.turn, 'üì¶', `${card.name} distributes ammo to the gang!`, `+15 rounds each`, 'scavenge');
                }
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // RANDOM WEAPON DROPS: 1‚Äì3 weapons
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const numWeapons = 1
                
                // Get valid allies (alive, not self, not environment)
                const allies = G.field[G.turn].filter(c => 
                    c.id !== card.id && 
                    !c.isEnvironment && 
                    c.hp > 0
                );
                
                if (allies.length === 0) {
                    addToFeed(G.turn, ability.icon, `${card.name} rumbles...`, 'No allies to supply weapons!', 'scavenge');
                } else {
                    let granted = [];
                    
                    for (let i = 0; i < numWeapons; i++) {
                        // Pick random weapon from pool
                        const weaponId = ability.value.pool[Math.floor(Math.random() * ability.value.pool.length)];
                        
                        // Pick random ally that DOES NOT already have this weapon
                        let attempts = 0;
                        let targetAlly = null;
                        while (attempts < 20 && !targetAlly) {
                            const candidate = allies[Math.floor(Math.random() * allies.length)];
                            if (!candidate.abilities.includes(weaponId)) {
                                targetAlly = candidate;
                            }
                            attempts++;
                        }
                        
                        if (targetAlly) {
                            targetAlly.abilities.push(weaponId);
                            granted.push(`${targetAlly.name} gains ${G.abilities[weaponId].name}`);
                            
                            // Special handling for 'ammo' weapon: +20 ammo burst
                            if (weaponId === 'ammo') {
                                const oldAmmo = targetAlly.ammo;
                                targetAlly.ammo = Math.min(targetAlly.maxAmmo, targetAlly.ammo + 20);
                                granted[granted.length - 1] += ` (+20 ammo)`;
                            }
                        }
                    }
                    
                    // Decrement charges after success
                    card.supplyCharges--;
                    
                    // Feed message
                    if (granted.length > 0) {
                        addToFeed(G.turn, ability.icon, `${card.name} supplies the gang!`, 
                            granted.join(' ‚Ä¢ ') + ` (${card.supplyCharges} uses left)`, 'scavenge');
                    } else {
                        addToFeed(G.turn, ability.icon, `${card.name} rumbles...`, 
                            'No new weapons found (allies already equipped)', 'scavenge');
                    }
                }
                
                // If out of charges, remove ability
                if (card.supplyCharges <= 0) {
                    card.abilities = card.abilities.filter(a => a !== 'supply_crate');
                    addToFeed(G.turn, 'üì¶', `${card.name}'s ammo crate runs dry!`, 'Ability exhausted', 'scavenge');
                }
            }
            // Optional quiet fail (uncomment if you want feedback on misses)
            // else {
            //     addToFeed(G.turn, ability.icon, `${card.name} rumbles...`, 'No supplies this turn', 'scavenge');
            // }
        }
    });
});
   
    // Switch turn
    G.turn = G.turn === 'outlaw' ? 'law' : 'outlaw';
    G.selected = null;
    G.actionMode = null;
   
    // New round check
    if (G.turn === 'outlaw') {
        G.round++;
        addEventToFeeds(`Round ${G.round}`, 'New round begins!');
        
        // Check if forest is deployed - re-roll forest effects
        const forestDeployed = [...G.field.outlaw, ...G.field.law].some(c => c.isEnvironment && c.name === 'Dense Forest');
        if (forestDeployed) {
            // Re-roll for EVERY card on field (both teams)
            [...G.field.outlaw, ...G.field.law].forEach(card => {
                if (card.isEnvironment) return; // Skip environment cards themselves
                
                // Random dodge bonus (+5% to +15%)
                const dodgeRoll = 5 + Math.floor(Math.random() * 11); // 5 to 15
                card.forestDodge = dodgeRoll;
                
                // Random fire modifier (-3 to +3)
                const fireRoll = Math.floor(Math.random() * 7) - 3; // -3 to +3
                card.forestFire = fireRoll;
                
                // Random move modifier (-2 to +2)
               const moveRoll = Math.floor(Math.random() * 5) - 2;  // -2 to +2
               card.forestMove = moveRoll;
               
               // Random accuracy modifier (-10% to +10%)
               const accRoll = Math.floor(Math.random() * 21) - 10;
               card.forestAccuracy = accRoll;
        
             addToFeed(card.faction, 'üå≤', `${card.name} repositions in forest`, 
             `Dodge: +${dodgeRoll}%, Fire: ${fireRoll >= 0 ? '+' : ''}${fireRoll}, Move: ${moveRoll >= 0 ? '+' : ''}${moveRoll}, Acc: ${accRoll >= 0 ? '+' : ''}${accRoll}%`, 'event');
    
            });
            
            addEventToFeeds('üå≤ Forest Shifts', 'Everyone repositions through the trees');
        }
       
        // Apply poison damage from active events
        G.activeEvents.forEach(e => {
            if (e.stat === 'poison') {
                const poisonTargets = e.faction === 'both'
                    ? [...G.field.outlaw, ...G.field.law]
                    : G.field[e.faction];
                poisonTargets.forEach(c => {
                    c.hp = Math.max(0, c.hp - e.value);
                    addToFeed(c.faction, '‚ò†Ô∏è', `${c.name} takes poison damage`, `-${e.value} HP`, 'event');
                });
               
                // Check for poison deaths
                ['outlaw', 'law'].forEach(faction => {
                    G.field[faction] = G.field[faction].filter(c => {
                        if (c.hp <= 0) {
                            const enemy = faction === 'outlaw' ? 'law' : 'outlaw';
                            G.scores[enemy]++;
                            G.stats[enemy].kills++;
                            addToFeed(faction, '‚ò†Ô∏è', `${c.name} died from poison!`, '', 'kill');
                            return false;
                        }
                        return true;
                    });
                });
            }
        });
       
        // Apply persistent defending status from active events
        G.activeEvents.filter(e => e.stat === 'defending').forEach(e => {
            const faction = e.faction === 'both' ? ['outlaw', 'law'] : [e.faction];
            faction.forEach(f => {
                G.field[f].forEach(card => {
                    card.defending = true;
                });
            });
        });
       
        // Tick down active events
        G.activeEvents = G.activeEvents.filter(e => {
            e.turnsLeft--;
            return e.turnsLeft > 0;
        });
       
        // Random event chance (85%)
        if (Math.random() < 0.85 && G.events.length > 0) {
            triggerRandomEvent();
        }
    }
   
    // Reset rally usage for new turn
    G.rallyUsedThisTurn = false;
    // Reset manual event usage for new turn
    G.manualEventUsed = false;
   
// Reset actions and apply suppression
G.field[G.turn].forEach(card => {
    // Natural state regeneration
    if (!card.damagedThisTurn) {
        card.state = Math.min(100, (card.state || 100) + 3);
    }
    card.damagedThisTurn = false;
    
    // Apply current suppression as starting "used" actions for this turn
    
    // NEW: Slowly fade suppression (decays by 2 per turn, min 0)
    const suppDecay = 12;  // ‚Üê Change this number to control how fast it fades
                          // 2 = moderate (supp=8 lasts ~4 turns)
                          // 1 = brutal linger (8 turns)
                          // 3 = quicker recovery (3 turns)
    card.suppressed = Math.max(0, (card.suppressed || 0) - suppDecay);
    card.actionsUsed = card.suppressed || 0;
   
    // Clear Lewis Gun jam AND reset shot counter for next turn
    if (card.lewisJammed) {
        card.lewisJammed = false;
    }
    card.lewisShotsFired = 0;  // Reset heat buildup
    
    // Arrest Warrant release check
if (card.arrested) {
    card.arrestTurns++;
    if (card.arrestTurns >= 2 && Math.random() * 100 < 20) {  // Min 2 turns + 20% chance
        // RELEASE: Drain ammo/MP, strip abilities
        card.arrested = false;
        card.ammo = 0;
        card.actionsUsed = getEffectiveMove(card);  // Full drain MP
        card.abilities = [];  // STRIP ALL ABILITIES
        addToFeed(card.faction, 'üîì', `${card.name} released from arrest!`, '0 ammo/MP, abilities stripped', 'event');
    }
}

    // Optional: Log when suppression fully clears
    if (card.suppressed === 0 && card.actionsUsed > 0) {
        addToFeed(G.turn, 'üòå', `${card.name} shakes off the fear`, 'Suppression cleared', 'rally');
    }

    // Handle cover status (keep your existing code here)
    if (card.coverTurns && card.coverTurns > 0) {
        // ... your existing cover logic ...
    }
       
        // Handle cover status
        if (card.coverTurns && card.coverTurns > 0) {
            // Don't decrement marksman cover (permanent sniper hiding)
            if (!hasAbility(card, 'marksman')) {
                card.coverTurns--;
            }
            if (card.coverTurns <= 0) {
                // Cover expired
                card.coverTurns = 0;
                card.defending = false;
                addToFeed(card.faction, 'ü™®', `${card.name} leaves cover`, 'Stats restored', 'event');
            }
            // Keep defending while in cover
        } else {
            card.defending = false; // Reset defending stance each turn (not in cover)
        }
    });
   
    // Roadblock ability check - immobilize enemy vehicles
    const enemy = G.turn === 'outlaw' ? 'law' : 'outlaw';
    const roadblockers = G.field[G.turn].filter(card => hasAbility(card, 'roadblock'));
    const enemyVehicles = G.field[enemy].filter(card => card.isVehicle);
   
    if (roadblockers.length > 0 && enemyVehicles.length > 0) {
        roadblockers.forEach(blocker => {
            enemyVehicles.forEach(vehicle => {
                const roadblockChance = 40; // 40% chance per roadblocker
                if (Math.random() * 100 < roadblockChance) {
                    vehicle.roadblocked = true;
                    
                    //Roadblock Sound effect
                    playSound('roadblock');
                    
                    addToFeed(G.turn, 'üöß', `${blocker.name} sets up roadblock!`, `${vehicle.name} immobilized!`, 'event');
                } else {
                    vehicle.roadblocked = false;
                }
            });
        });
    }
   
    updateUI();
   
    // Check victory after poison/event processing
    checkVictory();
   
    // Check if it's now AI's turn
    if (G.aiEnabled && G.turn === G.aiFaction) {
        setTimeout(() => aiTakeTurn(), 1000);
    }
}

// ============ VEHICLE SYSTEM ============
function boardVehicle() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card first!', G.turn);
        return;
    }
   
    const card = G.selected;
    const effectiveMove = getEffectiveMove(card);
   
    // Check if already in vehicle
    if (card.inVehicle) {
        log(`${card.name} is already in a vehicle!`, G.turn);
        return;
    }
   
    // Check if card is a vehicle
    if (card.isVehicle) {
        log(`Cannot board the vehicle with itself!`, G.turn);
        return;
    }
   
    // Check if has actions
    if (card.actionsUsed >= effectiveMove) {
        log(`${card.name} has no actions left!`, G.turn);
        return;
    }
   
    // Enter board mode - wait for user to click vehicle
    G.actionMode = 'board';
    log('Click on the vehicle to board...', G.turn);
}

function performBoarding(card, vehicle) {
    // Initialize passengers array if missing
    if (!vehicle.passengers) {
        vehicle.passengers = [];
    }
    
    // Check vehicle capacity
    if (vehicle.passengers.length >= vehicle.maxPassengers) {
        log(`${vehicle.name} is full (${vehicle.maxPassengers} max)!`, G.turn);
        return;
    }
   
    // Board the vehicle (costs 1 action)
    card.actionsUsed++;
    card.inVehicle = true;
    card.vehicleId = vehicle.id;
    vehicle.passengers.push(card.id);
   
    addToFeed(G.turn, 'üöó', `${card.name} boards ${vehicle.name}!`, `${vehicle.passengers.length}/${vehicle.maxPassengers} passengers`, 'event');
    log(`${card.name} boarded ${vehicle.name}!`, G.turn);
}

function disembarkVehicle() {
    if (!isPlayerTurn()) return;
    if (!G.selected) {
        log('Select a card to disembark!', G.turn);
        return;
    }
    
    const card = G.selected;
   
    // Check if in vehicle
    if (!card.inVehicle) {
        log(`${card.name} is not in a vehicle!`, G.turn);
        return;
    }
   
    // Find the vehicle
    const vehicle = G.field[G.turn].find(c => c.id === card.vehicleId);
    if (!vehicle) {
        log('Vehicle not found!', G.turn);
        return;
    }
   
    // Disembark (free action)
    card.inVehicle = false;
    card.vehicleId = null;
    vehicle.passengers = vehicle.passengers.filter(id => id !== card.id);
   
    addToFeed(G.turn, 'üö™', `${card.name} disembarks from ${vehicle.name}!`, '', 'event');
    log(`${card.name} disembarked!`, G.turn);
    updateUI();
}

function forceDisembarkAll(vehicle) {
    if (!vehicle.isVehicle || !vehicle.passengers?.length) return;

    const faction = vehicle.faction;
    const passengerIds = [...vehicle.passengers];

    passengerIds.forEach(passengerId => {
        const passenger = G.field[faction].find(c => c.id === passengerId);
        if (passenger) {
            passenger.inVehicle   = false;
            passenger.vehicleId   = null;
            // Extra safety: clear any other vehicle-related flags you might add later
            passenger.boardedThisTurn = false;   // if you ever add this
            passenger.insideBurningVehicle = false; // future-proofing

            addToFeed(faction, 'üí•', `${passenger.name} leaps from the burning ${vehicle.name}!`, 'Vehicle destroyed!', 'event');
        }
    });

    vehicle.passengers = [];   // Clear the vehicle's list too
    updateUI();                // Force immediate UI refresh
}

function ramAction() {
    if (!isPlayerTurn()) return;
    if (!G.selected || !G.selected.isVehicle) {
        log('Select a vehicle first!', G.turn);
        return;
    }
    const vehicle = G.selected;
    const effectiveMove = getEffectiveMove(vehicle);
    if (vehicle.actionsUsed >= effectiveMove || vehicle.ammo <= 0) {
        log(`${vehicle.name} has no actions/ammo for RAM!`, G.turn);
        return;
    }
    if (vehicle.rammed) {
        log(`${vehicle.name} already RAMmed this deploy!`, G.turn);
        return;
    }
    if (!hasAbility(vehicle, 'ram')) {
        log(`${vehicle.name} does not have RAM ability!`, G.turn);
        return;
    }
    performRam(vehicle);
}

function performRam(vehicle) {
    playSound('roadblock');  // Uses your existing crash sound
    
    // Cost: Burn ALL actions + 1 ammo
    vehicle.actionsUsed = getEffectiveMove(vehicle);
    vehicle.ammo = Math.max(0, vehicle.ammo - 1);
    
    // Prevent repeat use this deploy
    vehicle.rammed = true;
    
    // Find living non-env enemies
    const enemyFaction = vehicle.faction === 'outlaw' ? 'law' : 'outlaw';
    let enemies = G.field[enemyFaction].filter(c => c.hp > 0 && !c.isEnvironment);
    
    if (enemies.length === 0) {
        addToFeed(vehicle.faction, 'üöóüí•', `${vehicle.name} rams empty air!`, 'No targets', 'attack');
        updateUI();
        return;
    }
    
// Kill 1‚Äì3 random enemies (ignores everything)
const numKills = Math.floor(Math.random() * 3) + 1;
const killTargets = [];
for (let i = 0; i < numKills && enemies.length > 0; i++) {
    const idx = Math.floor(Math.random() * enemies.length);
    const target = enemies.splice(idx, 1)[0];
    killTargets.push(target.name);
    target.hp = 0;
    G.stats[vehicle.faction].kills++;
    G.scores[vehicle.faction]++;
    
    // NEW: Remove killed target from field immediately
    G.field[enemyFaction] = G.field[enemyFaction].filter(c => c.id !== target.id);
}
    
    // Cripple the V8 hard
    vehicle.suppressed *= 4;   // Quadruple current suppression
    vehicle.move -= 10;        // Negative move (can't move)
    vehicle.dodge = 10;        // Dodge tanked to 10%
    
    // 60% chance the vehicle destroys itself from the impact
    if (Math.random() < 0.60) {
        vehicle.hp = 0;
        addToFeed(vehicle.faction, 'üí•', `${vehicle.name} RAMS... but the crash destroys it!`, 'Vehicle wrecked', 'kill');
        
    // Passengers get hurt/shocked from the crash impact ‚Äî wide injury lottery
    if (vehicle.passengers && vehicle.passengers.length > 0) {
        const isWrecked = vehicle.hp <= 0;  // If vehicle already destroyed itself
        
        vehicle.passengers.forEach(passId => {
            const passenger = G.field[vehicle.faction].find(c => c.id === passId);
            if (!passenger) return;
            
            let injuryRoll = Math.random();
            if (isWrecked) injuryRoll += 0.25;  // Wreck makes everything 25% worse
            
            let outcome = '';
            let mpHit = 0;
            let hpLoss = 0;
            
            if (injuryRoll < 0.10) {  // 10% - Nothing (or 0% if wrecked)
                outcome = 'walks away unscathed';
            } else if (injuryRoll < 0.50) {  // 40% - Minor
                mpHit = -Math.floor(Math.random() * 4) - 2;  // -2 to -5 MP
                outcome = `minor injury (+${Math.abs(mpHit)} MP penalty)`;
            } else if (injuryRoll < 0.80) {  // 30% - Serious
                mpHit = -Math.floor(Math.random() * 8) - 8;  // -8 to -15 MP
                hpLoss = Math.floor(Math.random() * 2) + 1;   // -2 HP
                outcome = `serious injury (${hpLoss} HP, ${Math.abs(mpHit)} MP penalty)`;
            } else if (injuryRoll < 0.95) {  // 15% - Critical
                hpLoss = Math.floor(Math.random() * 6) + 5;   // -5 to -10 HP
                mpHit = -15;  // Max MP penalty
                outcome = `critical injury (${hpLoss} HP, -15 MP)`;
            } else {  // 5‚Äì10% - Instant death (higher if wrecked)
                hpLoss = passenger.hp;
                outcome = 'killed in the crash!';
                passenger.hp = 0;
                G.field[vehicle.faction] = G.field[vehicle.faction].filter(c => c.id !== passenger.id);
                G.scores[vehicle.faction === 'outlaw' ? 'law' : 'outlaw']++;
                G.stats[vehicle.faction === 'outlaw' ? 'law' : 'outlaw'].kills++;
            }
            
            passenger.suppressed += 2;  // Always dazed a bit
            if (mpHit !== 0) passenger.actionsUsed += Math.abs(mpHit);  // Apply MP penalty
            passenger.hp = Math.max(0, passenger.hp - hpLoss);
            
            addToFeed(vehicle.faction, 'ü©∏', `${passenger.name} ${outcome}`, 
                `${hpLoss > 0 ? `-${hpLoss} HP` : ''} ${mpHit < 0 ? `${mpHit} MP` : ''}`, 'debuff');
            
            // If passenger died
            if (passenger.hp <= 0 && outcome.includes('killed')) {
                addToFeed(vehicle.faction, '‚ò†Ô∏è', `${passenger.name} died in the crash!`, '', 'kill');
                checkVictory();
            }
        });
    }
        
        // Force disembark all passengers
        if (vehicle.passengers && vehicle.passengers.length > 0) {
            forceDisembarkAll(vehicle);
        }
        
        // Remove vehicle from field
        G.field[vehicle.faction] = G.field[vehicle.faction].filter(c => c.id !== vehicle.id);
        
        // Check if this ended the game
        checkVictory();
    }
    
    // Feed message
    addToFeed(vehicle.faction, 'üöóüí•', `${vehicle.name} RAMS through the line!`, 
        `Kills: ${killTargets.join(', ')}`, 'kill');
    
    // Temp alert so you see it worked (we'll replace with panel next)
    alert(`RAM SUCCESS!\nKilled: ${killTargets.join(', ')}\nV8 crippled: suppress √ó4, move -10, dodge 10%`);
    
    updateUI();
} 

// ============ FORCE TURN (Emergency Recovery) ============
function forceTurn() {
    if (!confirm('‚ö†Ô∏è EMERGENCY: Force skip to next turn?\n\nUse this only if the game is stuck/hanging.\nThis will close all panels and force the turn to end.')) {
        return;
    }
   
    // Close all possible panels
    hide('combatPanel');
    hide('eventPanel');
    hide('rallyPanel');
    hide('scavengePanel');
    hide('handModal');
   
    // Reset AI state
    G.aiThinking = false;
    G.aiWaitingResolve = null;
    G.aiWaitingPanel = null;
   
    // Reset action mode
    G.actionMode = null;
    G.selected = null;
   
    // Force switch turn
    G.turn = G.turn === 'outlaw' ? 'law' : 'outlaw';
   
    // Reset rally
    G.rallyUsedThisTurn = false;
   
    // Reset actions for new turn's cards
    G.field[G.turn].forEach(card => {
        card.actionsUsed = card.suppressed || 0;
        card.suppressed = 0;
        card.defending = false;
    });
   
    addEventToFeeds('‚ö†Ô∏è FORCE TURN', 'Turn manually forced by player');
    updateUI();
   
    // If it's now AI turn, trigger AI (with delay to ensure state is clean)
    if (G.aiEnabled && G.turn === G.aiFaction) {
        setTimeout(() => aiTakeTurn(), 500);
    }
}

// ============ AI SYSTEM ============
function aiTakeTurn() {
    if (!G.aiEnabled || G.turn !== G.aiFaction) return;
   
    G.aiThinking = true;
    log(`ü§ñ AI is thinking...`, G.aiFaction);
    updateUI();
   
    // AI turn sequence with delays for visual feedback
    aiDeployPhase().then(() => {
        return aiActionPhase();
    }).then(() => {
        G.aiThinking = false;
        endTurn(true); // Pass true to indicate AI is calling
    }).catch(err => {
        G.aiThinking = false;
        addEventToFeeds('‚ö†Ô∏è AI Error', 'AI encountered an error');
        endTurn(true);
    });
}

async function aiDeployPhase() {
    // Deploy cards based on difficulty
    const maxDeploy = G.aiDifficulty === 'easy' ? 2 : G.aiDifficulty === 'medium' ? 3 : 4;
    let deployed = 0;
    const deployedCards = [];
   
    // Sort hand by value (higher cost = better card usually)
    const sortedHand = [...G.hands[G.aiFaction]].sort((a, b) => b.cost - a.cost);
   
    for (const card of sortedHand) {
        if (deployed >= maxDeploy) break;
        if (G.field[G.aiFaction].length >= 6) break; // Max field size
       
        // Deploy the card
        const idx = G.hands[G.aiFaction].findIndex(c => c.id === card.id);
        if (idx !== -1) {
            const deployedCard = G.hands[G.aiFaction].splice(idx, 1)[0];
            deployedCard.actionsUsed = 0;
            G.field[G.aiFaction].push(deployedCard);
            deployedCards.push(deployedCard);
            log(`ü§ñ AI deploys ${deployedCard.name}`, G.aiFaction);
            deployed++;
            updateUI();
        }
    }
   
    // Show deployment summary if cards were deployed
    if (deployedCards.length > 0) {
        showAIDeployPanel(deployedCards);
        await waitForPanelDismiss('deployPanel');
    }
}

async function aiActionPhase() {
    const enemy = G.aiFaction === 'outlaw' ? 'law' : 'outlaw';
    
   
    // Process each card with actions remaining
    for (const card of G.field[G.aiFaction]) {
        // Skip environment cards
        if (card.isEnvironment) continue;
        const effectiveMove = getEffectiveMove(card);
        while (card.actionsUsed < effectiveMove) {
            // Check if any enemies exist
            if (G.field[enemy].length === 0) break;
           
            const action = aiDecideAction(card, enemy);
           
            if (action.type === 'attack') {
                await aiPerformAttack(card, action.target);
            } else if (action.type === 'suppress') {
                await aiPerformSuppress(card, action.target);
            async function aiPerformArrest(attacker, target) {
    if (attacker.actionsUsed + 2 > getEffectiveMove(attacker)) return;
    
    log(`ü§ñ AI: ${attacker.name} ARRESTS ${target.name}!`, G.aiFaction);
    
    performArrest(attacker, target);
    
    await waitForPanelDismiss('combatPanel');
}
            } else if (action.type === 'defend') {
                await aiPerformDefend(card);
            } else if (action.type === 'cover') {
                await aiPerformTakeCover(card);
            } else if (action.type === 'scavenge') {
                await aiPerformScavenge(card);
            } else if (action.type === 'share') {
                await aiPerformShare(card, action.target);
            } else {
                // No valid action, skip
                break;
            }
           
            // Small delay between actions
            await aiDelay(600);
           
            // Re-check if card is still alive/valid
            if (!G.field[G.aiFaction].find(c => c.id === card.id)) break;
        }
    }
   
    // Try to rally if needed and not used
    if (!G.rallyUsedThisTurn) {
        const rallyCandidate = G.field[G.aiFaction].find(c =>
            (c.actionsUsed >= getEffectiveMove(c) || (c.suppressed && c.suppressed > 0))
        );
        if (rallyCandidate && Math.random() < 0.5) { // 50% chance to attempt rally
            await aiAttemptRally(rallyCandidate);
        }
    }
}

function aiDecideAction(card, enemy) {
    const enemies = G.field[enemy];
    const allies = G.field[G.aiFaction];
    const effectiveMove = getEffectiveMove(card);
    
        // Vehicles cannot attack or suppress - only move
    if (card.isVehicle) {
        return { type: 'none' };
    }
   
    // Difficulty affects decision quality
    const makesMistakes = G.aiDifficulty === 'easy' && Math.random() < 0.3;
   
    // If low HP and not defending/in cover, consider defensive options
    const hpPercent = card.hp / card.maxHp;
    const notInCover = !card.coverTurns || card.coverTurns <= 0;
   
    if (hpPercent < 0.3 && !card.defending && notInCover && card.actionsUsed < effectiveMove) {
        if (G.aiDifficulty !== 'easy' || Math.random() < 0.5) {
            // Hard AI prefers Take Cover for longer protection when critically wounded
            if (G.aiDifficulty === 'hard' && hpPercent < 0.2) {
                return { type: 'cover' };
            }
            // Medium AI sometimes takes cover
            if (G.aiDifficulty === 'medium' && Math.random() < 0.4) {
                return { type: 'cover' };
            }
            return { type: 'defend' };
        }
    }
   
    // If out of ammo, scavenge or look for ally to share
    if (card.ammo <= 0) {
        return { type: 'scavenge' };
    }
   
    // AI Hide: Low HP retreat (Hard/Med only)
if ((G.aiDifficulty === 'hard' || G.aiDifficulty === 'medium') &&
    card.hp / card.maxHp < 0.4 &&
    getEffectiveMove(card) - (card.actionsUsed || 0) >= 2 &&
    Math.random() < 0.7) {
    return { type: 'hide' };
}
   
    // Consider sharing ammo with allies who are out (Medium/Hard AI)
    if (G.aiDifficulty !== 'easy' && card.ammo >= 3) {
        const needyAlly = allies.find(a => a.id !== card.id && a.ammo === 0 && a.fire >= 3);
        if (needyAlly && Math.random() < 0.4) {
            return { type: 'share', target: needyAlly };
        }
    }
   
    // Evaluate targets - with randomization to spread fire
    const targetScores = [];
   
    for (const target of enemies) {
        // Skip passengers in vehicles (cannot be targeted)
        if (target.inVehicle) continue;
        // Skip environment cards (forest, etc)
        if (target.isEnvironment) continue;
        
        let score = 0;
       
        // HEAVILY penalize targets in cover (almost pointless to shoot)
        if (target.coverTurns && target.coverTurns > 0) {
            score -= 80;
        }
       
        // Penalize defending targets
        if (target.defending) {
            score -= 20;
        }
       
        // Can we kill this target?
        const prediction = calculateAttackPrediction(card, target);
        if (prediction.netDmg >= target.hp) {
            score += 100; // High priority for kills
        }
       
        // Prioritize low HP targets (but not too heavily)
        score += (1 - target.hp / target.maxHp) * 20;
       
        // Prioritize high-value abilities (reduced weights)
        if (hasAbility(target, 'leader')) score += 25;
        if (hasAbility(target, 'medic')) score += 20;
        if (hasAbility(target, 'sniper')) score += 15;
        if (hasAbility(target, 'coordinator')) score += 20;
        if (hasAbility(target, 'sergeant')) score += 15;
       
        // Penalize high dodge targets
        score -= target.dodge * 0.3;
       
        // Hard AI considers more factors
        if (G.aiDifficulty === 'hard') {
            score += target.fire * 2;
            if (!target.defending && (!target.coverTurns || target.coverTurns <= 0)) score += 15;
        }
       
        // ADD RANDOMIZATION to spread fire around (all difficulties)
        // Easy: high randomization, Medium: moderate, Hard: low
        const randomFactor = G.aiDifficulty === 'easy' ? 60 : G.aiDifficulty === 'medium' ? 40 : 25;
        score += (Math.random() - 0.3) * randomFactor;
       
        targetScores.push({ target, score });
    }
   
    // Sort by score and pick from top candidates (not always the best)
    targetScores.sort((a, b) => b.score - a.score);
   
    let bestTarget = null;
    if (targetScores.length > 0) {
        // Sometimes pick 2nd or 3rd best target to spread damage
        if (targetScores.length >= 3 && Math.random() < 0.3) {
            bestTarget = targetScores[Math.floor(Math.random() * 3)].target;
        } else if (targetScores.length >= 2 && Math.random() < 0.4) {
            bestTarget = targetScores[Math.floor(Math.random() * 2)].target;
        } else {
            bestTarget = targetScores[0].target;
        }
    }
   
    // Decide between attack and suppress
    if (bestTarget) {
        // Strongly prefer NOT attacking covered targets
        if (bestTarget.coverTurns && bestTarget.coverTurns > 0) {
            // Look for uncovered target instead
            const uncoveredTarget = targetScores.find(t => !t.target.coverTurns || t.target.coverTurns <= 0);
            if (uncoveredTarget) {
                bestTarget = uncoveredTarget.target;
            } else if (Math.random() < 0.7) {
                // 70% chance to just skip attacking covered target
                if (card.ammo < card.maxAmmo) return { type: 'scavenge' };
                return { type: 'skip' };
            }
        }
       
        // Consider suppression for hard difficulty
        if (G.aiDifficulty === 'hard' && card.ammo >= 4) {
            if (bestTarget.move >= 3 && bestTarget.hp > bestTarget.maxHp * 0.5) {
                if (Math.random() < 0.3) {
                    return { type: 'suppress', target: bestTarget };
                }
            }
        }
       
        return { type: 'attack', target: bestTarget };
    }
    
    // Consider ARREST for high-value targets (ALL difficulties)
if (card.actionsUsed + 2 <= getEffectiveMove(card)) {
    if (bestTarget && !bestTarget.arrested && !bestTarget.abilities.includes('marksman')) {
        // Prioritize leaders, high fire, or random chance
        if (hasAbility(bestTarget, 'leader') || bestTarget.fire >= 4 || Math.random() < 0.4) {
            return { type: 'arrest', target: bestTarget };
        }
    }
}
   
    // Fallback: scavenge if nothing else
    if (card.ammo < card.maxAmmo) {
        return { type: 'scavenge' };
    }
   
    return { type: 'none' };
}

async function aiPerformAttack(attacker, target) {
    if (attacker.ammo <= 0) return;
    const effectiveMove = getEffectiveMove(attacker);
    if (attacker.actionsUsed >= effectiveMove) return;
   
    log(`ü§ñ AI: ${attacker.name} attacks ${target.name}`, G.aiFaction);
    performAttack(attacker, target);
   
    // No modal - just brief pause for readability
    await aiDelay(400);
}

async function aiPerformSuppress(attacker, target) {
    if (attacker.ammo <= 0) return;
    const effectiveMove = getEffectiveMove(attacker);
    if (attacker.actionsUsed >= effectiveMove) return;
   
    log(`ü§ñ AI: ${attacker.name} suppresses ${target.name}`, G.aiFaction);
    performSuppress(attacker, target);
   
    // Show a suppress result panel
    showSuppressPanel(attacker, target);
    await waitForPanelDismiss('suppressPanel');
}

async function aiPerformDefend(card) {
    const effectiveMove = getEffectiveMove(card);
    if (card.actionsUsed >= effectiveMove) return;
    if (card.defending) return;
   
    card.defending = true;
    card.actionsUsed = effectiveMove; // Use ALL remaining actions
    log(`ü§ñ AI: ${card.name} takes a defensive stance`, G.aiFaction);
   
    // Show defend notification
    showDefendPanel(card);
    await waitForPanelDismiss('defendPanel');
    updateUI();
}

async function aiPerformTakeCover(card) {
    const effectiveMove = getEffectiveMove(card);
    const actionsRemaining = effectiveMove - (card.actionsUsed || 0);
   
    // Need at least 2 actions
    if (actionsRemaining < 2) return;
    if (card.coverTurns && card.coverTurns > 0) return;
   
    // Apply cover - costs 2 actions
    card.actionsUsed = (card.actionsUsed || 0) + 2;
    card.coverTurns = 2;
    card.defending = true;
    card.hp = Math.min(card.maxHp, card.hp + 2);
   
    log(`ü§ñ AI: ${card.name} takes cover!`, G.aiFaction);
    addToFeed(G.aiFaction, 'ü™®', `${card.name} takes cover!`, '+2 HP, +DEF, costs 2 Move', 'defend');
   
    showCoverPanel(card);
    await waitForPanelDismiss('combatPanel');
    updateUI();
}

async function aiPerformScavenge(card) {
    const effectiveMove = getEffectiveMove(card);
    if (card.actionsUsed >= effectiveMove) return;
    if (card.ammo >= card.maxAmmo) return;
   
    G.selected = card;
    scavengeAmmo();
    G.selected = null;
   
    // Wait for player to dismiss the scavenge panel
    await waitForPanelDismiss('scavengePanel');
}

async function aiPerformShare(giver, receiver) {
    if (giver.ammo <= 1) return;
    if (receiver.ammo >= receiver.maxAmmo) return;
   
    log(`ü§ñ AI: ${giver.name} shares ammo with ${receiver.name}`, G.aiFaction);
    performShareAmmo(giver, receiver);
   
    // Wait for player to dismiss the share panel
    await waitForPanelDismiss('sharePanel');
    updateUI();
}

async function aiPerformHide(card) {
    G.selected = card;
    hideMember();
    await aiDelay(800); // Panel time
    updateUI();
}

// Promise-based wait for panel dismissal
function waitForPanelDismiss(panelId) {
    return new Promise(resolve => {
        G.aiWaitingResolve = resolve;
        G.aiWaitingPanel = panelId;
    });
}

// Call this when any AI-relevant panel is closed
function aiContinue() {
    if (G.aiWaitingResolve) {
        const resolve = G.aiWaitingResolve;
        G.aiWaitingResolve = null;
        G.aiWaitingPanel = null;
        resolve();
    }
}

function showSuppressPanel(attacker, target) {
    $('combatHeader').textContent = 'üíú SUPPRESSION! üíú';
   
    $('attackerPortrait').textContent = attacker.portrait;
    $('attackerName').textContent = attacker.name;
    $('attackerHP').textContent = `${attacker.hp}/${attacker.maxHp} HP`;
    $('attackerAmmo').textContent = `Ammo: ${attacker.ammo}/${attacker.maxAmmo}`;
    const attackerPct = (attacker.hp / attacker.maxHp) * 100;
    $('attackerHPBar').style.width = attackerPct + '%';
    $('attackerHPBar').className = 'combat-hp-fill ' + getHPClass(attackerPct);
   
    $('defenderPortrait').textContent = target.portrait;
    $('defenderName').textContent = target.name;
    $('defenderHP').textContent = `${target.hp}/${target.maxHp} HP`;
    $('defenderStatus').innerHTML = `<span style="color:#9b6bcc">SUPPRESSED -${attacker.supp}</span>`;
    const defenderPct = (target.hp / target.maxHp) * 100;
    $('defenderHPBar').style.width = defenderPct + '%';
    $('defenderHPBar').className = 'combat-hp-fill ' + getHPClass(defenderPct);
   
    $('combatDefender').style.display = '';
    $('combatVs').style.display = '';
   
    $('combatDamage').textContent = `-${attacker.supp} ACTIONS`;
    $('combatDamage').className = 'combat-damage blocked';
   
    const ammoCost = Math.ceil((attacker.ammo + Math.ceil(attacker.ammo / 2)) / 2); // Reverse calc
    $('combatEffects').innerHTML = `<span class="combat-effect debuff">Suppression: ${attacker.supp}</span>`;
    $('combatBreakdown').innerHTML = `
        <div class="combat-breakdown-title">Suppression Effect</div>
        <div class="combat-breakdown-row">
            <span>Attacker Supp Stat</span>
            <span>${attacker.supp}</span>
        </div>
        <div class="combat-breakdown-row sub">
            <span>Target Actions Next Turn</span>
            <span>-${attacker.supp}</span>
        </div>
        <div class="combat-breakdown-row result">
            <span>Effect</span>
            <span style="color:#9b6bcc">PINNED DOWN!</span>
        </div>
    `;
   
    // Use suppressPanel ID for tracking, but show in combat panel
    G.aiWaitingPanel = 'suppressPanel';
    show('combatPanel');
}

function showDefendPanel(card) {
    $('combatHeader').textContent = 'üõ°Ô∏è DEFENDING! üõ°Ô∏è';
   
    $('attackerPortrait').textContent = card.portrait;
    $('attackerName').textContent = card.name;
    $('attackerHP').textContent = `${card.hp}/${card.maxHp} HP`;
    $('attackerAmmo').textContent = `Ammo: ${card.ammo}/${card.maxAmmo}`;
    const pct = (card.hp / card.maxHp) * 100;
    $('attackerHPBar').style.width = pct + '%';
    $('attackerHPBar').className = 'combat-hp-fill ' + getHPClass(pct);
   
    $('combatDefender').style.display = 'none';
    $('combatVs').style.display = 'none';
   
    $('combatDamage').textContent = '50% REDUCTION';
    $('combatDamage').className = 'combat-damage blocked';
   
    $('combatEffects').innerHTML = `<span class="combat-effect buff">Defensive Stance</span>`;
    $('combatBreakdown').innerHTML = `
        <div class="combat-breakdown-title">Defend Action</div>
        <div class="combat-breakdown-row">
            <span>Damage Reduction</span>
            <span>50%</span>
        </div>
        <div class="combat-breakdown-row">
            <span>Duration</span>
            <span>Until next turn</span>
        </div>
        <div class="combat-breakdown-row result">
            <span>Status</span>
            <span style="color:#5bc0de">DEFENDING!</span>
        </div>
    `;
   
    G.aiWaitingPanel = 'defendPanel';
    show('combatPanel');
}

async function aiAttemptRally(card) {
    if (G.rallyUsedThisTurn) return;
   
    G.selected = card;
   
    // Calculate rally chance (simplified)
    const hpPercent = (card.hp / card.maxHp) * 100;
    const ammoPercent = (card.ammo / card.maxAmmo) * 100;
    const baseChance = 15;
    const hpBonus = (hpPercent / 100) * 45;
    const ammoBonus = (ammoPercent / 100) * 25;
    const chance = Math.floor(baseChance + hpBonus + ammoBonus);
   
    // AI only rallies if chance is decent
    if (chance >= 40 || G.aiDifficulty === 'hard') {
        log(`ü§ñ AI: ${card.name} attempts to rally!`, G.aiFaction);
       
        const roll = Math.random() * 100;
        const success = roll < chance;
        G.rallyUsedThisTurn = true;
       
        const isSuppressed = card.suppressed && card.suppressed > 0;
       
        if (success) {
            if (isSuppressed) {
                G.field[G.aiFaction].forEach(c => {
                    if (c.suppressed) {
                        c.actionsUsed = Math.max(0, c.actionsUsed - c.suppressed);
                        c.suppressed = 0;
                    }
                });
                log(`ü§ñ ${card.name} rallies the team! All suppression cleared!`, G.aiFaction);
            } else {
                const hpPct = card.hp / card.maxHp;
                const actionsRestored = hpPct >= 0.5 ? 2 : 1;
                card.actionsUsed = Math.max(0, card.actionsUsed - actionsRestored);
                log(`ü§ñ ${card.name} rallies! Restored ${actionsRestored} action(s)!`, G.aiFaction);
            }
        } else {
            log(`ü§ñ ${card.name} failed to rally! (${Math.floor(roll)} vs ${chance}%)`, G.aiFaction);
        }
       
        // Show rally result panel
        showAIRallyPanel(card, success, Math.floor(roll), chance, isSuppressed);
        await waitForPanelDismiss('rallyPanel');
       
        updateUI();
    }
   
    G.selected = null;
}

function showAIRallyPanel(card, success, roll, chance, isSuppressed) {
    const rallyTypeText = isSuppressed ? '(Team Rally)' : '(Self Rally)';
    $('rallyCard').innerHTML = `
        <div style="font-size:2em">${card.portrait}</div>
        <div style="font-weight:bold;color:var(--gold)">ü§ñ ${card.name}</div>
        <div style="font-size:.75em;color:#aaa;margin-top:4px">${rallyTypeText}</div>
    `;
    $('rallyChance').textContent = chance + '%';
    $('rallyFill').style.width = chance + '%';
   
    $('rallyResult').textContent = success ? 'üî• RALLY SUCCESS! üî•' : 'üí® RALLY FAILED';
    $('rallyResult').className = 'rally-result ' + (success ? 'success' : 'fail');
    $('rallyResult').classList.remove('hidden');
   
    $('rallyDetails').innerHTML = `Rolled: ${roll} (needed < ${chance})`;
   
    // Hide roll and cancel, show continue
    $('rallyBtn').classList.add('hidden');
    $('rallyCancelBtn').classList.add('hidden');
    $('rallyContinueBtn').classList.remove('hidden');
   
    show('rallyPanel');
}

function closeRally() {
    hide('rallyPanel');
   
    // If AI is waiting for this panel, continue
    if (G.aiWaitingPanel === 'rallyPanel') {
        aiContinue();
    }
}

function showAIDeployPanel(cards) {
    const factionName = G.aiFaction === 'outlaw' ? 'OUTLAW GANG' : 'THE LAW';
    const factionColor = G.aiFaction === 'outlaw' ? '#f87171' : '#60a5fa';
   
    $('combatHeader').textContent = `ü§ñ AI DEPLOYS ${cards.length} CARD${cards.length > 1 ? 'S' : ''}`;
   
    // Show first deployed card in attacker slot
    const mainCard = cards[0];
    $('attackerPortrait').textContent = mainCard.portrait;
    $('attackerName').textContent = mainCard.name;
    $('attackerHP').textContent = `${mainCard.hp}/${mainCard.maxHp} HP`;
    $('attackerAmmo').textContent = `Ammo: ${mainCard.ammo}/${mainCard.maxAmmo}`;
    const pct = (mainCard.hp / mainCard.maxHp) * 100;
    $('attackerHPBar').style.width = pct + '%';
    $('attackerHPBar').className = 'combat-hp-fill ' + getHPClass(pct);
   
    $('combatDefender').style.display = 'none';
    $('combatVs').style.display = 'none';
   
    $('combatDamage').textContent = `${factionName}`;
    $('combatDamage').className = 'combat-damage';
    $('combatDamage').style.color = factionColor;
   
    $('combatEffects').innerHTML = cards.map(c =>
        `<span class="combat-effect buff">${c.portrait} ${c.name}</span>`
    ).join('');
   
    $('combatBreakdown').innerHTML = `
        <div class="combat-breakdown-title">Deployed Cards</div>
        ${cards.map(c => `
            <div class="combat-breakdown-row">
                <span>${c.portrait} ${c.name}</span>
                <span style="color:#aaa">HP:${c.hp} Fire:${c.fire}</span>
            </div>
        `).join('')}
        <div class="combat-breakdown-row result" style="margin-top:8px">
            <span>Total Deployed</span>
            <span style="color:${factionColor}">${cards.length}</span>
        </div>
    `;
   
    G.aiWaitingPanel = 'deployPanel';
    show('combatPanel');
}

function aiDelay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function triggerRandomEvent() {
    const event = G.events[Math.floor(Math.random() * G.events.length)];
    const results = applyEvent(event);
    showEventPanel(event, results);
    addEventToFeeds(event.name, event.desc);
}

function applyEvent(event) {
    const results = [];
    let targets = [];
   
    // Get initial target pool based on faction
    if (event.faction === 'both') {
        targets.push(...G.field.outlaw, ...G.field.law);
    } else {
        targets.push(...G.field[event.faction]);
    }
   
    // Filter targets based on targetCount (for custom events)
    if (event.targetCount && event.targetCount !== 'all' && targets.length > 0) {
        switch (event.targetCount) {
            case 'random_one':
                targets = [targets[Math.floor(Math.random() * targets.length)]];
                break;
            case 'random_two':
                const shuffled2 = [...targets];
                shuffle(shuffled2);
                targets = shuffled2.slice(0, 2);
                break;
            case 'random_three':
                const shuffled3 = [...targets];
                shuffle(shuffled3);
                targets = shuffled3.slice(0, 3);
                break;
            case 'lowest_hp':
                targets = [targets.reduce((min, c) => c.hp < min.hp ? c : min, targets[0])];
                break;
            case 'highest_hp':
                targets = [targets.reduce((max, c) => c.hp > max.hp ? c : max, targets[0])];
                break;
            case 'lowest_ammo':
                targets = [targets.reduce((min, c) => c.ammo < min.ammo ? c : min, targets[0])];
                break;
            case 'highest_ammo':
                targets = [targets.reduce((max, c) => c.ammo > max.ammo ? c : max, targets[0])];
                break;
        }
    }
   
    switch (event.type) {
        case 'damage_all':
        case 'damage_faction':
            targets.forEach(c => {
                const oldHp = c.hp;
                c.hp = Math.max(1, c.hp - event.value);
                results.push({ card: c, type: 'damage', value: oldHp - c.hp, oldVal: oldHp, newVal: c.hp });
            });
            break;
        case 'heal_all':
        case 'heal_faction':
            targets.forEach(c => {
                const oldHp = c.hp;
                c.hp = Math.min(c.maxHp, c.hp + event.value);
                results.push({ card: c, type: 'heal', value: c.hp - oldHp, oldVal: oldHp, newVal: c.hp });
            });
            break;
        case 'damage_lowest_hp':
            if (targets.length > 0) {
                const victim = targets.reduce((min, c) => c.hp < min.hp ? c : min, targets[0]);
                const oldHp = victim.hp;
                victim.hp = Math.max(0, victim.hp - event.value);
                results.push({ card: victim, type: 'damage', value: oldHp - victim.hp, oldVal: oldHp, newVal: victim.hp });
            }
            break;
        case 'damage_highest_hp':
            if (targets.length > 0) {
                const victim = targets.reduce((max, c) => c.hp > max.hp ? c : max, targets[0]);
                const oldHp = victim.hp;
                victim.hp = Math.max(0, victim.hp - event.value);
                results.push({ card: victim, type: 'damage', value: oldHp - victim.hp, oldVal: oldHp, newVal: victim.hp });
            }
            break;
        case 'heal_lowest_hp':
            if (targets.length > 0) {
                const target = targets.reduce((min, c) => c.hp < min.hp ? c : min, targets[0]);
                const oldHp = target.hp;
                target.hp = Math.min(target.maxHp, target.hp + event.value);
                results.push({ card: target, type: 'heal', value: target.hp - oldHp, oldVal: oldHp, newVal: target.hp });
            }
            break;
        case 'full_heal_one':
            if (targets.length > 0) {
                const target = targets[Math.floor(Math.random() * targets.length)];
                const oldHp = target.hp;
                target.hp = target.maxHp;
                results.push({ card: target, type: 'heal', value: target.hp - oldHp, oldVal: oldHp, newVal: target.hp });
            }
            break;
        case 'execute_wounded':
            // Kill any card with HP <= value threshold
            targets.forEach(c => {
                if (c.hp <= event.value && c.hp > 0) {
                    const oldHp = c.hp;
                    c.hp = 0;
                    results.push({ card: c, type: 'kill', value: oldHp, oldVal: oldHp, newVal: 0 });
                }
            });
            break;
        case 'ammo':
            targets.forEach(c => {
                const oldAmmo = c.ammo;
                c.ammo = Math.max(0, Math.min(c.maxAmmo, c.ammo + event.value));
                results.push({ card: c, type: 'ammo', value: c.ammo - oldAmmo, oldVal: oldAmmo, newVal: c.ammo });
            });
            break;
case 'drain_ammo':

    if (event.duration > 0) {
        G.activeEvents.push({
            name: event.name || 'Ammo Drain',
            stat: 'drain_ammo',
            value: event.value,
            faction: event.faction,
            turnsLeft: event.duration * 2
        });
    } else {
        targets.forEach(c => {
            const oldAmmo = c.ammo;
            c.ammo = Math.max(0, c.ammo - event.value);
            results.push({ card: c, type: 'ammo', value: c.ammo - oldAmmo, oldVal: oldAmmo, newVal: c.ammo });
        });
    }
    break;
        case 'stat_mod':
        case 'dodge_mod':
            if (event.duration > 0) {
                G.activeEvents.push({
                    name: event.name,
                    stat: event.stat || 'fire',
                    value: event.value,
                    faction: event.faction,
                    turnsLeft: event.duration * 2
                });
                targets.forEach(c => {
                    results.push({ card: c, type: 'stat', stat: event.stat || 'fire', value: event.value, duration: event.duration });
                });
            }
            break;
        case 'suppress_all':
        case 'suppress_faction':
            targets.forEach(c => {
                const oldSupp = c.suppressed || 0;
                c.suppressed = (c.suppressed || 0) + event.value;
                results.push({ card: c, type: 'suppress', value: event.value, oldVal: oldSupp, newVal: c.suppressed });
            });
            break;
        case 'clear_suppress':
            targets.forEach(c => {
                const oldSupp = c.suppressed || 0;
                if (oldSupp > 0) {
                    c.suppressed = 0;
                    // Also restore actions that were lost to suppression
                    c.actionsUsed = Math.max(0, c.actionsUsed - oldSupp);
                    results.push({ card: c, type: 'clear_suppress', value: oldSupp, oldVal: oldSupp, newVal: 0 });
                }
            });
            break;
        case 'restore_actions':
            targets.forEach(c => {
                const oldActions = c.actionsUsed || 0;
                const restored = Math.min(event.value, oldActions);
                c.actionsUsed = Math.max(0, c.actionsUsed - event.value);
                results.push({ card: c, type: 'restore_actions', value: restored, oldVal: c.move - oldActions, newVal: c.move - c.actionsUsed });
            });
            break;
        case 'random_kill':
            if (targets.length > 0) {
                const victim = targets[Math.floor(Math.random() * targets.length)];
                const oldHp = victim.hp;
                victim.hp = 0;
                results.push({ card: victim, type: 'kill', value: oldHp, oldVal: oldHp, newVal: 0 });
            }
            break;
        case 'swap_stats':
            // Swap a stat between factions (e.g., swap all fire values)
            const stat = event.stat || 'fire';
            const outlawCards = G.field.outlaw;
            const lawCards = G.field.law;
            if (outlawCards.length > 0 && lawCards.length > 0) {
                // Calculate average stat for each faction
                const outlawAvg = Math.round(outlawCards.reduce((sum, c) => sum + c[stat], 0) / outlawCards.length);
                const lawAvg = Math.round(lawCards.reduce((sum, c) => sum + c[stat], 0) / lawCards.length);
               
                // Apply swap - outlaws get law's average, law gets outlaw's average
                outlawCards.forEach(c => {
                    const oldVal = c[stat];
                    c[stat] = lawAvg;
                    results.push({ card: c, type: 'swap', stat: stat, value: lawAvg - oldVal, oldVal: oldVal, newVal: lawAvg });
                });
                lawCards.forEach(c => {
                    const oldVal = c[stat];
                    c[stat] = outlawAvg;
                    results.push({ card: c, type: 'swap', stat: stat, value: outlawAvg - oldVal, oldVal: oldVal, newVal: outlawAvg });
                });
            }
            break;
        case 'equalizer':
            // Set all cards to the average HP
            if (targets.length > 0) {
                const avgHp = Math.round(targets.reduce((sum, c) => sum + c.hp, 0) / targets.length);
                targets.forEach(c => {
                    const oldHp = c.hp;
                    c.hp = Math.min(c.maxHp, avgHp);
                    const change = c.hp - oldHp;
                    results.push({ card: c, type: change >= 0 ? 'heal' : 'damage', value: Math.abs(change), oldVal: oldHp, newVal: c.hp });
                });
            }
            break;
        case 'shuffle_hp':
            // Shuffle HP values among all targets
            if (targets.length > 1) {
                const hpValues = targets.map(c => c.hp);
                // Fisher-Yates shuffle
                for (let i = hpValues.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [hpValues[i], hpValues[j]] = [hpValues[j], hpValues[i]];
                }
                targets.forEach((c, i) => {
                    const oldHp = c.hp;
                    c.hp = Math.min(c.maxHp, hpValues[i]);
                    const change = c.hp - oldHp;
                    results.push({ card: c, type: 'shuffle', value: change, oldVal: oldHp, newVal: c.hp });
                });
            }
            break;
        case 'buff_random':
            // Give a random buff to one random card
            if (targets.length > 0) {
                const target = targets[Math.floor(Math.random() * targets.length)];
                const buffs = ['heal', 'ammo', 'actions'];
                const buff = buffs[Math.floor(Math.random() * buffs.length)];
               
                if (buff === 'heal') {
                    const oldHp = target.hp;
                    const healAmt = Math.floor(Math.random() * 4) + 2; // 2-5 heal
                    target.hp = Math.min(target.maxHp, target.hp + healAmt);
                    results.push({ card: target, type: 'heal', value: target.hp - oldHp, oldVal: oldHp, newVal: target.hp });
                } else if (buff === 'ammo') {
                    const oldAmmo = target.ammo;
                    const ammoAmt = Math.floor(Math.random() * 3) + 2; // 2-4 ammo
                    target.ammo = Math.min(target.maxAmmo, target.ammo + ammoAmt);
                    results.push({ card: target, type: 'ammo', value: target.ammo - oldAmmo, oldVal: oldAmmo, newVal: target.ammo });
                } else {
                    const oldActions = target.actionsUsed || 0;
                    target.actionsUsed = 0; // Full action restore
                    results.push({ card: target, type: 'restore_actions', value: oldActions, oldVal: target.move - oldActions, newVal: target.move });
                }
            }
            break;
           
        // === NEW EVENT TYPES ===
        case 'steal_hp':
            // Steal HP from random enemy, give to random ally of opposite faction
            const allCards = [...G.field.outlaw, ...G.field.law];
            if (G.field.outlaw.length > 0 && G.field.law.length > 0) {
                const victim = allCards[Math.floor(Math.random() * allCards.length)];
                const victimFaction = victim.faction;
                const beneficiaries = victimFaction === 'outlaw' ? G.field.law : G.field.outlaw;
                const beneficiary = beneficiaries[Math.floor(Math.random() * beneficiaries.length)];
               
                const stealAmt = Math.min(event.value || 3, victim.hp - 1);
                if (stealAmt > 0) {
                    victim.hp -= stealAmt;
                    const oldBeneficiaryHp = beneficiary.hp;
                    beneficiary.hp = Math.min(beneficiary.maxHp, beneficiary.hp + stealAmt);
                    results.push({ card: victim, type: 'damage', value: stealAmt, oldVal: victim.hp + stealAmt, newVal: victim.hp });
                    results.push({ card: beneficiary, type: 'heal', value: beneficiary.hp - oldBeneficiaryHp, oldVal: oldBeneficiaryHp, newVal: beneficiary.hp });
                }
            }
            break;
           
        case 'glass_cannon':
            // Double fire, halve HP for targets
            targets.forEach(c => {
                const oldHp = c.hp;
                const oldFire = c.fire;
                c.fire = Math.min(15, c.fire * 2);
                c.hp = Math.max(1, Math.floor(c.hp / 2));
                results.push({ card: c, type: 'glass_cannon', oldHp: oldHp, newHp: c.hp, oldFire: oldFire, newFire: c.fire });
            });
            break;
           
        case 'fortify':
            // Halve fire, heal HP significantly
            targets.forEach(c => {
                const oldHp = c.hp;
                const oldFire = c.fire;
                c.fire = Math.max(1, Math.floor(c.fire / 2));
                c.hp = Math.min(c.maxHp, c.hp + Math.floor(c.maxHp / 2));
                results.push({ card: c, type: 'fortify', oldHp: oldHp, newHp: c.hp, oldFire: oldFire, newFire: c.fire });
            });
            break;
           
        case 'shield_all':
            // Grant defending status to all targets
            if (event.duration > 0) {
                // Add as persistent effect with duration tracking
                G.activeEvents.push({
                    name: event.name || 'Shield All',
                    stat: 'defending',
                    value: 1,
                    faction: event.faction,
                    turnsLeft: event.duration * 2  // Convert rounds to turns
                });
            }
            // Apply immediate defending status
            targets.forEach(c => {
                if (!c.defending) {
                    c.defending = true;
                    results.push({ card: c, type: 'shield', value: 1, oldVal: 0, newVal: 1 });
                }
            });
            break;
           
        case 'disarm':
            // Set ammo to 0 for all targets
            targets.forEach(c => {
                const oldAmmo = c.ammo;
                c.ammo = 0;
                results.push({ card: c, type: 'ammo', value: -oldAmmo, oldVal: oldAmmo, newVal: 0 });
            });
            break;
           
        case 'max_ammo':
            // Fill all ammo to max
            if (event.duration > 0) {
                // Create persistent max ammo effect
                G.activeEvents.push({
                    name: event.name,
                    stat: 'max_ammo',
                    value: 1,
                    faction: event.faction,
                    turnsLeft: event.duration  // Already in turns, not rounds
                });
            }
            // Apply immediate ammo refill
            targets.forEach(c => {
                const oldAmmo = c.ammo;
                c.ammo = c.maxAmmo;
                results.push({ card: c, type: 'ammo', value: c.ammo - oldAmmo, oldVal: oldAmmo, newVal: c.ammo });
            });
            break;
           
        case 'time_warp':
            // Reset all actions used (full refresh)
            targets.forEach(c => {
                const oldActions = c.actionsUsed || 0;
                c.actionsUsed = 0;
                c.suppressed = 0;
                results.push({ card: c, type: 'time_warp', value: oldActions, oldVal: c.move - oldActions, newVal: c.move });
            });
            break;
           
        case 'sudden_death':
            // Set all cards to 1 HP - extremely dangerous!
            targets.forEach(c => {
                const oldHp = c.hp;
                c.hp = 1;
                results.push({ card: c, type: 'sudden_death', value: oldHp - 1, oldVal: oldHp, newVal: 1 });
            });
            break;
           
        case 'coin_flip':
            // 50/50 chance of big heal or big damage for each card
            targets.forEach(c => {
                const isLucky = Math.random() < 0.5;
                const amount = event.value || 4;
                if (isLucky) {
                    const oldHp = c.hp;
                    c.hp = Math.min(c.maxHp, c.hp + amount);
                    results.push({ card: c, type: 'heal', value: c.hp - oldHp, oldVal: oldHp, newVal: c.hp });
                } else {
                    const oldHp = c.hp;
                    c.hp = Math.max(0, c.hp - amount);
                    results.push({ card: c, type: 'damage', value: oldHp - c.hp, oldVal: oldHp, newVal: c.hp });
                }
            });
            break;
           
        case 'last_stand':
            // Cards below 50% HP get fire bonus
            targets.forEach(c => {
                const hpPercent = c.hp / c.maxHp;
                if (hpPercent <= 0.5) {
                    const bonus = hpPercent <= 0.25 ? 3 : 2;
                    const oldFire = c.fire;
                    c.fire += bonus;
                    results.push({ card: c, type: 'last_stand', value: bonus, oldVal: oldFire, newVal: c.fire });
                }
            });
            break;
           
        case 'momentum_shift':
            // Help the team with fewer cards / lower total HP
            const outlawTotalHp = G.field.outlaw.reduce((sum, c) => sum + c.hp, 0);
            const lawTotalHp = G.field.law.reduce((sum, c) => sum + c.hp, 0);
            const losingFaction = outlawTotalHp < lawTotalHp ? 'outlaw' : 'law';
            const losers = G.field[losingFaction];
            losers.forEach(c => {
                const oldHp = c.hp;
                c.hp = Math.min(c.maxHp, c.hp + 3);
                const oldAmmo = c.ammo;
                c.ammo = Math.min(c.maxAmmo, c.ammo + 2);
                results.push({ card: c, type: 'momentum', value: (c.hp - oldHp) + (c.ammo - oldAmmo), oldVal: oldHp, newVal: c.hp });
            });
            break;
           
        case 'vampire_wave':
            // Damage all, but one random card heals for total damage dealt
            if (targets.length > 0) {
                let totalDamage = 0;
                const damageAmt = event.value || 2;
                targets.forEach(c => {
                    const oldHp = c.hp;
                    c.hp = Math.max(1, c.hp - damageAmt);
                    totalDamage += oldHp - c.hp;
                    results.push({ card: c, type: 'damage', value: oldHp - c.hp, oldVal: oldHp, newVal: c.hp });
                });
                // One random card gets all that HP
                const vampire = targets[Math.floor(Math.random() * targets.length)];
                const oldVampHp = vampire.hp;
                vampire.hp = Math.min(vampire.maxHp, vampire.hp + totalDamage);
                results.push({ card: vampire, type: 'heal', value: vampire.hp - oldVampHp, oldVal: oldVampHp, newVal: vampire.hp });
            }
            break;
           
        case 'sacrifice':
            // Kill lowest HP card of a faction, buff the rest
            if (targets.length > 1) {
                const sacrifice = targets.reduce((min, c) => c.hp < min.hp ? c : min, targets[0]);
                const oldHp = sacrifice.hp;
                sacrifice.hp = 0;
                results.push({ card: sacrifice, type: 'kill', value: oldHp, oldVal: oldHp, newVal: 0 });
               
                // Buff survivors
                targets.filter(c => c.id !== sacrifice.id).forEach(c => {
                    const oldCardHp = c.hp;
                    c.hp = Math.min(c.maxHp, c.hp + 3);
                    c.fire += 1;
                    results.push({ card: c, type: 'sacrifice_buff', value: 1, oldVal: oldCardHp, newVal: c.hp });
                });
            }
            break;
           
        case 'mirror_match':
            // Set all cards to have the same fire and dodge (average of all)
            if (targets.length > 0) {
                const avgFire = Math.round(targets.reduce((sum, c) => sum + c.fire, 0) / targets.length);
                const avgDodge = Math.round(targets.reduce((sum, c) => sum + c.dodge, 0) / targets.length);
                targets.forEach(c => {
                    const oldFire = c.fire;
                    const oldDodge = c.dodge;
                    c.fire = avgFire;
                    c.dodge = avgDodge;
                    results.push({ card: c, type: 'mirror', oldFire: oldFire, newFire: avgFire, oldDodge: oldDodge, newDodge: avgDodge });
                });
            }
            break;
           
        case 'chain_lightning':
            // Damage decreases with each target hit
            if (targets.length > 0) {
                const shuffled = [...targets].sort(() => Math.random() - 0.5);
                let damage = event.value || 5;
                shuffled.forEach(c => {
                    if (damage > 0) {
                        const oldHp = c.hp;
                        c.hp = Math.max(0, c.hp - damage);
                        results.push({ card: c, type: 'damage', value: oldHp - c.hp, oldVal: oldHp, newVal: c.hp });
                        damage = Math.max(0, damage - 1); // Decrease damage for next target
                    }
                });
            }
            break;
           
        case 'poison_cloud':
            // Add a poison effect that damages over time
            G.activeEvents.push({
                name: event.name || 'Poison Cloud',
                stat: 'poison',
                value: event.value || 1,
                faction: event.faction,
                turnsLeft: 4 // 2 rounds
            });
            targets.forEach(c => {
                results.push({ card: c, type: 'poison', value: event.value || 1, oldVal: 0, newVal: event.value || 1 });
            });
            break;
           
            case 'gutshot':
            // Apply bleeding status to target cards
            targets.forEach(c => {
                if (!c.bleeding) {
                    c.bleeding = true;
                    results.push({ card: c, type: 'bleeding', value: 1, oldVal: 0, newVal: 1 });
                }
            });
            break;
           
                    case 'grant_vest':
            // Give bulletproof vest ability to targets
            targets.forEach(c => {
                if (!c.abilities.includes('bulletproof')) {
                    c.abilities.push('bulletproof');
                    c.vestDurability = 3;
                    results.push({ card: c, type: 'vest', value: 1, oldVal: 0, newVal: 1 });
                }
            });
            break;
           
                    case 'spawn_card':
            // Spawn a random custom card for the faction
            const customCards = G.allCards[event.faction].filter(c => c.id.startsWith('custom_'));
            if (customCards.length > 0) {
                const randomCard = customCards[Math.floor(Math.random() * customCards.length)];
                // Clone the card with a unique ID
                const newCard = JSON.parse(JSON.stringify(randomCard));
                newCard.id = `${newCard.id}_${Date.now()}`;
                newCard.hp = newCard.maxHp;
                newCard.ammo = newCard.maxAmmo;
                newCard.actionsUsed = 0;
                newCard.suppressed = 0;
                newCard.defending = false;
               
                // Add to hand
                G.hands[event.faction].push(newCard);
               
                results.push({
                    card: newCard,
                    type: 'spawn',
                    value: 1,
                    oldVal: 0,
                    newVal: 1
                });
               
                addToFeed(event.faction, 'üéñÔ∏è', `${newCard.name} arrives as reinforcement!`, `${newCard.portrait} HP: ${newCard.hp}`, 'deploy');
            } else {
                // No custom cards available - spawn a default trooper instead
                const defaultCard = event.faction === 'outlaw'
                    ? { name: 'Outlaw Recruit', portrait: 'ü§†', hp: 8, maxHp: 8, fire: 3, move: 2, supp: 1, dodge: 15, ammo: 5, maxAmmo: 5, cost: 0, faction: 'outlaw', abilities: [] }
                    : { name: 'Deputy', portrait: 'üëÆ', hp: 8, maxHp: 8, fire: 3, move: 2, supp: 1, dodge: 15, ammo: 5, maxAmmo: 5, cost: 0, faction: 'law', abilities: [] };
               
                defaultCard.id = `recruit_${Date.now()}`;
                defaultCard.actionsUsed = 0;
                defaultCard.suppressed = 0;
                defaultCard.defending = false;
               
                G.hands[event.faction].push(defaultCard);
               
                results.push({
                    card: defaultCard,
                    type: 'spawn',
                    value: 1,
                    oldVal: 0,
                    newVal: 1
                });
               
                addToFeed(event.faction, 'üéñÔ∏è', `${defaultCard.name} arrives as reinforcement!`, `${defaultCard.portrait} HP: ${defaultCard.hp}`, 'deploy');
            }
            break;
           
                    case 'fortified':
            // Building cover - massive defensive bonuses
            if (event.duration > 0) {
                // Add dodge boost
                G.activeEvents.push({
                    name: event.name + ' (Dodge)',
                    stat: 'dodge',
                    value: 40,  // +40% dodge
                    faction: event.faction,
                    turnsLeft: event.duration * 2
                });
                // Add damage reduction
                G.activeEvents.push({
                    name: event.name + ' (Protection)',
                    stat: 'damage_reduction',
                    value: 30,  // -30% damage taken
                    faction: event.faction,
                    turnsLeft: event.duration * 2
                });
                // Reduce movement (can't leave building easily)
                G.activeEvents.push({
                    name: event.name + ' (Pinned)',
                    stat: 'move',
                    value: -1,  // -1 movement
                    faction: event.faction,
                    turnsLeft: event.duration * 2
                });
            }
            // Set fortified status on cards for badge display
            targets.forEach(c => {
                c.fortified = event.duration * 2;  // Convert rounds to turns
                c.coverTurns = event.duration * 2;  // Also grant Take Cover protection
                results.push({ card: c, type: 'fortified', value: 40, oldVal: 0, newVal: 40 });
            });
            break;
           
        case 'ammo_explosion':
            // Each card takes damage equal to their current ammo, then loses all ammo
            targets.forEach(c => {
                const damage = c.ammo;
                const oldHp = c.hp;
                const oldAmmo = c.ammo;
                c.hp = Math.max(0, c.hp - damage);
                c.ammo = 0;
                results.push({ card: c, type: 'explosion', damage: damage, oldHp: oldHp, newHp: c.hp, oldAmmo: oldAmmo });
            });
            break;
    }
   
    // Track damage and healing stats from event results
    results.forEach(r => {
        if (r.type === 'damage' || r.type === 'sudden_death' || r.type === 'explosion') {
            const dmgValue = r.value || r.damage || 0;
            if (dmgValue > 0) {
                G.stats[r.card.faction].dmgTaken += dmgValue;
            }
        } else if (r.type === 'heal') {
            // Healing doesn't track in nerd stats currently, but we could add it
        }
    });
   
    // Check for deaths
    ['outlaw', 'law'].forEach(faction => {
        G.field[faction] = G.field[faction].filter(c => {
            if (c.hp <= 0) {
                const enemy = faction === 'outlaw' ? 'law' : 'outlaw';
                G.scores[enemy]++;
                G.stats[enemy].kills++;
                addToFeed(faction, '‚ò†Ô∏è', `${c.name} eliminated by event!`, '', 'kill');
                return false;
            }
            return true;
        });
    });
   
    updateUI();
   
    // Check victory after event processing (delayed to allow UI update)
    setTimeout(() => checkVictory(), 100);
   
    return results;
}

function showEventPanel(event, results) {
    clearCombatPrediction(); // Clear tooltip immediately
   
    $('combatHeader').textContent = 'üé≤ RANDOM EVENT! üé≤';
    $('eventPanelDesc').textContent = event.desc;

let affectedHTML = '';
if (results.length === 0) {
    affectedHTML = '<div class="affected-card"><span class="name">No units on field</span></div>';
} else {
        results.forEach(r => {
            let changeText = '';
            let changeClass = 'neutral';
           
            switch (r.type) {
                case 'damage':
                    changeText = `-${r.value} HP (${r.oldVal}‚Üí${r.newVal})`;
                    changeClass = 'negative';
                    break;
                case 'heal':
                    changeText = `+${r.value} HP (${r.oldVal}‚Üí${r.newVal})`;
                    changeClass = 'positive';
                    break;
                case 'ammo':
                    changeText = `${r.value >= 0 ? '+' : ''}${r.value} Ammo (${r.oldVal}‚Üí${r.newVal})`;
                    changeClass = r.value >= 0 ? 'positive' : 'negative';
                    break;
                case 'stat':
                    changeText = `${r.value >= 0 ? '+' : ''}${r.value} ${r.stat} (${r.duration} turns)`;
                    changeClass = r.value >= 0 ? 'positive' : 'negative';
                    break;
                case 'suppress':
                    changeText = `+${r.value} Suppression`;
                    changeClass = 'negative';
                    break;
                case 'clear_suppress':
                    changeText = `Suppression cleared! (-${r.value})`;
                    changeClass = 'positive';
                    break;
                case 'restore_actions':
                    changeText = `+${r.value} Actions restored`;
                    changeClass = 'positive';
                    break;
                case 'kill':
                    changeText = `üíÄ KILLED!`;
                    changeClass = 'negative';
                    break;
                case 'swap':
                    changeText = `${r.stat}: ${r.oldVal}‚Üí${r.newVal}`;
                    changeClass = r.value >= 0 ? 'positive' : 'negative';
                    break;
                case 'shuffle':
                    changeText = `HP: ${r.oldVal}‚Üí${r.newVal}`;
                    changeClass = r.value >= 0 ? 'positive' : 'negative';
                    break;
                case 'glass_cannon':
                    changeText = `üî• Fire: ${r.oldFire}‚Üí${r.newFire}, üíî HP: ${r.oldHp}‚Üí${r.newHp}`;
                    changeClass = 'neutral';
                    break;
                case 'fortify':
                    changeText = `üõ°Ô∏è HP: ${r.oldHp}‚Üí${r.newHp}, Fire: ${r.oldFire}‚Üí${r.newFire}`;
                    changeClass = 'neutral';
                    break;
                case 'shield':
                    changeText = `üõ°Ô∏è DEFENDING!`;
                    changeClass = 'positive';
                    break;
                case 'time_warp':
                    changeText = `‚è∞ Actions Reset! (+${r.value})`;
                    changeClass = 'positive';
                    break;
                case 'sudden_death':
                    changeText = `üíÄ HP ‚Üí 1 (-${r.value})`;
                    changeClass = 'negative';
                    break;
                case 'last_stand':
                    changeText = `üî• Last Stand! +${r.value} Fire`;
                    changeClass = 'positive';
                    break;
                case 'momentum':
                    changeText = `üìà Momentum! HP: ${r.oldVal}‚Üí${r.newVal}`;
                    changeClass = 'positive';
                    break;
                case 'sacrifice_buff':
                    changeText = `‚ú® Empowered! +3 HP, +1 Fire`;
                    changeClass = 'positive';
                    break;
                case 'mirror':
                    changeText = `ü™û Fire: ${r.oldFire}‚Üí${r.newFire}, Dodge: ${r.oldDodge}‚Üí${r.newDodge}`;
                    changeClass = 'neutral';
                    break;
                case 'poison':
                    changeText = `‚ò†Ô∏è Poisoned! (${r.value} dmg/turn)`;
                    changeClass = 'negative';
                    break;
                case 'explosion':
                    changeText = `üí• Exploded! -${r.damage} HP, -${r.oldAmmo} Ammo`;
                    changeClass = 'negative';
                    break;
                case 'vest':
                    changeText = `ü¶∫ Bulletproof Vest equipped! (3 hits)`;
                    changeClass = 'positive';
                    break;
            }
           
            affectedHTML += `
                <div class="affected-card">
                    <span class="name">${r.card.portrait} ${r.card.name}</span>
                    <span class="change ${changeClass}">${changeText}</span>
                </div>
            `;
        });
    }
   
    $('eventAffectedList').innerHTML = affectedHTML;
    show('eventPanel');
}

function closeEventPanel() {
    hide('eventPanel');
    checkVictory(); // Check if event caused a win condition
   
    // If AI was waiting, continue
    if (G.aiWaitingPanel === 'eventPanel') {
        aiContinue();
    }
}

function dismissEvent() {
    hide('eventBanner');
}

function checkVictory() {
    let winner = null;
   
    // Score victory
    if (G.scores.outlaw >= 10) winner = 'outlaw';
    if (G.scores.law >= 10) winner = 'law';
   
    // Elimination victory (arrested cards DON'T COUNT as active)
    const activeLaw = G.field.law.filter(c => !c.arrested).length;
    const activeOutlaw = G.field.outlaw.filter(c => !c.arrested).length;

    if (activeLaw === 0 && G.decks.law.length === 0 && G.hands.law.length === 0) {
        winner = 'outlaw';
    }
    if (activeOutlaw === 0 && G.decks.outlaw.length === 0 && G.hands.outlaw.length === 0) {
        winner = 'law';
    }
    
    // ‚Üê THIS WAS MISSING:
    if (winner) {
        showVictory(winner);
    }
}

function showVictory(winner) {
    clearCombatPrediction(); // Clear tooltip immediately
    $('victoryScreen').className = 'victory-screen ' + winner;
    $('victoryTitle').textContent = winner === 'outlaw' ? 'üî´ OUTLAWS WIN!' : 'üöî THE LAW WINS!';
    $('victoryStats').innerHTML = `
        <p><strong>Final Score</strong></p>
        <p>Outlaws: ${G.scores.outlaw} | Law: ${G.scores.law}</p>
        <p>Rounds: ${G.round}</p>
    `;
    show('victoryScreen');
}

function returnToMenu() {
    hide('victoryScreen');
    hide('gameScreen');
    show('menuScreen');
    clearCombatPrediction(); // Clear any lingering tooltips
}

// ============ CARD CREATOR ============
function showCardCreator() {
    show('cardCreator');  // ‚Üê SHOW THE MODAL FIRST!
    
    loadData();
    updateCardCreatorAbilities();
    $('ccName').value = '';
    $('ccPortrait').value = '';
    $('ccHP').value = 10;
    $('ccAmmo').value = 6;
    $('ccMove').value = 2;
    $('ccFire').value = 3;
    $('ccSupp').value = 2;
    $('ccDodge').value = 15;
    $('ccCost').value = 3;
    $('ccAbility1').value = '';
    $('ccAbility2').value = '';
    $('ccAbility3').value = '';
    $('ccFaction').value = 'outlaw';
    
    // Reset color pickers to defaults
    $('ccColorName').value = '#ffffff';
    $('ccColorHP').value = '#5cb85c';
    $('ccColorAmmo').value = '#d9a34a';
    $('ccColorMove').value = '#5bc0de';
    $('ccColorFire').value = '#c9302c';
    $('ccColorSupp').value = '#9b6bcc';
    $('ccColorDodge').value = '#3dbdbd';
    $('ccColorAcc').value = '#facc15';
    $('ccColorState').value = '#4ade80';
    
    // Reset background
    $('ccBgUrl').value = '';
    $('ccBgFile').value = '';
    $('cardPreview').style.backgroundImage = '';
    $('bgPreview').textContent = 'No background selected';
    $('bgPreview').style.color = '#666';
    
    // Add input listeners for real-time preview updates
    $('ccName').oninput = updatePreview;
    $('ccPortrait').oninput = updatePreview;
    $('ccHP').oninput = updatePreview;
    $('ccAmmo').oninput = updatePreview;
    $('ccMove').oninput = updatePreview;
    $('ccFire').oninput = updatePreview;
    $('ccSupp').oninput = updatePreview;
    $('ccDodge').oninput = updatePreview;
    $('ccBgUrl').oninput = previewBackground;
    
    // Initial preview render
    updatePreview();
}

function saveCard() {
    const name = $('ccName').value.trim();
    if (!name) {
        alert('Enter a card name!');
        return;
    }

    const abilities = [
        $('ccAbility1').value,
        $('ccAbility2').value,
        $('ccAbility3').value
    ].filter(a => a && a !== '');

const card = {
        name: name,
        portrait: $('ccPortrait').value || 'üé≠',
        hp: parseInt($('ccHP').value) || 10,
        maxHp: parseInt($('ccHP').value) || 10,
        ammo: parseInt($('ccAmmo').value) || 6,
        maxAmmo: parseInt($('ccAmmo').value) || 6,
        move: parseInt($('ccMove').value) || 2,
        fire: parseInt($('ccFire').value) || 3,
        supp: parseInt($('ccSupp').value) || 2,
        dodge: parseInt($('ccDodge').value) || 15,
        cost: parseInt($('ccCost').value) || 3,
        abilities: abilities,
        accuracy: 100,
        faction: $('ccFaction').value,
        background: null,
        textColors: {
            name: $('ccColorName').value || '#ffffff',
            hp: $('ccColorHP').value || '#5cb85c',
            ammo: $('ccColorAmmo').value || '#d9a34a',
            move: $('ccColorMove').value || '#5bc0de',
            fire: $('ccColorFire').value || '#c9302c',
            supp: $('ccColorSupp').value || '#9b6bcc',
            dodge: $('ccColorDodge').value || '#3dbdbd',
            acc: $('ccColorAcc').value || '#facc15',
            state: $('ccColorState').value || '#4ade80'
        }
    };

    // Handle background image
    const url = $('ccBgUrl').value.trim();
    const file = $('ccBgFile').files[0];

    if (url) {
        card.background = url;  // Store direct URL
    } else if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            card.background = e.target.result;  // base64 data URL
            finishSave(card);
        };
        reader.readAsDataURL(file);
        return;  // Wait for file read ‚Äî don't save yet
    }

    // If no image or URL, save immediately
    finishSave(card);
}

function finishSave(card) {
    // Initialize vest if bulletproof
    if (card.abilities.includes('bulletproof')) {
        card.vestHitsRemaining = 3;
    }

    saveCustomCard(card);
    alert(`${card.name} saved to ${card.faction} faction!`);
    closeModal('cardCreator');

    // Clear inputs
    $('ccBgUrl').value = '';
    $('ccBgFile').value = '';
    $('bgPreview').textContent = 'No background selected';
    $('bgPreview').style.color = '#666';
}

// ============ CARD PREVIEW FUNCTIONS ============
function updatePreview() {
    // Update name
    const name = $('ccName').value.trim() || 'CARD NAME';
    $('previewName').textContent = name;
    $('previewName').style.color = $('ccColorName').value;
    
    // Update portrait
    const portrait = $('ccPortrait').value.trim() || '';
    $('previewPortrait').textContent = portrait;
    
    // Update stats with colors
    const hp = $('ccHP').value || 10;
    const ammo = $('ccAmmo').value || 6;
    const move = $('ccMove').value || 2;
    const fire = $('ccFire').value || 3;
    const supp = $('ccSupp').value || 2;
    const dodge = $('ccDodge').value || 15;
    
    $('previewHP').textContent = `HP: ${hp}/${hp}`;
    $('previewHP').style.color = $('ccColorHP').value;
    
    $('previewAmmo').textContent = `Ammo: ${ammo}/${ammo}`;
    $('previewAmmo').style.color = $('ccColorAmmo').value;
    
    $('previewMove').textContent = `Move: ${move}`;
    $('previewMove').style.color = $('ccColorMove').value;
    
    $('previewFire').textContent = `Fire: ${fire}`;
    $('previewFire').style.color = $('ccColorFire').value;
    
    $('previewSupp').textContent = `Supp: ${supp}`;
    $('previewSupp').style.color = $('ccColorSupp').value;
    
    $('previewDodge').textContent = `Dodge: ${dodge}%`;
    $('previewDodge').style.color = $('ccColorDodge').value;
    
    $('previewAcc').textContent = `Acc: 100%`;
    $('previewAcc').style.color = $('ccColorAcc').value;
    
    $('previewState').textContent = `State: 100/100`;
    $('previewState').style.color = $('ccColorState').value;
}

function previewBackground() {
    const url = $('ccBgUrl').value.trim();
    const file = $('ccBgFile').files[0];
    
    if (url) {
        $('cardPreview').style.backgroundImage = `url('${url}')`;
        $('bgPreview').textContent = '‚úì URL background loaded';
        $('bgPreview').style.color = '#4ade80';
    } else if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            $('cardPreview').style.backgroundImage = `url('${e.target.result}')`;
            $('bgPreview').textContent = '‚úì Image uploaded: ' + file.name;
            $('bgPreview').style.color = '#4ade80';
        };
        reader.readAsDataURL(file);
    } else {
        $('cardPreview').style.backgroundImage = '';
        $('bgPreview').textContent = 'No background selected';
        $('bgPreview').style.color = '#666';
    }
}

// ============ EVENT CREATOR ============
function showEventCreator() {
    $('evName').value = '';
    $('evDesc').value = '';
    $('evType').value = 'damage_all';
    $('evFaction').value = 'both';
    $('evTargetCount').value = 'all';
    $('evValue').value = 2;
    $('evDuration').value = 0;
    show('eventCreator');
}

// ============ CARD PREVIEW FUNCTIONS ============
function updatePreview() {
    // Update name
    const name = $('ccName').value.trim() || 'CARD NAME';
    $('previewName').textContent = name;
    $('previewName').style.color = $('ccColorName').value;
    
    // Update portrait
    const portrait = $('ccPortrait').value.trim() || '';
    $('previewPortrait').textContent = portrait;
    
    // Update stats with colors
    const hp = $('ccHP').value || 10;
    const ammo = $('ccAmmo').value || 6;
    const move = $('ccMove').value || 2;
    const fire = $('ccFire').value || 3;
    const supp = $('ccSupp').value || 2;
    const dodge = $('ccDodge').value || 15;
    
    $('previewHP').textContent = `HP: ${hp}/${hp}`;
    $('previewHP').style.color = $('ccColorHP').value;
    
    $('previewAmmo').textContent = `Ammo: ${ammo}/${ammo}`;
    $('previewAmmo').style.color = $('ccColorAmmo').value;
    
    $('previewMove').textContent = `Move: ${move}`;
    $('previewMove').style.color = $('ccColorMove').value;
    
    $('previewFire').textContent = `Fire: ${fire}`;
    $('previewFire').style.color = $('ccColorFire').value;
    
    $('previewSupp').textContent = `Supp: ${supp}`;
    $('previewSupp').style.color = $('ccColorSupp').value;
    
    $('previewDodge').textContent = `Dodge: ${dodge}%`;
    $('previewDodge').style.color = $('ccColorDodge').value;
    
    $('previewAcc').textContent = `Acc: 100%`;
    $('previewAcc').style.color = $('ccColorAcc').value;
    
    $('previewState').textContent = `State: 100/100`;
    $('previewState').style.color = $('ccColorState').value;
}

function previewBackground() {
    const url = $('ccBgUrl').value.trim();
    const file = $('ccBgFile').files[0];
    
    if (url) {
        $('cardPreview').style.backgroundImage = `url('${url}')`;
        $('bgPreview').textContent = '‚úì URL background loaded';
        $('bgPreview').style.color = '#4ade80';
    } else if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            $('cardPreview').style.backgroundImage = `url('${e.target.result}')`;
            $('bgPreview').textContent = '‚úì Image uploaded: ' + file.name;
            $('bgPreview').style.color = '#4ade80';
        };
        reader.readAsDataURL(file);
    } else {
        $('cardPreview').style.backgroundImage = '';
        $('bgPreview').textContent = 'No background selected';
        $('bgPreview').style.color = '#666';
    }
}

function saveEvent() {
    const name = $('evName').value.trim();
    if (!name) {
        alert('Enter an event name!');
        return;
    }
   
    const evType = $('evType').value;
    const event = {
        name: name,
        desc: $('evDesc').value || name,
        type: evType,
        faction: $('evFaction').value,
        targetCount: $('evTargetCount').value,
        value: parseInt($('evValue').value) || 0,
        duration: parseInt($('evDuration').value) || 0
    };
   
    // Add stat field for stat modification events
    if (evType === 'stat_mod' || evType === 'dodge_mod') {
        event.stat = $('evStat').value;
    }
   
    saveCustomEvent(event);
    alert(`Event "${name}" saved!`);
    closeModal('eventCreator');
}

function updateEventOptions() {
    const evType = $('evType').value;
    const statGroup = $('evStatGroup');
   
    // Show stat selector for stat modification events
    if (evType === 'stat_mod' || evType === 'dodge_mod') {
        statGroup.style.display = '';
    } else {
        statGroup.style.display = 'none';
    }
}

// ============ ABILITY CREATOR ============
function showAbilityCreator() {
    loadData();
    $('abName').value = '';
    $('abIcon').value = '‚ö°';
    $('abTrigger').value = 'on_attack';
    $('abEffect').value = 'fire_bonus';
    $('abValue').value = 2;
    $('abDesc').value = '';
    updateAbilityEffectOptions();
    updateAbilityPreview();
    show('abilityCreator');
   
    // Add live preview updates
    $('abName').oninput = updateAbilityPreview;
    $('abIcon').oninput = updateAbilityPreview;
    $('abDesc').oninput = updateAbilityPreview;
    $('abEffect').onchange = function() {
        updateValueHint();
        updateAbilityPreview();
    };
    $('abValue').oninput = updateAbilityPreview;
}

function updateAbilityEffectOptions() {
    const trigger = $('abTrigger').value;
    const effectSelect = $('abEffect');
   
    // Define which effects are available for each trigger
    const effectsByTrigger = {
        on_attack: [
            { value: 'fire_bonus', text: 'Add Fire Damage' },
            { value: 'lifesteal', text: 'Lifesteal (heal % of damage)' },
            { value: 'double_damage', text: 'Chance for Double Damage' }
        ],
        on_defend: [
            { value: 'damage_reduction', text: 'Reduce Incoming Damage %' },
            { value: 'reflect', text: 'Reflect Damage %' },
            { value: 'dodge_bonus', text: 'Extra Dodge Chance' }
        ],
        on_turn_end: [
            { value: 'heal_self', text: 'Heal Self' },
            { value: 'heal_ally', text: 'Heal Random Ally' },
            { value: 'ammo_regen', text: 'Regenerate Ammo' }
        ],
        aura: [
            { value: 'ally_fire', text: 'Allies Get Fire Bonus' },
            { value: 'ally_dodge', text: 'Allies Get Dodge Bonus' },
            { value: 'rally_bonus', text: 'Team Rally Bonus %' }
        ]
    };
   
    const options = effectsByTrigger[trigger] || [];
    effectSelect.innerHTML = options.map(o =>
        `<option value="${o.value}">${o.text}</option>`
    ).join('');
   
    updateValueHint();
}

function updateValueHint() {
    const effect = $('abEffect').value;
    const hints = {
        fire_bonus: 'Amount of bonus fire damage (1-10 recommended)',
        damage_reduction: 'Percentage of damage reduced (10-50 recommended)',
        heal_self: 'HP healed at end of turn (1-5 recommended)',
        heal_ally: 'HP healed to random ally (1-5 recommended)',
        ally_fire: 'Fire bonus given to all allies (1-3 recommended)',
        ally_dodge: 'Dodge bonus given to all allies (5-15 recommended)',
        rally_bonus: 'Bonus % added to team rally chance (5-20 recommended)',
        lifesteal: 'Percentage of damage dealt that heals you (10-50 recommended)',
        double_damage: 'Percentage chance to deal double damage (10-30 recommended)',
        reflect: 'Percentage of damage reflected back (10-30 recommended)',
        dodge_bonus: 'Extra dodge chance when attacked (5-20 recommended)',
        ammo_regen: 'Ammo regenerated at end of turn (1-3 recommended)',
        gutshot: 'Chance to cause bleeding per attack (5-25 recommended)'
    };
    $('abValueHint').textContent = hints[effect] || 'Effect value';
}

function updateAbilityPreview() {
    $('abPreviewIcon').textContent = $('abIcon').value || '‚ö°';
    $('abPreviewName').textContent = $('abName').value || 'Unnamed Ability';
    $('abPreviewDesc').textContent = $('abDesc').value || 'No description';
}

function saveAbility() {
    const name = $('abName').value.trim();
    if (!name) {
        alert('Enter an ability name!');
        return;
    }
   
    // Create ID from name (lowercase, no spaces)
    const id = 'custom_' + name.toLowerCase().replace(/[^a-z0-9]/g, '_');
   
    // Check if ability already exists
    if (G.abilities[id]) {
        if (!confirm(`An ability named "${name}" already exists. Overwrite it?`)) {
            return;
        }
    }
   
    const ability = {
        id: id,
        name: name,
        icon: $('abIcon').value || '‚ö°',
        trigger: $('abTrigger').value,
        effect: $('abEffect').value,
        value: parseInt($('abValue').value) || 1,
        desc: $('abDesc').value || name,
        custom: true
    };
   
    // Save to localStorage
    const customAbilities = JSON.parse(localStorage.getItem('bc_custom_abilities') || '{}');
    customAbilities[id] = ability;
    localStorage.setItem('bc_custom_abilities', JSON.stringify(customAbilities));
   
    loadData();
    updateCardCreatorAbilities();
   
    alert(`Ability "${name}" saved!`);
    closeModal('abilityCreator');
}

function showAbilityList() {
    loadData();
    const abilities = Object.values(G.abilities);
   
    if (abilities.length === 0) {
        $('abilityListContent').innerHTML = '<p style="color:#666;text-align:center">No abilities created yet.</p>';
    } else {
        $('abilityListContent').innerHTML = abilities.map(ab => `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:10px;margin:6px 0;background:#0d0d12;border:1px solid var(--border)">
                <div>
                    <span style="font-size:1.2em">${ab.icon}</span>
                    <strong style="color:var(--gold)">${ab.name}</strong>
                    ${ab.custom ? '<span style="color:#5cb85c;font-size:.7em;margin-left:8px">[CUSTOM]</span>' : '<span style="color:#888;font-size:.7em;margin-left:8px">[DEFAULT]</span>'}
                    <br><span style="color:#888;font-size:.85em">${ab.desc}</span>
                </div>
                ${ab.custom ? `<button class="btn btn-red" style="padding:4px 8px;font-size:.7em" onclick="deleteAbility('${ab.id}')">Delete</button>` : ''}
            </div>
        `).join('');
    }
   
    show('abilityList');
}

function deleteAbility(id) {
    if (!confirm('Delete this ability? Cards using it will lose their ability.')) return;
   
    const customAbilities = JSON.parse(localStorage.getItem('bc_custom_abilities') || '{}');
    delete customAbilities[id];
    localStorage.setItem('bc_custom_abilities', JSON.stringify(customAbilities));
   
    loadData();
    updateCardCreatorAbilities();
    showAbilityList();
}

function updateCardCreatorAbilities() {
    // Update all 3 ability selects
    ['ccAbility1', 'ccAbility2', 'ccAbility3'].forEach(selectId => {
        const select = $(selectId);
        if (!select) return;
       
        select.innerHTML = '<option value="">None</option>';
       
        Object.values(G.abilities).forEach(ab => {
            const option = document.createElement('option');
            option.value = ab.id;
            option.textContent = `${ab.icon} ${ab.name} - ${ab.desc}`;
            select.appendChild(option);
        });
    });
}

// ============ DECK BUILDER ============
let deckBuilderFaction = 'outlaw';
let tempDeck = [];

function showDeckBuilder() {
    loadData();
    deckBuilderFaction = 'outlaw';
    tempDeck = G.savedDecks.outlaw ? [...G.savedDecks.outlaw] : [];
    renderDeckBuilder();
    show('deckBuilder');
}

function switchDeckFaction(faction) {
    // Save current before switching
    deckBuilderFaction = faction;
    tempDeck = G.savedDecks[faction] ? [...G.savedDecks[faction]] : [];
    document.querySelectorAll('.faction-tab').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');
    renderDeckBuilder();
}

function renderDeckBuilder() {
    const cards = G.allCards[deckBuilderFaction];
    $('cardPool').innerHTML = cards.map(c => {
        const isCustom = c.id.startsWith('custom_');
        return `
        <div class="card ${c.faction}" style="cursor:pointer;position:relative">
            <div onclick="addToDeck('${c.id}')">
                <div class="card-name">${c.name}${isCustom ? ' <span style="color:#5cb85c;font-size:.7em">[CUSTOM]</span>' : ''}</div>
                <div class="card-portrait">${c.portrait}</div>
                                <div class="card-stats">
                    <span class="stat-hp">HP: ${c.hp}/${c.maxHp}</span>
                    <span class="stat-ammo">Ammo: ${c.ammo}/${c.maxAmmo}</span>
                    <span class="stat-move">Move: ${c.move}</span>
                    <span class="stat-fire">Fire: ${c.fire}</span>
                    <span class="stat-supp">Supp: ${c.supp}</span>
                    <span class="stat-dodge">Dodge: ${c.dodge}%</span>
                    ${c.abilities && c.abilities.length > 0 ? `<span style="color:#c9a227;font-size:7px;margin-top:2px;display:block;text-align:center">${c.abilities.map(ab => G.abilities[ab]?.name || ab).join(', ')}</span>` : ''}
                </div>
            </div>
            ${isCustom ? `<button onclick="event.stopPropagation();deleteCustomCard('${c.id}')" style="position:absolute;top:2px;right:2px;background:#c9302c;border:none;color:#fff;padding:2px 6px;font-size:.7em;cursor:pointer;border-radius:2px">‚úï</button>` : ''}
        </div>
        `;
    }).join('');
   
    renderDeckList();
}

function deleteCustomCard(cardId) {
    if (!confirm(`Delete "${cardId}" permanently? This cannot be undone!`)) {
        return;
    }
   
    const customCards = JSON.parse(localStorage.getItem('bc_custom_cards') || '{"outlaw":[],"law":[]}');
    customCards[deckBuilderFaction] = customCards[deckBuilderFaction].filter(c => c.id !== cardId);
    localStorage.setItem('bc_custom_cards', JSON.stringify(customCards));
   
    tempDeck = tempDeck.filter(id => {
        const baseId = id.replace(/_\d{1,2}$/, '');
        return baseId !== cardId;
    });
   
    loadData();
    renderDeckBuilder();
   
    alert('Custom card deleted!');
}

function renderDeckList() {
    const cards = G.allCards[deckBuilderFaction];
    $('deckCount').textContent = tempDeck.length;
   
    // Count occurrences - only strip short suffixes like _2, _3 (not timestamps)
    const counts = {};
    tempDeck.forEach(id => {
        const baseId = id.replace(/_\d{1,2}$/, '');
        counts[baseId] = (counts[baseId] || 0) + 1;
    });
   
    $('deckList').innerHTML = Object.entries(counts).map(([id, count]) => {
        const card = cards.find(c => c.id === id || c.id.replace(/_\d{1,2}$/, '') === id);
        return card ? `
            <div class="deck-item">
                <span>${card.portrait} ${card.name}</span>
                <span>x${count} <button onclick="removeFromDeck('${id}')" style="background:none;border:none;color:#c9302c;cursor:pointer">‚úï</button></span>
            </div>
        ` : '';
    }).join('');
}

function addToDeck(id) {
    if (tempDeck.length >= 20) {
        alert('Deck is full! (20 cards max)');
        return;
    }
   
    // Count existing copies - only match exact id or id with short suffix (_2, _3, etc)
    const count = tempDeck.filter(i => i === id || i.replace(/_\d{1,2}$/, '') === id).length;
    tempDeck.push(count > 0 ? `${id}_${count + 1}` : id);
    renderDeckList();
}

function removeFromDeck(id) {
    // Find and remove one instance - match exact or with short suffix
    const idx = tempDeck.findIndex(i => i === id || i.replace(/_\d{1,2}$/, '') === id);
    if (idx !== -1) {
        tempDeck.splice(idx, 1);
        renderDeckList();
    }
}

function saveDeck() {
    saveCurrentDeck(deckBuilderFaction, tempDeck);
    alert(`${deckBuilderFaction.toUpperCase()} deck saved! (${tempDeck.length} cards)`);
}

function clearDeck() {
    tempDeck = [];
    renderDeckList();
}

// ============ DECK EXPORT/IMPORT ============
function exportDecks() {
    const exportData = {
        version: '1.1',
        exportDate: new Date().toISOString(),
        decks: G.savedDecks,
        customCards: JSON.parse(localStorage.getItem('bc_custom_cards') || '{"outlaw":[],"law":[]}'),
        customEvents: JSON.parse(localStorage.getItem('bc_custom_events') || '[]'),
        customAbilities: JSON.parse(localStorage.getItem('bc_custom_abilities') || '{}')
    };
   
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `bonnie_clyde_decks_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
   
    log('Decks exported to JSON file!', 'event');
}

function importDecks() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
       
        const reader = new FileReader();
        reader.onload = (evt) => {
            try {
                const data = JSON.parse(evt.target.result);
               
                if (data.decks) {
                    localStorage.setItem('bc_decks', JSON.stringify(data.decks));
                }
                if (data.customCards) {
                    localStorage.setItem('bc_custom_cards', JSON.stringify(data.customCards));
                }
                if (data.customEvents) {
                    localStorage.setItem('bc_custom_events', JSON.stringify(data.customEvents));
                }
                if (data.customAbilities) {
                    localStorage.setItem('bc_custom_abilities', JSON.stringify(data.customAbilities));
                }
               
                loadData();
               
                const imported = [];
                if (data.decks) imported.push('decks');
                if (data.customCards) imported.push('custom cards');
                if (data.customEvents) imported.push('custom events');
                if (data.customAbilities) imported.push('custom abilities');
               
                alert(`Successfully imported: ${imported.join(', ')}!`);
               
                // Refresh deck builder if open
                if (!$('deckBuilder').classList.contains('hidden')) {
                    tempDeck = G.savedDecks[deckBuilderFaction] ? [...G.savedDecks[deckBuilderFaction]] : [];
                    renderDeckBuilder();
                }
            } catch (err) {
                alert('Error importing file: ' + err.message);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

// ============ MANUAL EVENT TRIGGER ============
function showEventTrigger() {
    if (!isPlayerTurn()) {
        log('Not your turn!', G.turn);
        return;
    }
   
    // Check if already used this turn
    if (G.manualEventUsed) {
        log('Event already triggered this turn!', G.turn);
        return;
    }
   
    // Build event list
    const eventList = $('eventTriggerList');
    eventList.innerHTML = G.events.map((evt, idx) => `
        <div onclick="triggerManualEvent(${idx})" style="cursor:pointer;margin:6px 0;padding:12px;border:1px solid var(--border);background:#15151d;transition:all .2s">
            <div style="display:flex;justify-content:space-between;align-items:center">
                <div style="flex:1">
                    <div style="font-weight:600;color:var(--gold);font-size:.95em">${evt.name}</div>
                    <div style="font-size:.8em;color:#888;margin-top:4px">${evt.desc}</div>
                    <div style="font-size:.75em;color:#666;margin-top:6px">
                        Type: ${evt.type} | Faction: ${evt.faction} | Value: ${evt.value}
                    </div>
                </div>
                <div style="color:#aaa;font-size:1.5em;margin-left:12px">üé≤</div>
            </div>
        </div>
    `).join('');
   
    show('eventTriggerModal');
}

function triggerManualEvent(eventIndex) {
    const event = G.events[eventIndex];
    if (!event) return;
   
    // Mark as used
    G.manualEventUsed = true;
   
    // Trigger the event
    const results = applyEvent(event);
    showEventPanel(event, results);
    addEventToFeeds('üé≤ ' + event.name + ' [MANUAL]', event.desc);
   
    // Close modal
    closeModal('eventTriggerModal');
    updateUI();
}

// ============ RULES ============
function showRules() {
    show('rulesModal');
}

function clearAllData() {
    if (confirm('‚ö†Ô∏è This will DELETE all your:\n\n‚Ä¢ Custom Cards\n‚Ä¢ Custom Events\n‚Ä¢ Custom Abilities\n‚Ä¢ Saved Decks\n\nAre you sure?')) {
        localStorage.removeItem('bc_custom_cards');
        localStorage.removeItem('bc_custom_events');
        localStorage.removeItem('bc_custom_abilities');
        localStorage.removeItem('bc_decks');
        loadData();
        alert('‚úÖ All data cleared! Game reset to defaults.');
    }
}

// ============ INIT ============
loadData();
</script>

<!-- Floating Combat Predictor Tooltip -->
<div id="combatPredictor" class="combat-predictor-tooltip hidden"></div>

<!-- Signal Charge Screen Flash Overlay -->
<div id="screenFlash" class="screen-flash hidden"></div>

</body>
</html>